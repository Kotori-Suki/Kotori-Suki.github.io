<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2022/03/15/UE4/UE4CPP/Unreal%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E4%B9%8B%E4%B8%80/"><title>Unreal 常用接口源码分析 之一 - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unreal 常用接口源码分析 之一</h1><div class="meta"><span class="item" title="创建时间：2022-03-15 11:56:16"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-15T11:56:16+08:00">2022-03-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicli3sbvtj20zk0m8x6p.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2022/03/15/UE4/UE4CPP/Unreal%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E4%B9%8B%E4%B8%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="unreal-常用接口源码分析-之一"><a class="anchor" href="#unreal-常用接口源码分析-之一">#</a> Unreal 常用接口源码分析 之一</h1><p>简介：本篇包括对 NewObject, SpawnActor, CreateDefaultSubobject 等对象构造相关的类及函数的解析。</p><h2 id="newobjectclassname"><a class="anchor" href="#newobjectclassname">#</a> NewObject&lt;ClassName&gt;(...)</h2><p>首先，我们使用的 <code>NewObject</code> 函数是定义在 <code>UObjectGlobals</code> 类中的，拥有三个重载。其函数体如下：</p><p><img data-src="NewObject_1.png" alt="NewObject_1"></p><p><img data-src="NewObject_2.png" alt="NewObject_2"></p><p><img data-src="NewObject_3.png" alt="NewObject_3"></p><p>从上面代码中可以看出，三个重载函数如出一辙。只是为了方便开发者使用而实现的不同版本 <code>NewObject&lt;...&gt;()</code> 。步骤如下：</p><ol><li>首先如果没有传入子类名称且 Outer 为子类则会导致 &quot;New&quot;(与 cpp 的 new 不太一样) 出来的对象的名称与实际名称不一致 (这种对象不符合 unreal 标准)，所以需要触发断言。</li><li>初始化静态构造对象的参数，调用 <code>StaticConstructObject_Internal()</code> 函数静态构造此对象。(重要)</li></ol><h3 id="staticconstructobject_internal"><a class="anchor" href="#staticconstructobject_internal">#</a> StaticConstructObject_Internal</h3><p>函数定义如下：</p><p></p><figure class="highlight c++"><figcaption><span>StaticConstructObject_Internal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectGlobals.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">StaticConstructObject_Internal</span><span class="params">(<span class="keyword">const</span> FStaticConstructObjectParameters&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> UClass* InClass = Params.Class;</span><br><span class="line">	UObject* InOuter = Params.Outer;</span><br><span class="line">	<span class="keyword">const</span> FName&amp; InName = Params.Name;</span><br><span class="line">	EObjectFlags InFlags = Params.SetFlags;</span><br><span class="line">	UObject* InTemplate = Params.Template;</span><br><span class="line">    </span><br><span class="line">    UObject* Result = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子对象总是在构造函数中被创建，不需要重新创建它们，除非它们的原型不是CDO，或者是由来蓝图生成的对象。</span></span><br><span class="line">    <span class="comment">// 如果要重用现有的子对象，则不能对其调用BeginDestroy。所以我们需要将此信息传递给StaticAllocateObject</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bIsNativeClass = InClass-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_Native | CLASS_Intrinsic);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bIsNativeFromCDO = bIsNativeClass &amp;&amp;</span><br><span class="line">		(	</span><br><span class="line">			!InTemplate || </span><br><span class="line">			(InName != NAME_None &amp;&amp; (Params.bAssumeTemplateIsArchetype || InTemplate == UObject::<span class="built_in">GetArchetypeFromRequiredInfo</span>(InClass, InOuter, InName, InFlags)))</span><br><span class="line">			);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bCanRecycleSubobjects = bIsNativeFromCDO &amp;&amp; (!(InFlags &amp; RF_DefaultSubObject) || !FUObjectThreadContext::<span class="built_in">Get</span>().IsInConstructor)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">bool</span> bRecycledSubobject = <span class="literal">false</span>;	</span><br><span class="line">	Result = <span class="built_in">StaticAllocateObject</span>(InClass, InOuter, InName, InFlags, Params.InternalSetFlags, bCanRecycleSubobjects, &amp;bRecycledSubobject, Params.ExternalPackage);</span><br><span class="line">	<span class="built_in">check</span>(Result != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 不要对回收的子对象调用构造函数，它们尚未被销毁。</span></span><br><span class="line">	<span class="keyword">if</span> (!bRecycledSubobject)</span><br><span class="line">	&#123;</span><br><span class="line">		(*InClass-&gt;ClassConstructor)( <span class="built_in">FObjectInitializer</span>(Result, InTemplate, Params.bCopyTransientsFromClassDefaults, <span class="literal">true</span>, Params.InstanceGraph) );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>( GIsEditor &amp;&amp; GUndo &amp;&amp; (InFlags &amp; RF_Transactional) &amp;&amp; !(InFlags &amp; RF_NeedLoad) &amp;&amp; !InClass-&gt;<span class="built_in">IsChildOf</span>(UField::<span class="built_in">StaticClass</span>()) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 设置 PF_PendingKill 并更新撤销缓存，因此撤销操作将设置新创建的对象的 PF_PendingKill</span></span><br><span class="line">		Result-&gt;<span class="built_in">MarkPendingKill</span>();</span><br><span class="line">		<span class="built_in">SaveToTransactionBuffer</span>(Result, <span class="literal">false</span>);</span><br><span class="line">		Result-&gt;<span class="built_in">ClearPendingKill</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此函数理解起来也不算难，步骤可分为：</p><ol><li>先取出传进来的参数</li><li>然后确认该类的一些参数，如：是否为本地类 (cpp 定义的类)，是否为本地类且由 CDO 创建，是否可以回收子类 (采取不同的构造策略)</li><li>调用 <code>StaticAllocateObject()</code> 静态分配对象，并确认该对象是否为回收的子对象。如果不是则使用 <code>FObjectInitializer</code> 初始化此对象的属性，完成此对象的构造。(重要)</li></ol><h3 id="staticallocateobject"><a class="anchor" href="#staticallocateobject">#</a> StaticAllocateObject</h3><p>函数定义如下：</p><p></p><figure class="highlight c++"><figcaption><span>StaticAllocateObject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectGlobals.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">StaticAllocateObject</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> UClass*	InClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	UObject*		InOuter,</span></span></span><br><span class="line"><span class="params"><span class="function">	FName			InName,</span></span></span><br><span class="line"><span class="params"><span class="function">	EObjectFlags	InFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	EInternalObjectFlags InternalSetFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">bool</span> bCanRecycleSubobjects,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">bool</span>* bOutRecycledSubobject,</span></span></span><br><span class="line"><span class="params"><span class="function">	UPackage* ExternalPackage</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当前 NewObject 创建的对象是否为默认对象，即CDO</span></span><br><span class="line">	<span class="keyword">bool</span> bCreatingCDO = (InFlags &amp; RF_ClassDefaultObject) != <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bCreatingCDO)</span><br><span class="line">	&#123;</span><br><span class="line">		InName = InClass-&gt;<span class="built_in">GetDefaultObjectName</span>();</span><br><span class="line">        <span class="comment">// 绝不调用 CDO 的 PostLoad.</span></span><br><span class="line">		InFlags &amp;= ~(RF_NeedPostLoad|RF_NeedPostLoadSubobjects);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    UObject* Obj = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(InName == NAME_None)</span><br><span class="line">	&#123;</span><br><span class="line">        InName = <span class="built_in">MakeUniqueObjectName</span>(InOuter, InClass);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 确认对象是否已经存在</span></span><br><span class="line">		Obj = <span class="built_in">StaticFindObjectFastInternal</span>( <span class="comment">/*Class=*/</span> <span class="literal">NULL</span>, InOuter, InName, <span class="literal">true</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FLinkerLoad*	Linker						= <span class="literal">NULL</span>;</span><br><span class="line">	int32			LinkerIndex					= INDEX_NONE;</span><br><span class="line">	<span class="keyword">bool</span>			bWasConstructedOnOldObject	= <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 为真，如果需要分配的对象已经存在且是一个子对象</span></span><br><span class="line">	<span class="keyword">bool</span> bSubObject = <span class="literal">false</span>;</span><br><span class="line">	int32 TotalSize = InClass-&gt;<span class="built_in">GetPropertiesSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( Obj == <span class="literal">NULL</span> )</span><br><span class="line">	&#123;	</span><br><span class="line">		int32 Alignment	= FMath::<span class="built_in">Max</span>( <span class="number">4</span>, InClass-&gt;<span class="built_in">GetMinAlignment</span>() );</span><br><span class="line">		Obj = (UObject *)GUObjectAllocator.<span class="built_in">AllocateUObject</span>(TotalSize,Alignment,GIsInitialLoad);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        ObjectRestoreAfterInitProps = Obj-&gt;<span class="built_in">GetRestoreForUObjectOverwrite</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存链接器，标志，下标，本地类信息</span></span><br><span class="line">		Linker		= Obj-&gt;<span class="built_in">GetLinker</span>();</span><br><span class="line">		LinkerIndex = Obj-&gt;<span class="built_in">GetLinkerIndex</span>();</span><br><span class="line">		InternalSetFlags |= (Obj-&gt;<span class="built_in">GetInternalFlags</span>() &amp; (EInternalObjectFlags::Native | EInternalObjectFlags::RootSet));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( bCreatingCDO )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">check</span>(Obj-&gt;<span class="built_in">HasAllFlags</span>(RF_ClassDefaultObject));</span><br><span class="line">			Obj-&gt;<span class="built_in">SetFlags</span>(InFlags);</span><br><span class="line">			Obj-&gt;<span class="built_in">SetInternalFlags</span>(InternalSetFlags);</span><br><span class="line">            <span class="comment">// 绝不调用 CDO 的 PostLoad 函数</span></span><br><span class="line">			Obj-&gt;<span class="built_in">ClearFlags</span>(RF_NeedPostLoad|RF_NeedPostLoadSubobjects);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 子对象总是在构造函数中被创建，不需要重新创建它们，除非它们的原型不是CDO或是蓝图生成的对象</span></span><br><span class="line">        <span class="keyword">if</span> (!bCreatingCDO &amp;&amp; (!bCanRecycleSubobjects || !Obj-&gt;<span class="built_in">IsDefaultSubobject</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 销毁对象。</span></span><br><span class="line">            <span class="comment">// 确认此对象没有被销毁。</span></span><br><span class="line">			<span class="keyword">if</span>(!Obj-&gt;<span class="built_in">HasAnyFlags</span>(RF_FinishDestroyed))</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 在我们销毁之前，获取名称，因为销毁将导致对象被重命名。</span></span><br><span class="line">				FString OldName = Obj-&gt;<span class="built_in">GetFullName</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开始异步对象清除</span></span><br><span class="line">				Obj-&gt;<span class="built_in">ConditionalBeginDestroy</span>();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">bool</span> bPrinted = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">double</span> StallStart = <span class="number">0.0</span>;</span><br><span class="line">                <span class="comment">// 等待对象异步清除结束</span></span><br><span class="line">				<span class="keyword">while</span> (!Obj-&gt;<span class="built_in">IsReadyForFinishDestroy</span>()) </span><br><span class="line">				&#123;</span><br><span class="line">                    FPlatformProcess::<span class="built_in">Sleep</span>(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 完成对象销毁</span></span><br><span class="line">				Obj-&gt;<span class="built_in">ConditionalFinishDestroy</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			GUObjectArray.<span class="built_in">LockInternalArray</span>();</span><br><span class="line">			Obj-&gt;~<span class="built_in">UObject</span>();</span><br><span class="line">			GUObjectArray.<span class="built_in">UnlockInternalArray</span>();</span><br><span class="line">			bWasConstructedOnOldObject	= <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			bSubObject = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果类是临时的，非原型对象必须是临时的</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">const</span> bCreatingArchetype = (InFlags &amp; RF_ArchetypeObject) != <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ( !bCreatingCDO &amp;&amp; InClass-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_Transient) &amp;&amp; !bCreatingArchetype )</span><br><span class="line">	&#123;</span><br><span class="line">		InFlags |= RF_Transient;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bSubObject)</span><br><span class="line">	&#123;</span><br><span class="line">		FMemory::<span class="built_in">Memzero</span>((<span class="keyword">void</span> *)Obj, TotalSize);</span><br><span class="line">		<span class="keyword">new</span> ((<span class="keyword">void</span> *)Obj) <span class="built_in">UObjectBase</span>(<span class="keyword">const_cast</span>&lt;UClass*&gt;(InClass), InFlags|RF_NeedInitialization, InternalSetFlags, InOuter, InName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 传播标记到本地构造函数创建的子对象中</span></span><br><span class="line">		Obj-&gt;<span class="built_in">SetFlags</span>(InFlags);</span><br><span class="line">		Obj-&gt;<span class="built_in">SetInternalFlags</span>(InternalSetFlags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定了外部包，将其装载至对象中</span></span><br><span class="line">	<span class="keyword">if</span> (ExternalPackage)</span><br><span class="line">	&#123;</span><br><span class="line">		Obj-&gt;<span class="built_in">SetExternalPackage</span>(ExternalPackage);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bWasConstructedOnOldObject)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 通过链接器重关联对象</span></span><br><span class="line">		Obj-&gt;<span class="built_in">SetLinker</span>(Linker,LinkerIndex,<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span>(Linker)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">check</span>(Linker-&gt;ExportMap[LinkerIndex].Object == <span class="literal">NULL</span>);</span><br><span class="line">			Linker-&gt;ExportMap[LinkerIndex].Object = Obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsInAsyncLoadingThread</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">NotifyConstructedDuringAsyncLoading</span>(Obj, bSubObject);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 检测异步标记的合理性</span></span><br><span class="line">        <span class="comment">// 可能在游戏线程中复制对象，即使此对象仍被异步读取代码引用或已在非主线程的不同线程中被创建</span></span><br><span class="line">		Obj-&gt;<span class="built_in">ClearInternalFlags</span>(EInternalObjectFlags::AsyncLoading);</span><br><span class="line">		<span class="keyword">if</span> (Obj-&gt;<span class="built_in">HasAnyInternalFlags</span>(EInternalObjectFlags::Async) &amp;&amp; <span class="built_in">IsInGameThread</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			Obj-&gt;<span class="built_in">ClearInternalFlags</span>(EInternalObjectFlags::Async);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 让调用者知道子对象是否刚刚被回收</span></span><br><span class="line">	<span class="keyword">if</span> (bOutRecycledSubobject)</span><br><span class="line">	&#123;</span><br><span class="line">		*bOutRecycledSubobject = bSubObject;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此函数需要为三种对象分配内存，即：</p><ol><li>CDO</li><li>传入名称或未传入名称的对象</li><li>传入名称的子对象 (用于 <code>CreateDefaultSubobject</code> 等函数)</li></ol><p>以下是处理过程图解：</p><p><img data-src="StaticAllocateObject.png" alt="StaticAllocateObject"></p><p>总得来说，先用对象名称在全局的 <code>UObjectHashTable</code> 中寻找是否存在此对象，如果找不到或一开始就没有对象名称，则直接为此对象分配内存空间。如果找到了且不是子对象，则可以更新其相关标记后直接使用，如果为子对象，则需要异步销毁，因为我们子对象的外部对象的构造函数中默认需要对其进行构造。</p><p>紧接着需要为非原型对象标记为暂时性的，原型对象是保存在 <code>GUObjectArray</code> 全局数组中的对象，所有存活的对象都保存在其中。然后需要调用对象构造函数，装载外部包，重关联对象，异步通知等。</p><p>值得注意的是，这里调用构造函数的方法为：</p><p><code>new ((void *)Obj) UObjectBase(const_cast&lt;UClass*&gt;(InClass), InFlags|RF_NeedInitialization, InternalSetFlags, InOuter, InName);</code></p><p>此方法是在构造 <code>UObject</code> 的基类对象 <code>UObjectBase</code> ，并初始化其相关属性 (ClassPrivate, OuterPrivate 等) 。其子类的构造函数是在 <code>StaticAllocateObject</code> 之后，使用 <code>FObjectInitializer</code> 调用的。此外，在构造函数调用后， <code>FObjectInitializer</code> 析构时，将对子对象与组件进行初始化 (后面用到)。</p><h2 id="spawnactor"><a class="anchor" href="#spawnactor">#</a> SpawnActor(...)</h2><p><code>SpawnActorByClass</code> 这个蓝图节点相信用过 UE 的家人们都不陌生。此节点的实现依赖于 <code>UWorld::SpawnActor</code> 函数，节点的具体实现方法 请参考写者的另一篇博客。以下是对 <code>UWorld::SpawnActor</code> 的函数解析。</p><p><img data-src="SpawnActor.png" alt="SpawnActor"></p><p>内部的 <code>SpawnActor</code> 函数代码过长，不方便截图，以下是其核心代码。</p><p></p><figure class="highlight c++"><figcaption><span>SpawnActor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LevelActor.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">AActor* <span class="title">UWorld::SpawnActor</span><span class="params">( UClass* Class, FTransform <span class="keyword">const</span>* UserTransformPtr, <span class="keyword">const</span> FActorSpawnParameters&amp; SpawnParameters )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ULevel* CurrentLevel = PersistentLevel;</span><br><span class="line">    </span><br><span class="line">    ULevel* LevelToSpawnIn = SpawnParameters.OverrideLevel;</span><br><span class="line">	<span class="keyword">if</span> (LevelToSpawnIn == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果 owner 不为空，生成到 owner 所在的关卡中</span></span><br><span class="line">		LevelToSpawnIn = (SpawnParameters.Owner != <span class="literal">NULL</span>) ? SpawnParameters.Owner-&gt;<span class="built_in">GetLevel</span>() : CurrentLevel;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FName NewActorName = SpawnParameters.Name;</span><br><span class="line">	AActor* Template = SpawnParameters.Template;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>( !Template )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 使用 Actor 的默认对象作为模板</span></span><br><span class="line">		Template = Class-&gt;GetDefaultObject&lt;AActor&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (NewActorName.<span class="built_in">IsNone</span>())</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果我们使用模板对象且没有特定的名称，创建与模板相关的名称</span></span><br><span class="line">        <span class="comment">// 否则，在Stat中使用默认对象命名行为</span></span><br><span class="line">		<span class="keyword">if</span> (!Template-&gt;<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject))</span><br><span class="line">		&#123;</span><br><span class="line">			NewActorName = <span class="built_in">MakeUniqueObjectName</span>(LevelToSpawnIn, Template-&gt;<span class="built_in">GetClass</span>(), *Template-&gt;<span class="built_in">GetFName</span>().<span class="built_in">GetPlainNameString</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">StaticFindObjectFast</span>(<span class="literal">nullptr</span>, LevelToSpawnIn, NewActorName))</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果提供的名称已在使用中，则请求失败，或确定新名称(如果 NameMode == Requested)</span></span><br><span class="line">		<span class="keyword">if</span> (SpawnParameters.NameMode == FActorSpawnParameters::ESpawnActorNameMode::Requested)</span><br><span class="line">		&#123;</span><br><span class="line">			NewActorName = <span class="built_in">MakeUniqueObjectName</span>(LevelToSpawnIn, Template-&gt;<span class="built_in">GetClass</span>(), *NewActorName.<span class="built_in">GetPlainNameString</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FTransform <span class="keyword">const</span> UserTransform = UserTransformPtr ? *UserTransformPtr : FTransform::Identity;</span><br><span class="line"></span><br><span class="line">	ESpawnActorCollisionHandlingMethod CollisionHandlingOverride = SpawnParameters.SpawnCollisionHandlingOverride;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &quot;无故障&quot; 优先于包含故障的冲突处理设置</span></span><br><span class="line">	<span class="keyword">if</span> (SpawnParameters.bNoFail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 可能升级为不允许失败</span></span><br><span class="line">		<span class="keyword">if</span> (CollisionHandlingOverride == ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding)</span><br><span class="line">		&#123;</span><br><span class="line">			CollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (CollisionHandlingOverride == ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding)</span><br><span class="line">		&#123;</span><br><span class="line">			CollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重写的值(如已设置)，否则回滚到对象的首选项(默认为AlwaysSpawn)</span></span><br><span class="line">	ESpawnActorCollisionHandlingMethod <span class="keyword">const</span> CollisionHandlingMethod = (CollisionHandlingOverride == ESpawnActorCollisionHandlingMethod::Undefined) ? Template-&gt;SpawnCollisionHandlingMethod : CollisionHandlingOverride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查本地组件以确认我们是否可以避免完全生成</span></span><br><span class="line">    <span class="comment">// 注意: 我们不能在此处理所有的情况，因为我们不知道完整的组件层次结构 (直到 Actor 完全生成之前)</span></span><br><span class="line">	<span class="keyword">if</span> (CollisionHandlingMethod == ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding)</span><br><span class="line">	&#123;</span><br><span class="line">		USceneComponent* <span class="keyword">const</span> TemplateRootComponent = Template-&gt;<span class="built_in">GetRootComponent</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意: 我们遵守根组件在CDO中的所有初始变换，因此最后的变换可能正是传入的 UserTransform</span></span><br><span class="line">		FTransform <span class="keyword">const</span> FinalRootComponentTransform =</span><br><span class="line">			TemplateRootComponent</span><br><span class="line">			? <span class="built_in">FTransform</span>(TemplateRootComponent-&gt;<span class="built_in">GetRelativeRotation</span>(), TemplateRootComponent-&gt;<span class="built_in">GetRelativeLocation</span>(), TemplateRootComponent-&gt;<span class="built_in">GetRelativeScale3D</span>()) * UserTransform</span><br><span class="line">			: UserTransform;</span><br><span class="line"></span><br><span class="line">		FVector <span class="keyword">const</span> FinalRootLocation = FinalRootComponentTransform.<span class="built_in">GetLocation</span>();</span><br><span class="line">		FRotator <span class="keyword">const</span> FinalRootRotation = FinalRootComponentTransform.<span class="built_in">Rotator</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">EncroachingBlockingGeometry</span>(Template, FinalRootLocation, FinalRootRotation))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 与本地组件发生碰撞，这足以拒绝此 Actor 的生成</span></span><br><span class="line">			<span class="built_in">UE_LOG</span>(LogSpawn, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;SpawnActor failed because of collision at the spawn location [%s] for [%s]&quot;</span>), *FinalRootLocation.<span class="built_in">ToString</span>(), *Class-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    EObjectFlags ActorFlags = SpawnParameters.ObjectFlags;</span><br><span class="line"></span><br><span class="line">	UPackage* ExternalPackage = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正生成 Actor 对象</span></span><br><span class="line">	AActor* <span class="keyword">const</span> Actor = NewObject&lt;AActor&gt;(LevelToSpawnIn, Class, NewActorName, ActorFlags, Template, <span class="literal">false</span><span class="comment">/*bCopyTransientsFromClassDefaults*/</span>, <span class="literal">nullptr</span><span class="comment">/*InInstanceGraph*/</span>, ExternalPackage);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> ( GUndo )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 如果我们正在生成外部的 Actor，则在不事先捕获业务的情况下清除脏标记</span></span><br><span class="line">        <span class="comment">// 这允许业务在捕获包的当前状态时将其捕获为非脏，这正是正确的外部参与者行为所需要的</span></span><br><span class="line">		<span class="keyword">if</span> (ExternalPackage)</span><br><span class="line">		&#123;</span><br><span class="line">			LevelToSpawnIn-&gt;<span class="built_in">GetPackage</span>()-&gt;<span class="built_in">ClearDirtyFlag</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ModifyLevel</span>( LevelToSpawnIn );</span><br><span class="line">	&#125;</span><br><span class="line">	LevelToSpawnIn-&gt;Actors.<span class="built_in">Add</span>( Actor );</span><br><span class="line">	LevelToSpawnIn-&gt;ActorsForGC.<span class="built_in">Add</span>(Actor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 告诉 Actor 使用哪个生成策略，以免被重写</span></span><br><span class="line">	Actor-&gt;SpawnCollisionHandlingMethod = CollisionHandlingMethod;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 广播代理，在 Actor 及其包含的组件初始化完成之前</span></span><br><span class="line">	OnActorPreSpawnInitialization.<span class="built_in">Broadcast</span>(Actor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后处理 Actor 生成初始化。</span></span><br><span class="line">    <span class="comment">// 此处将设置 Actor 的基础属性(Owner，Instigator等)</span></span><br><span class="line">    <span class="comment">// 预初始化组件，构造Actor，完成所有组件的组装等</span></span><br><span class="line">    <span class="comment">// 调用组件的创建回调(OnComponentCreated)，初始化函数(InitializeComponent)，后处理初始化函数(PostInitializeComponents)</span></span><br><span class="line">	Actor-&gt;<span class="built_in">PostSpawnInitialize</span>(UserTransform, SpawnParameters.Owner, SpawnParameters.Instigator, SpawnParameters.<span class="built_in">IsRemoteOwned</span>(), SpawnParameters.bNoFail, SpawnParameters.bDeferConstruction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们正在生成一个外部的 Actor，在后处理生成初始化(可能通过运行构造脚本使关卡包成为脏数据)之后清除脏标记</span></span><br><span class="line">	<span class="keyword">if</span> (ExternalPackage)</span><br><span class="line">	&#123;</span><br><span class="line">		LevelToSpawnIn-&gt;<span class="built_in">GetPackage</span>()-&gt;<span class="built_in">ClearDirtyFlag</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    Actor-&gt;<span class="built_in">CheckDefaultSubobjects</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 广播生成通知</span></span><br><span class="line">	OnActorSpawned.<span class="built_in">Broadcast</span>(Actor);</span><br><span class="line">    <span class="comment">// 添加此新生成的 Actor 到网络 Actor 列表中。</span></span><br><span class="line">    <span class="comment">// 在 PostSpawnInitialize 之后添加，以便 Actor 已经完成生成</span></span><br><span class="line">	<span class="built_in">AddNetworkActor</span>( Actor );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Actor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从核心代码中可以看出， <code>SpawnActor</code> 的步骤大致如下：</p><ol><li>首先确定一些生成此 Actor 所需的一些参数，如：在哪个 World 中生成，Actor 的模板对象 (没有则使用 CDO) 和名称，Actor 生成的 Transform 和碰撞处理方法 (CollisionHandlingMethod)，Actor 的对象标记以及外部包</li><li>用上一步中处理好的参数，调用 <code>NewObject</code> 方法生成对象。 <code>NewObject</code> 方法在上文中我们已经解析过了，不再赘述。(主要是为新对象分配内存和调用构造函数)</li><li>将 Actor 添加到对应关卡的 Actors 和 ActorsForGC 数组里，广播 Actor 的预生成初始化代理，调用 Actor 的后处理生成初始化函数 ( <code>PostSpawnInitialize</code> )，再检查默认子对象后，广播 Actor 生成结束代理，将 Actor 添加到网络对象中，返回 Actor 即可。</li></ol><p><code>PostSpawnInitialize</code> 函数主要是丰富之前构造好的 Actor 的属性，组件的创建注册后处理，以及执行本地和蓝图构造脚本等，其中：</p><ul><li>设置基本属性包括：NetRoles, Owner, Instigator, RootComponent.Transform 等，</li><li>组件的创建注册后处理包括： <code>DispatchOnComponentsCreated</code> 的函数调用 (调用所有默认本地组件的 <code>OnComponentCreated</code> )， <code>RegisterAllComponents</code> 的函数调用 (调用 <code>PostRegisterAllComponents</code> ，如果是蓝图等脚本实例，则需要延迟本地注册直至 SCS 执行后建立场景根)</li><li>执行本地和蓝图构造脚本包括： <code>ExecuteConstruction</code> 的函数调用 (设置根组件的变换，为蓝图 Actor 创建并注册组件，调用蓝图脚本的 <code>OnConstruction</code> 函数) 和 <code>PostActorConstruction</code> 的函数调用 (初始化上一步中创建出来的组件)。</li></ul><h2 id="createdefaultsubobjectclassname"><a class="anchor" href="#createdefaultsubobjectclassname">#</a> CreateDefaultSubobject&lt;ClassName&gt;(...)</h2><p><code>CreateDefaultSubobject</code> 此函数的调用大致可分为两种情况，在类的构造函数内调用和运行时调用。在类的构造函数内调用时，我们可以在蓝图编辑器中看到此组件 / 子对象，称之为<strong>静态创建子对象</strong>。运行时调用时功能相同，但无法在蓝图编辑器中看到或使用，因为该对象在编辑器中编辑时，其子对象仍未被创建，此行为我们称之为<strong>动态创建子对象</strong>。</p><p>我们平时调用的 <code>CreateDefaultSubobject</code> 函数是定义在 <code>UObject</code> 中的泛型函数。代码如图：</p><p><img data-src="CreateDefaultSubobject_1.png" alt="CreateDefaultSubobject_1"></p><p>![CreateDefaultSubobject_2](D:\blog\source_posts\UE4\UE4CPP\Unreal 常用接口源码分析 之一 \CreateDefaultSubobject_2.png)</p><p></p><figure class="highlight c++"><figcaption><span>CreateDefaultSubobject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectGlobals.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">FObjectInitializer::CreateDefaultSubobject</span><span class="params">(UObject* Outer, FName SubobjectFName, UClass* ReturnType, UClass* ClassToCreateByDefault, <span class="keyword">bool</span> bIsRequired, <span class="keyword">bool</span> bIsTransient)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UObject* Result = <span class="literal">NULL</span>;</span><br><span class="line">	UClass* OverrideClass = ComponentOverrides.<span class="built_in">Get</span>(SubobjectFName, ReturnType, ClassToCreateByDefault, *<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (!OverrideClass &amp;&amp; bIsRequired)</span><br><span class="line">	&#123;</span><br><span class="line">		OverrideClass = ClassToCreateByDefault;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (OverrideClass)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">check</span>(OverrideClass-&gt;<span class="built_in">IsChildOf</span>(ReturnType));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (OverrideClass-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_Abstract))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 尝试创建抽象类将返回空。如果这不是可选的且所属的类不是抽象的则报告警告。</span></span><br><span class="line">			<span class="keyword">if</span> (!bIsRequired &amp;&amp; !Outer-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_Abstract))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">UE_LOG</span>(LogClass, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Required default subobject %s not created as requested class %s is abstract. Returning null.&quot;</span>), *SubobjectFName.<span class="built_in">ToString</span>(), *OverrideClass-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			UObject* Template = OverrideClass-&gt;<span class="built_in">GetDefaultObject</span>(); <span class="comment">// 强制创建 CDO (如果还没有创建好)</span></span><br><span class="line">			EObjectFlags SubobjectFlags = Outer-&gt;<span class="built_in">GetMaskedFlags</span>(RF_PropagateToSubObjects) | RF_DefaultSubObject;</span><br><span class="line">			<span class="keyword">bool</span> bOwnerArchetypeIsNotNative;</span><br><span class="line">			UClass* OuterArchetypeClass;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将该组件标记为暂时性是不安全的，可能导致其结果错误地变为空</span></span><br><span class="line"></span><br><span class="line">			OuterArchetypeClass = Outer-&gt;<span class="built_in">GetArchetype</span>()-&gt;<span class="built_in">GetClass</span>();</span><br><span class="line">			bOwnerArchetypeIsNotNative = !OuterArchetypeClass-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_Native | CLASS_Intrinsic);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bOwnerTemplateIsNotCDO = ObjectArchetype != <span class="literal">nullptr</span> &amp;&amp; ObjectArchetype != Outer-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">GetDefaultObject</span>(<span class="literal">false</span>) &amp;&amp; !Outer-&gt;<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject);</span><br><span class="line"></span><br><span class="line">            <span class="function">FStaticConstructObjectParameters <span class="title">Params</span><span class="params">(OverrideClass)</span></span>;</span><br><span class="line">			Params.Outer = Outer;</span><br><span class="line">			Params.Name = SubobjectFName;</span><br><span class="line">			Params.SetFlags = SubobjectFlags;</span><br><span class="line"></span><br><span class="line">			Result = <span class="built_in">StaticConstructObject_Internal</span>(Params);</span><br><span class="line">			<span class="keyword">if</span> (!bIsTransient &amp;&amp; (bOwnerArchetypeIsNotNative || bOwnerTemplateIsNotCDO))</span><br><span class="line">			&#123;</span><br><span class="line">				UObject* MaybeTemplate = <span class="literal">nullptr</span>;</span><br><span class="line">				<span class="keyword">if</span> (bOwnerTemplateIsNotCDO)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 尝试从特定的对象模板中获取子对象模板</span></span><br><span class="line">					MaybeTemplate = ObjectArchetype-&gt;<span class="built_in">GetDefaultSubobjectByName</span>(SubobjectFName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!MaybeTemplate)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 外部对象的原型非本地，所以我们需要在外部对象链的C++构造函数调用后，拷贝属性到子对象中(因为这是在子对象中设置属性)</span></span><br><span class="line">					MaybeTemplate = OuterArchetypeClass-&gt;<span class="built_in">GetDefaultSubobjectByName</span>(SubobjectFName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (MaybeTemplate &amp;&amp; MaybeTemplate-&gt;<span class="built_in">IsA</span>(ReturnType) &amp;&amp; Template != MaybeTemplate)</span><br><span class="line">				&#123;</span><br><span class="line">                    <span class="comment">// 添加到此数组中的组件将在C++构造函数调用后被初始化</span></span><br><span class="line">					ComponentInits.<span class="built_in">Add</span>(Result, MaybeTemplate);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (Outer-&gt;<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject) &amp;&amp; Outer-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">GetSuperClass</span>())</span><br><span class="line">			&#123;</span><br><span class="line">                Outer-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">AddDefaultSubobject</span>(Result, ReturnType);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 清除 PendingKill 标记，以免我们回收死亡对象的子对象</span></span><br><span class="line">			<span class="comment">// @todo: 我们不应该回收子对象，除非我们当前正在读取包</span></span><br><span class="line">			Result-&gt;<span class="built_in">ClearInternalFlags</span>(EInternalObjectFlags::PendingKill);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>CreateDefaultSubobject</code> 函数处理步骤：</p><ol><li>首先如果要创建的子对象是抽象类对象，则报告警告后，返回空的 UObject 指针，结束。</li><li>如果不是抽象类，则调用 <code>StaticConstructObject_Internal</code> 函数 (前面分析过了) 为子对象分配内存空间，并调用其构造函数 (回收子对象的构造函数将延迟调用)</li><li>如果该子对象的原型，与其外部对象的类对象中存的该子对象的原型不同，则将该子对象添加到组件初始化数组中，等待构造函数调用后进行初始化 (在 <code>FObjectInitializer</code> 析构时或之后进行)。</li></ol><p>以上步骤中，理解第三步可能需要读者对 UObject 构造过程有所了解。提问：</p><blockquote><ul><li>为什么 <code>NewObject</code> 中，构造函数的调用不使用 cpp 原生的 new 运算符，而是选择实现 FObjectInitializer (对象构造器) 来构造 UObject ？</li></ul><p>这个问题需要读者对虚幻的反射机制有一定的了解。我们都知道，cpp 中函数指针是不能指向构造函数的，但因为我们的 UClass 对象 (由反射系统生成的描述类的类对象) 需要存有对应类的构造函数 (以便可以使用同样的函数来构造不同的 UObject 并完成一些构造函数中的其他操作)，所以引擎采用了封装构造函数的方法，在 . <code>generated.h</code> 文件中使用宏生成调用此类默认构造函数的函数，并在 UClass 构造时将此函数存在其 <code>ClassConstructor</code> 指针中。UClass 生成的详细过程请参考博主的另一篇博客。</p></blockquote><p>第三步中，构造器中的 <code>ComponentOverrides</code> 是指蓝图重写的父类中的组件，在 <code>FObjectInitializer</code> 的构造函数中通过类对象的 <code>ComponentClassOverrides</code> 初始化。如果咱生成的子对象的原型与类对象中的原型不一样，证明是咱构造子对象时 (第二步) 用的原型就不是 CDO，所以该子对象仍需要在 <code>PostConstructInit</code> 中被初始化 ()。</p><hr><p>以上便是笔者本篇想总结的关于虚幻中构造对象的常用接口，如果后面还想到什么关于构造对象的函数，笔者也将在后文补充。最后，总结一下上面三个接口之间的关系。</p><p><img data-src="%E5%85%B3%E7%B3%BB.png" alt="关系"></p><p>另外 再提一下 <code>Archetype</code> (原型对象) ， <code>NewObject</code> 和 <code>CreateDefaultSubobject</code> 中对 <code>Archetype</code> 的使用是比较多的，主要用来初始化我们创建出来的 <code>UObject</code> 的属性。原型对象可以通过 <code>NewObject</code> 的参数传入，如果未传入，则默认使用 CDO 作为对象原型。</p><p>还有什么不明白的地方，欢迎留言 😃</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-19 11:58:39" itemprop="dateModified" datetime="2022-03-19T11:58:39+08:00">2022-03-19</time> </span><span id="2022/03/15/UE4/UE4CPP/Unreal 常用接口源码分析 之一/" class="item leancloud_visitors" data-flag-title="Unreal 常用接口源码分析 之一" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2022/03/15/UE4/UE4CPP/Unreal%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E4%B9%8B%E4%B8%80/" title="Unreal 常用接口源码分析 之一">https://kotori_suki.github.io/2022/03/15/UE4/UE4CPP/Unreal 常用接口源码分析 之一/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/02/12/UE4/UE4CPP/Unreal%20%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicmnywqgpj20zk0m8dwx.jpg" title="Unreal MotionMatching"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal MotionMatching</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unreal-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B9%8B%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">Unreal 常用接口源码分析 之一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#newobjectclassname"><span class="toc-number">1.1.</span> <span class="toc-text">NewObject&lt;ClassName&gt;(...)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#staticconstructobject_internal"><span class="toc-number">1.1.1.</span> <span class="toc-text">StaticConstructObject_Internal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#staticallocateobject"><span class="toc-number">1.1.2.</span> <span class="toc-text">StaticAllocateObject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spawnactor"><span class="toc-number">1.2.</span> <span class="toc-text">SpawnActor(...)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createdefaultsubobjectclassname"><span class="toc-number">1.3.</span> <span class="toc-text">CreateDefaultSubobject&lt;ClassName&gt;(...)</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li><li><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" rel="bookmark" title="Unreal Slate">Unreal Slate</a></li><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li><li><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></li><li><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="bookmark" title="Custom Item Module">Custom Item Module</a></li><li><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></li><li><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></li><li><a href="/2022/01/08/UE4/UE4CPP/Unreal%20%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" rel="bookmark" title="Unreal 蓝图底层实现机制">Unreal 蓝图底层实现机制</a></li><li><a href="/2022/02/12/UE4/UE4CPP/Unreal%20%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/" rel="bookmark" title="Unreal MotionMatching">Unreal MotionMatching</a></li><li class="active"><a href="/2022/03/15/UE4/UE4CPP/Unreal%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E4%B9%8B%E4%B8%80/" rel="bookmark" title="Unreal 常用接口源码分析 之一">Unreal 常用接口源码分析 之一</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">57</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/23/CPPBase/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/" title="迭代器失效问题">迭代器失效问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/" title="分类于 插件制作">插件制作</a></div><span><a href="/2021/08/05/UE4/UE4Plugin/UE4_Plugin/" title="UE4 Plugin">UE4 Plugin</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/Observe/" title="观察者模式">观察者模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/16/CPPBase/map%E4%B8%8Eunordered_map%E7%9A%84%E5%8C%BA%E5%88%AB/" title="map与unordered_map">map与unordered_map</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 结构型模式">结构型模式</a></div><span><a href="/2021/08/18/CPPBase/DesignPattern/Proxy/" title="代理模式">代理模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/17/CPPBase/DesignPattern/AbstractFactory/" title="抽象工厂模式">抽象工厂模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A6%82%E8%BF%B0/" title="分类于 概述">概述</a></div><span><a href="/2021/08/16/CPPBase/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%20&%20%E6%A6%82%E8%BF%B0/" title="设计模式六大原则 &amp; 概述">设计模式六大原则 & 概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/17/CPPBase/DesignPattern/SimpleFactory/" title="简单工厂模式">简单工厂模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" title="Session的使用 C++篇">Session的使用 C++篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/ModuleDesign/" title="分类于 ModuleDesign">ModuleDesign</a></div><span><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" title="Custom Item Module">Custom Item Module</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/03/15/UE4/UE4CPP/Unreal 常用接口源码分析 之一/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>