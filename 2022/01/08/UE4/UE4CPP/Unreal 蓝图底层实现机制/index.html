<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2022/01/08/UE4/UE4CPP/Unreal%20%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"><title>Unreal 蓝图底层实现机制 - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unreal 蓝图底层实现机制</h1><div class="meta"><span class="item" title="创建时间：2022-01-08 10:03:48"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-01-08T10:03:48+08:00">2022-01-08</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclj61ylzj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph47e9vtj20zk0m8x6l.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2022/01/08/UE4/UE4CPP/Unreal%20%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="unreal-蓝图底层实现机制"><a class="anchor" href="#unreal-蓝图底层实现机制">#</a> Unreal 蓝图底层实现机制</h1><p>简介：本篇主要解析蓝图的底层实现机制，从蓝图的创建编译到蓝图编辑器的工作机制的介绍。本篇将带你进入蓝图可视化编程的底层，分析其蓝图运行背后的秘密。另外不知道读者是否遇到过 &quot;SpawnActorFromClass&quot; 等蓝图节点无法在函数列表中找到的情况。<a href="#SpawnActor">原因</a>嘛，咱后面分析，正好可以让我卖个关子哈哈。</p><h2 id="蓝图底层实现机制概要"><a class="anchor" href="#蓝图底层实现机制概要">#</a> 蓝图底层实现机制概要</h2><p>首先，蓝图类只不过是 <code>UObject</code> 的一个子类，其名为 <code>UBlueprint</code> 。跟 <code>UObject</code> 一样， <code>UBlueprint</code> 有着属于自己的 <code>UClass</code> ，名为 <code>UBlueprintGeneratedClass</code> 。</p><p>蓝图实际上是 ue 为了方便开发者可视化编程而推出的脚本语言，引擎会根据我们在编辑器中的操作自动地转换成了相应的 CPP 代码，如：创建蓝图，添加蓝图节点，编译蓝图等。</p><p>那么，要理解蓝图实现机制，我们只需要搞清楚：</p><ol><li>引擎是怎么把编辑器中的蓝图转换为引擎可识别的代码，并运行起来的？</li><li>我们在编辑器中 创建蓝图，添加蓝图节点，编译蓝图时，引擎都做了什么？</li><li>如果要自定义蓝图节点，我需要做些什么？</li></ol><p>在开始分析之前，让我们先看看这张有趣的类图：</p><p><img data-src="%E8%93%9D%E5%9B%BE%E7%B1%BB%E5%9B%BE.png" alt="蓝图类图"></p><p>看起来似乎有点复杂...</p><p>但没关系，请静下心，与写者一同探究 编辑器中蓝图开发的各个步骤中的奥秘 😃</p><h2 id="创建蓝图"><a class="anchor" href="#创建蓝图">#</a> 创建蓝图</h2><p><img data-src="%E5%88%9B%E5%BB%BA%E8%93%9D%E5%9B%BE.png" alt="创建蓝图"></p><p>如图，如果我们需要创建蓝图资源，只需要右键，选择蓝图类，并挑选父类即可。</p><p>当我们确认创建资产时，实际上引擎的资产工具会调用 <code>CreateAsset</code> ，为我们创建一个包，并用于调用特定工厂的 <code>FactoryCreateNew()</code> ，代码如下：</p><p></p><figure class="highlight c++"><figcaption><span>CreateAsset</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssetTools.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">UAssetToolsImpl::CreateAsset</span><span class="params">(<span class="keyword">const</span> FString&amp; AssetName, <span class="keyword">const</span> FString&amp; PackagePath, UClass* AssetClass, UFactory* Factory, FName CallingContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> FString PackageName = UPackageTools::<span class="built_in">SanitizePackageName</span>(PackagePath + <span class="built_in">TEXT</span>(<span class="string">&quot;/&quot;</span>) + AssetName);</span><br><span class="line">    </span><br><span class="line">    UClass* ClassToUse = AssetClass ? AssetClass : (Factory ? Factory-&gt;<span class="built_in">GetSupportedClass</span>() : <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	UPackage* Pkg = <span class="built_in">CreatePackage</span>(*PackageName);</span><br><span class="line">	UObject* NewObj = <span class="literal">nullptr</span>;</span><br><span class="line">	EObjectFlags Flags = RF_Public|RF_Standalone|RF_Transactional;</span><br><span class="line">	<span class="keyword">if</span> ( Factory )</span><br><span class="line">	&#123;</span><br><span class="line">		NewObj = Factory-&gt;<span class="built_in">FactoryCreateNew</span>(ClassToUse, Pkg, <span class="built_in">FName</span>( *AssetName ), Flags, <span class="literal">nullptr</span>, GWarn, CallingContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( AssetClass )</span><br><span class="line">	&#123;</span><br><span class="line">		NewObj = NewObject&lt;UObject&gt;(Pkg, ClassToUse, <span class="built_in">FName</span>(*AssetName), Flags);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NewObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>蓝图资产也不例外，蓝图工厂创建新蓝图的代码如下：</p><p></p><figure class="highlight c++"><figcaption><span>UBlueprintFactory::FactoryCreateNew</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EditorFactories.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">UBlueprintFactory::FactoryCreateNew</span><span class="params">(UClass* Class, UObject* InParent, FName Name, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn, FName CallingContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    UClass* BlueprintClass = <span class="literal">nullptr</span>;</span><br><span class="line">	UClass* BlueprintGeneratedClass = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    IKismetCompilerInterface&amp; KismetCompilerModule = FModuleManager::LoadModuleChecked&lt;IKismetCompilerInterface&gt;(<span class="string">&quot;KismetCompiler&quot;</span>);</span><br><span class="line">	KismetCompilerModule.<span class="built_in">GetBlueprintTypesForClass</span>(ParentClass, BlueprintClass, BlueprintGeneratedClass);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> FKismetEditorUtilities::<span class="built_in">CreateBlueprint</span>(ParentClass, InParent, Name, BPTYPE_Normal, BlueprintClass, BlueprintGeneratedClass, CallingContext);</span><br><span class="line">	</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">UBlueprint* <span class="title">FKismetEditorUtilities::CreateBlueprint</span><span class="params">(UClass* ParentClass, UObject* Outer, <span class="keyword">const</span> FName NewBPName, EBlueprintType BlueprintType, TSubclassOf&lt;UBlueprint&gt; BlueprintClassType, TSubclassOf&lt;UBlueprintGeneratedClass&gt; BlueprintGeneratedClassType, FName CallingContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// debug代码</span></span><br><span class="line">    	</span><br><span class="line">    <span class="comment">// 创建新蓝图对象</span></span><br><span class="line">	UBlueprint* NewBP = NewObject&lt;UBlueprint&gt;(Outer, *BlueprintClassType, NewBPName, RF_Public | RF_Standalone | RF_Transactional | RF_LoadCompleted);</span><br><span class="line">	NewBP-&gt;Status = BS_BeingCreated;</span><br><span class="line">	NewBP-&gt;BlueprintType = BlueprintType;</span><br><span class="line">	NewBP-&gt;ParentClass = ParentClass;</span><br><span class="line">	NewBP-&gt;BlueprintSystemVersion = UBlueprint::<span class="built_in">GetCurrentBlueprintSystemVersion</span>();</span><br><span class="line">	NewBP-&gt;bIsNewlyCreated = <span class="literal">true</span>;</span><br><span class="line">	NewBP-&gt;bLegacyNeedToPurgeSkelRefs = <span class="literal">false</span>;</span><br><span class="line">	NewBP-&gt;<span class="built_in">GenerateNewGuid</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建通常构造脚本</span></span><br><span class="line">    <span class="comment">// 创建默认事件图表</span></span><br><span class="line">    <span class="comment">// 处理动画蓝图</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 创建初始UClass </span></span><br><span class="line"><span class="comment">     * 跳过CDO验证，因为用户没有机会改变任何默认值，</span></span><br><span class="line"><span class="comment">     * 且某些情况下，新蓝图CDO的默认值的设置可能被延迟到编译完成后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    	<span class="keyword">const</span> EBlueprintCompileOptions CompileOptions =</span><br><span class="line">		EBlueprintCompileOptions::SkipGarbageCollection |</span><br><span class="line">		EBlueprintCompileOptions::SkipDefaultObjectValidation |</span><br><span class="line">		EBlueprintCompileOptions::SkipFiBSearchMetaUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译UClass</span></span><br><span class="line">	FBlueprintCompilationManager::<span class="built_in">CompileSynchronously</span>(</span><br><span class="line">		<span class="built_in">FBPCompileRequest</span>(NewBP, CompileOptions, <span class="literal">nullptr</span>)</span><br><span class="line">	);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将蓝图标记为已被重新生成</span></span><br><span class="line">    NewBP-&gt;bHasBeenRegenerated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	UBlueprintEditorSettings* Settings = GetMutableDefault&lt;UBlueprintEditorSettings&gt;();</span><br><span class="line">	<span class="keyword">if</span>(Settings &amp;&amp; Settings-&gt;bSpawnDefaultBlueprintNodes)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// ..... 生成默认蓝图节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建稀疏类数据并设置flag</span></span><br><span class="line">    <span class="comment">// 向分析器报告蓝图创建成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以上代码，核心在于初始化新蓝图类 <code>UBlueprint</code> 的基本属性，编译新蓝图类的 <code>UBlueprintGeneratedClass</code> 对象</p><h2 id="编译蓝图"><a class="anchor" href="#编译蓝图">#</a> 编译蓝图</h2><p>编译蓝图在 <code>FBlueprintCompilationManagerImpl::CompileSynchronouslyImpl</code> 中进行，其主要完成以下任务：</p><ol><li>将需要编译的蓝图添加到 <code>QueuedRequests</code> 数组中</li><li><strong>调用 <code>FlushCompilationQueueImpl()</code> 编译 <code>QueuedRequests</code> 数组中的蓝图及其依赖蓝图</strong> (下文展开)</li><li>调用 <code>FlushReinstancingQueueImpl()</code> 重新实例化所有编译的蓝图 (只是替换已更改的实例)</li><li>根据编译的蓝图类型，决定是否更新关卡脚本蓝图，是否进行 GC，是否更新框架类等</li><li>最后调用 <code>FEditorFileUtils::PromptForCheckoutAndSave()</code> 将编译过且需要保存的蓝图保存起来</li></ol><p>以下是 <code>CompileSynchronouslyImpl()</code> 函数的核心代码：</p><p></p><figure class="highlight c++"><figcaption><span>FBlueprintCompilationManager::CompileSynchronously</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlueprintCompilationManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FBlueprintCompilationManagerImpl::CompileSynchronouslyImpl</span><span class="params">(<span class="keyword">const</span> FBPCompileRequestInternal&amp; Request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    QueuedRequests.<span class="built_in">Add</span>(Request);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> bSuppressBroadcastCompiled = <span class="literal">true</span>;</span><br><span class="line">	TArray&lt;UBlueprint*&gt; CompiledBlueprints;</span><br><span class="line">	TArray&lt;UBlueprint*&gt; SkeletonCompiledBlueprints;</span><br><span class="line">	<span class="built_in">FlushCompilationQueueImpl</span>(bSuppressBroadcastCompiled, &amp;CompiledBlueprints, &amp;SkeletonCompiledBlueprints, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">FlushReinstancingQueueImpl</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (CompiledBlueprintsToSave.<span class="built_in">Num</span>() &gt; <span class="number">0</span> &amp;&amp; !bRegenerateSkeletonOnly)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!bSkipSaving)</span><br><span class="line">		&#123;</span><br><span class="line">			TArray&lt;UPackage*&gt; PackagesToSave;</span><br><span class="line">			<span class="keyword">for</span> (UBlueprint* BP : CompiledBlueprintsToSave)</span><br><span class="line">			&#123;</span><br><span class="line">				PackagesToSave.<span class="built_in">Add</span>(BP-&gt;<span class="built_in">GetOutermost</span>());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			FEditorFileUtils::<span class="built_in">PromptForCheckoutAndSave</span>(PackagesToSave, <span class="comment">/*bCheckDirty =*/</span><span class="literal">true</span>, <span class="comment">/*bPromptToSave =*/</span><span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		CompiledBlueprintsToSave.<span class="built_in">Empty</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已经手动GC，释放对旧CDO的引用</span></span><br><span class="line">	OldCDOs.<span class="built_in">Empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在深入讲解蓝图的编译之前，让我们先思考一个简单的问题：<strong>为什么要编译蓝图？编译蓝图的目的是什么？</strong></p><p>相信聪明的你一下就能回答上来：<strong>因为蓝图只是脚本，我们要将其编译为 CPP 代码才能被引擎使用。</strong></p><p>上文可知，<strong>编译蓝图的重任其实是在 <code>FlushCompilationQueueImpl()</code> 中完成的</strong>，其代码较长，总结步骤大致如下：</p><ol><li>添加相关且未编译的蓝图到 <code>CurrentlyCompilingBPs</code> 和 <code>BlueprintsToRecompile</code> 数组中，并添加所有子蓝图以便可以重新链接。</li><li>过滤不包含任何需要重编译的逻辑或变量或元素的蓝图，如果需要重编译则将其添加到 <code>BlueprintsToRecompile</code> 数组中。</li><li>将 <code>BlueprintsToRecompile</code> 数组中的所有蓝图和及其所有需要重编译的子类蓝图添加到 <code>CurrentlyCompilingBPs</code> 数组中。</li><li>将 <code>CurrentlyCompilingBPs</code> 数组排序为正确的编译顺序，基类需要在子类之前编译。</li><li>设置 <code>CurrentlyCompilingBPs</code> 数组中蓝图的标记 (bBeingCompiled, bIsRegeneratingOnLoad)。</li><li>验证 <code>CurrentlyCompilingBPs</code> 数组中编译数据的正确性，并给予蓝图编辑的可能。</li><li>清除空图，修复数据。</li><li>安全移除旧框架蓝图 CDOs</li><li>重编译框架蓝图类，修复代理参数，如果函数签名被更改，则需要重现编译所有依赖。</li><li>重构造节点并替换不推荐使用的节点，广播 &quot;蓝图预编译&quot; 代理。</li><li>重新实例化队列中的每个蓝图。注意：这意味着继承关系中未被编译的类将成为重新实例化版本类的父类，因此涉及这些类型的类型检查 (如：IsA 等) 将不一致</li><li>重新实例化完成，修复子类的父类指针。</li><li>** 重编译蓝图。将蓝图编译到 BPGC 中。** 关键步骤，下文展开</li><li>** 编译函数。根据各种图生成字节码。** 关键步骤，下文展开</li><li>结束重新实例化操作的第一步，将旧类移动到新类中</li><li>后处理 CDO 编译</li><li>清除临时标记</li></ol><p>参考代码：UE_4.27\Engine\Source\Editor\Kismet\PrivateBlueprintCompilationManager.cpp</p><h3 id="重编译蓝图"><a class="anchor" href="#重编译蓝图">#</a> 重编译蓝图</h3><p>重编译蓝图主要进行以下操作：</p><ol><li>更新了 BPGC 中的属性函数元信息</li><li>修复 BPGC 中重写的函数事件接口</li><li><strong>创建 <code>FunctionList</code> 并将蓝图中的函数预编译到其中</strong>（编译函数的必要前置步骤）</li><li>重新链接此 <code>BPGC</code> 和子类蓝图 <code>BPGC</code> 的属性与结构</li><li>最后处理额外的编译任务 (如果有)。</li></ol><p>核心代码如下 (重要步骤标记注释)：</p><p></p><figure class="highlight c++"><figcaption><span>FlushCompilationQueueImpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlueprintCompilationManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FBlueprintCompilationManagerImpl::FlushCompilationQueueImpl</span><span class="params">(<span class="keyword">bool</span> bSuppressBroadcastCompiled, TArray&lt;UBlueprint*&gt;* BlueprintsCompiled, TArray&lt;UBlueprint*&gt;* BlueprintsCompiledOrSkeletonCompiled, FUObjectSerializeContext* InLoadContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (FCompilerData&amp; CompilerData : CurrentlyCompilingBPs)</span><br><span class="line">	&#123;</span><br><span class="line">        UBlueprint* BP = CompilerData.BP;</span><br><span class="line">        <span class="keyword">if</span>(CompilerData.<span class="built_in">ShouldCompileClassLayout</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(BP-&gt;ParentClass)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(BP-&gt;GeneratedClass &amp;&amp; !CompilerData.<span class="built_in">IsCppCompileType</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    BP-&gt;GeneratedClass-&gt;ClassDefaultObject = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置标记，以便蓝图未编译时在PIE中使用时发出警告</span></span><br><span class="line">                BP-&gt;bDisplayCompilePIEWarning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 编译 BPGC 的核心函数</span></span><br><span class="line">                FKismetCompilerContext&amp; CompilerContext = *(CompilerData.Compiler);</span><br><span class="line">                CompilerContext.<span class="built_in">CompileClassLayout</span>( EInternalCompilerFlags::PostponeLocalsGenerationUntilPhaseTwo );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新链接子蓝图类</span></span><br><span class="line">                TArray&lt;UClass*&gt; ClassesToRelink;</span><br><span class="line">                <span class="built_in">GetDerivedClasses</span>(BP-&gt;GeneratedClass, ClassesToRelink, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">for</span> (UClass* ChildClass : ClassesToRelink)</span><br><span class="line">                &#123;</span><br><span class="line">                    ChildClass-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">                    ChildClass-&gt;<span class="built_in">StaticLink</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行额外的编译处理</span></span><br><span class="line">    <span class="built_in">ProcessExtensions</span>(CurrentlyCompilingBPs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetCompilerContext::CompileClassLayout</span><span class="params">(EInternalCompilerFlags InternalFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PreCompile</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除旧类对象中的属性以便在原来的位置添加新的值</span></span><br><span class="line">    <span class="built_in">CleanAndSanitizeClass</span>(TargetClass, OldCDO);</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="function">TGuardValue&lt;<span class="keyword">bool</span>&gt; <span class="title">LockDependenciesUpToDate</span><span class="params">(Blueprint-&gt;bCachedDependenciesUpToDate, Blueprint-&gt;bCachedDependenciesUpToDate)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 确保此蓝图更新后父类函数调用仍有效，无效则清除调用节点</span></span><br><span class="line">		FBlueprintEditorUtils::<span class="built_in">ConformCallsToParentFunctions</span>(Blueprint);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 确保处理的事件全部存在，如果不存在则更换为自定义事件</span></span><br><span class="line">		FBlueprintEditorUtils::<span class="built_in">ConformImplementedEvents</span>(Blueprint);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 确保继承的所有接口的所有图存在，不存在则添加</span></span><br><span class="line">		FBlueprintEditorUtils::<span class="built_in">ConformImplementedInterfaces</span>(Blueprint);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用 BP 创建变量，并注册到 BPGC 中</span></span><br><span class="line">	<span class="built_in">CreateClassVariablesFromBlueprint</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 BPGC 的 Interfaces 数组中添加接口</span></span><br><span class="line">	<span class="built_in">AddInterfacesFromBlueprint</span>(NewClass);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 合并事件图为 UberGraph(以下简称主图)，根据主图函数入口对应创建存根函数</span></span><br><span class="line">    <span class="comment">// 为函数代理接口图中的函数构造上下文，并添加到 FunctionList 中</span></span><br><span class="line">	<span class="built_in">CreateFunctionList</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预编译函数，首先处理代理签名，因为代理签名可能被其他函数所需要</span></span><br><span class="line">    <span class="comment">/* 预编译函数，过程如下:</span></span><br><span class="line"><span class="comment">     * 清除不需要的节点，翻译节点，创建存根函数并存到 FunctionContext 的 Function 中，</span></span><br><span class="line"><span class="comment">     * 初始化 Function 中的各项属性元数据等，将 Function 链接到 BPGC 的属性链和 FunctionMap 中</span></span><br><span class="line"><span class="comment">     * 为函数内的每个节点注册 Nets，Net可以理解为引脚与值的对应关系，注册Net即是把这种对应关系添加到函数上下文的 NetMap 中</span></span><br><span class="line"><span class="comment">     * 为函数创建参数，创建函数本地变量，创建执行模式(为函数上下文的LinearExecutionList的节点排序)，链接 Function 中的参数列表，验证函数签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; FunctionList.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(FunctionList[i].<span class="built_in">IsDelegateSignature</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">PrecompileFunction</span>(FunctionList[i], InternalFlags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; FunctionList.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!FunctionList[i].<span class="built_in">IsDelegateSignature</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">PrecompileFunction</span>(FunctionList[i], InternalFlags);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    &#123; </span><br><span class="line">		<span class="comment">// 重现链接此蓝图类的属性和结构</span></span><br><span class="line">		NewClass-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">		NewClass-&gt;<span class="built_in">StaticLink</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="编译函数"><a class="anchor" href="#编译函数">#</a> 编译函数</h3><p>编译函数要进行以下操作：</p><ol><li>编译 <code>FunctionList</code> 中的所有函数<ol><li><strong>为每个函数生成代码 (不是真正的代码，而是蓝图编译语句，也就是 FBlueprintCompiledStatement)</strong></li><li><strong>后处理所有函数编译 (进行线性执行列表的最终排序，处理所有挂起的跳转修复，优化无用跳转)</strong></li><li>广播 <code>FunctionListCompiledEvent</code> 事件 (函数列表编译完成)</li><li>设置 BPGC 的结束标记，构建 CDO，构建代理绑定映射，拷贝默认值到 CDO 中，执行 CDO 编译后处理 (修复和缓存新 CDO 的数据)</li><li><strong>填充函数体和框架蓝图类的根存函数体 (生成字节码和 cpp 代码，下文展开)</strong></li><li>将需要依赖该蓝图的蓝图标记为脏</li><li>序列化 CDO 和 BPGC</li><li>编译后处理</li></ol></li><li>保存需要在编译后保存的蓝图</li><li>设置 BPGC 运行时复制所需的数据</li><li>更新依赖此蓝图的所有蓝图</li></ol><p>核心代码如下 (重要步骤标记注释)：</p><p></p><figure class="highlight c++"><figcaption><span>FlushCompilationQueueImpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlueprintCompilationManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FBlueprintCompilationManagerImpl::FlushCompilationQueueImpl</span><span class="params">(<span class="keyword">bool</span> bSuppressBroadcastCompiled, TArray&lt;UBlueprint*&gt;* BlueprintsCompiled, TArray&lt;UBlueprint*&gt;* BlueprintsCompiledOrSkeletonCompiled, FUObjectSerializeContext* InLoadContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">FKismetCompilerVMBackend <span class="title">Backend_VM</span><span class="params">(Blueprint, Schema, *<span class="keyword">this</span>)</span></span>;	<span class="comment">// VM后端，用于生成字节码</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (FCompilerData&amp; CompilerData : CurrentlyCompilingBPs)</span><br><span class="line">    &#123;</span><br><span class="line">        UBlueprint* BP = CompilerData.BP;</span><br><span class="line">        UClass* BPGC = BP-&gt;GeneratedClass;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(BPGC)</span><br><span class="line">        &#123;</span><br><span class="line">            BPGC-&gt;ClassDefaultObject = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 类布局已就绪，我们可以清除 CLASS_LayoutChanging 标记，CompileFunctions 将创建 CDO </span></span><br><span class="line">            BPGC-&gt;ClassFlags &amp;= ~CLASS_LayoutChanging;</span><br><span class="line"></span><br><span class="line">            FKismetCompilerContext&amp; CompilerContext = *(CompilerData.Compiler);</span><br><span class="line">            CompilerContext.<span class="built_in">CompileFunctions</span>(</span><br><span class="line">                EInternalCompilerFlags::PostponeLocalsGenerationUntilPhaseTwo</span><br><span class="line">                |EInternalCompilerFlags::PostponeDefaultObjectAssignmentUntilReinstancing</span><br><span class="line">                |EInternalCompilerFlags::SkipRefreshExternalBlueprintDependencyNodes</span><br><span class="line">            ); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存需要在编译后保存的蓝图</span></span><br><span class="line">        <span class="keyword">if</span>(!BP-&gt;bIsRegeneratingOnLoad)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bSaveBlueprintsAfterCompile || (bSaveBlueprintAfterCompileSucceeded &amp;&amp; BP-&gt;Status == BS_UpToDate))</span><br><span class="line">            &#123;</span><br><span class="line">                CompiledBlueprintsToSave.<span class="built_in">Add</span>(BP);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 BPGC 运行时复制所需的数据</span></span><br><span class="line">        <span class="keyword">if</span>(BPGC)</span><br><span class="line">        &#123;</span><br><span class="line">            BPGC-&gt;ClassFlags &amp;= ~CLASS_ReplicationDataIsSetUp;</span><br><span class="line">            BPGC-&gt;<span class="built_in">SetUpRuntimeReplicationData</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新依赖该蓝图的所有蓝图</span></span><br><span class="line">        FKismetCompilerUtilities::<span class="built_in">UpdateDependentBlueprints</span>(BP);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetCompilerContext::CompileFunctions</span><span class="params">(EInternalCompilerFlags InternalFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bIsFullCompile &amp;&amp; !MessageLog.NumErrors)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 为每个函数生成代码，下文展开</span></span><br><span class="line">        <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; FunctionList.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FunctionList[i].<span class="built_in">IsValid</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CompileFunction</span>(FunctionList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后处理所有函数，下文展开</span></span><br><span class="line">        <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; FunctionList.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FunctionList[i].<span class="built_in">IsValid</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">PostcompileFunction</span>(FunctionList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对于框架类仍需设置函数的标记</span></span><br><span class="line">		<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; FunctionList.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			FKismetFunctionContext&amp; Function = FunctionList[i];</span><br><span class="line">			<span class="keyword">if</span> (Function.<span class="built_in">IsValid</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">FinishCompilingFunction</span>(Function);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 广播 &quot;函数列表编译完成事件&quot; 代理</span></span><br><span class="line">    FunctionListCompiledEvent.<span class="built_in">Broadcast</span>(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置所有结束标记，关闭对类的修改，构建CDO等</span></span><br><span class="line">        <span class="built_in">FinishCompilingClass</span>(NewClass);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有主图，构建代理绑定映射</span></span><br><span class="line">		<span class="keyword">if</span> (ConsolidatedEventGraph)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 构建该类的所有动态绑定信息</span></span><br><span class="line">			<span class="built_in">BuildDynamicBindingObjects</span>(NewClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		UObject* NewCDO = NewClass-&gt;<span class="built_in">GetDefaultObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝所有在读取时未重新生成的父类蓝图类的属性到此蓝图框架 CDO 中，拷贝的属性将在加载编译结束后被处理</span></span><br><span class="line">		FBlueprintEditorUtils::<span class="built_in">PropagateParentBlueprintDefaults</span>(NewClass);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(bPropagateValuesToCDO)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( !Blueprint-&gt;<span class="built_in">HasAnyFlags</span>(RF_BeingRegenerated) )</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 将旧 CDO 中的值传达新 CDO 中</span></span><br><span class="line">				<span class="keyword">if</span>( OldCDO )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (OldLinker &amp;&amp; OldGenLinkerIdx != INDEX_NONE)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 如果有正在加载的对象列表，则修复导出表。此步骤也将修复加载标记</span></span><br><span class="line">						FBlueprintEditorUtils::<span class="built_in">PatchNewCDOIntoLinker</span>(Blueprint-&gt;GeneratedClass-&gt;<span class="built_in">GetDefaultObject</span>(), OldLinker, OldGenLinkerIdx, <span class="literal">nullptr</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					UEditorEngine::FCopyPropertiesForUnrelatedObjectsParams CopyDetails;</span><br><span class="line">					CopyDetails.bCopyDeprecatedProperties = Blueprint-&gt;bIsRegeneratingOnLoad;</span><br><span class="line">					CopyDetails.bNotifyObjectReplacement = <span class="literal">true</span>; </span><br><span class="line">					UEditorEngine::<span class="built_in">CopyPropertiesForUnrelatedObjects</span>(OldCDO, NewCDO, CopyDetails);</span><br><span class="line">					FBlueprintEditorUtils::<span class="built_in">PatchCDOSubobjectsIntoExport</span>(OldCDO, NewCDO);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 不执行生成类验证，因为我们没有修改任何值</span></span><br><span class="line">					bSkipGeneratedClassValidation = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">PropagateValuesToCDO</span>(NewCDO, OldCDO);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 基于新CDO执行修复和缓存</span></span><br><span class="line">			<span class="built_in">PostCDOCompiled</span>();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新用于构造后处理的自定义属性列表</span></span><br><span class="line">        <span class="comment">// 注意: BPGC重新生成时，旧CDO到新CDO的拷贝时延迟执行的，所以这种情况下，将跳过此步骤</span></span><br><span class="line">		<span class="keyword">if</span> (!Blueprint-&gt;<span class="built_in">HasAnyFlags</span>(RF_BeingRegenerated))</span><br><span class="line">		&#123;</span><br><span class="line">			TargetClass-&gt;<span class="built_in">UpdateCustomPropertyListForPostConstruction</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行VM后端，生成字节码</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bGenerateStubsOnly = !bIsFullCompile || (<span class="number">0</span> != MessageLog.NumErrors);</span><br><span class="line">			Backend_VM.<span class="built_in">GenerateCodeFromClass</span>(NewClass, FunctionList, bGenerateStubsOnly);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充函数的 ScriptAndPropertyObjectReferences 数组</span></span><br><span class="line">		<span class="keyword">if</span> (bIsFullCompile &amp;&amp; (<span class="number">0</span> == MessageLog.NumErrors))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (FKismetFunctionContext&amp; FunctionContext : FunctionList)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (FunctionContext.<span class="built_in">IsValid</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					UFunction* Function = FunctionContext.Function; </span><br><span class="line">					<span class="function">FArchiveScriptReferenceCollector <span class="title">ObjRefCollector</span><span class="params">(Function-&gt;ScriptAndPropertyObjectReferences)</span></span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">for</span> (int32 iCode = <span class="number">0</span>; iCode &lt; Function-&gt;Script.<span class="built_in">Num</span>();)</span><br><span class="line">					&#123;</span><br><span class="line">						Function-&gt;<span class="built_in">SerializeExpr</span>(iCode, ObjRefCollector);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bDisplayBytecode &amp;&amp; bIsFullCompile &amp;&amp; !<span class="built_in">IsRunningCommandlet</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">TGuardValue&lt;ELogTimes::Type&gt; <span class="title">DisableLogTimes</span><span class="params">(GPrintLogTimes, ELogTimes::None)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="function">FKismetBytecodeDisassembler <span class="title">Disasm</span><span class="params">(*GLog)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 反汇编脚本代码，输出函数生成的字节码</span></span><br><span class="line">			<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; FunctionList.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				FKismetFunctionContext&amp; Function = FunctionList[i];</span><br><span class="line">				<span class="keyword">if</span> (Function.<span class="built_in">IsValid</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">UE_LOG</span>(LogK2Compiler, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;\n\n[function %s]:\n&quot;</span>), *(Function.Function-&gt;<span class="built_in">GetName</span>()));</span><br><span class="line">					Disasm.<span class="built_in">DisassembleStructure</span>(Function.Function);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过cpp后端生成cpp代码</span></span><br><span class="line">		<span class="keyword">if</span> ((bDisplayCpp &amp;&amp; bIsFullCompile &amp;&amp; !<span class="built_in">IsRunningCommandlet</span>()) || CompileOptions.<span class="built_in">DoesRequireCppCodeGeneration</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">TUniquePtr&lt;IBlueprintCompilerCppBackend&gt; <span class="title">Backend_CPP</span><span class="params">(IBlueprintCompilerCppBackendModuleInterface::Get().Create())</span></span>;</span><br><span class="line">			HeaderSourceCode = Backend_CPP-&gt;<span class="built_in">GenerateCodeFromClass</span>(NewClass, FunctionList, !bIsFullCompile, CompileOptions.NativizationOptions, CppSourceCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是完全编译，则执行以下代码寻找需要刷新的蓝图，并将其标脏</span></span><br><span class="line">	<span class="keyword">if</span>( bIsFullCompile &amp;&amp; !Blueprint-&gt;bIsRegeneratingOnLoad &amp;&amp; !bSkipRefreshExternalBlueprintDependencyNodes )</span><br><span class="line">	&#123;</span><br><span class="line">		TArray&lt;UBlueprint*&gt; DependentBlueprints;</span><br><span class="line">		FBlueprintEditorUtils::<span class="built_in">GetDependentBlueprints</span>(Blueprint, DependentBlueprints);</span><br><span class="line">		<span class="keyword">for</span> (UBlueprint* CurrentBP : DependentBlueprints)</span><br><span class="line">		&#123;</span><br><span class="line">			FBlueprintEditorUtils::<span class="built_in">RefreshExternalBlueprintDependencyNodes</span>(CurrentBP, NewClass);</span><br><span class="line">			<span class="keyword">if</span>(Package != <span class="literal">nullptr</span> &amp;&amp; Package-&gt;<span class="built_in">IsDirty</span>() &amp;&amp; !bStartedWithUnsavedChanges)</span><br><span class="line">			&#123;</span><br><span class="line">				Package-&gt;<span class="built_in">SetDirtyFlag</span>(<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化新CDO，并刷新蓝图中的 CrcLastCompiledCDO 属性(记录编译是否改变默认值)</span></span><br><span class="line">	<span class="comment">// 序列化新BPGC，并刷新蓝图中的 CrcLastCompiledSignature 属性 </span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 编译后处理，广播 &quot;OnPostCompile&quot; 代理</span></span><br><span class="line">	<span class="built_in">PostCompile</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译完了！哎，先别急着休息，咱先把一些细节搞清楚！</p><h4 id="编译单个函数"><a class="anchor" href="#编译单个函数">#</a> 编译单个函数</h4><p>编译函数的第一步即是调用 <code>CompileFunction</code> 为 <code>FunctionList</code> 中的每个函数生成 <code>Statements</code> ，然后将纯节点 (没有执行引脚的节点) 合并到非纯节点中，最后分离可以独立执行的节点以备... mark (如：事件节点)</p><p>核心代码如下：</p><p></p><figure class="highlight c++"><figcaption><span>CompileFunction</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetCompilerContext::CompileFunction</span><span class="params">(FKismetFunctionContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为每个节点生成 statements (注意: 这里的节点顺序并不是最终执行顺序)</span></span><br><span class="line">	TMap&lt;UEdGraphNode*, int32&gt; SortKeyMap;</span><br><span class="line">	int32 NumNodesAtStart = Context.LinearExecutionList.<span class="built_in">Num</span>();</span><br><span class="line">	<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Context.LinearExecutionList.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		UEdGraphNode* Node = Context.LinearExecutionList[i];</span><br><span class="line">		SortKeyMap.<span class="built_in">Add</span>(Node, i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正生成 statement 的函数，我们自定义节点需要实现此方法</span></span><br><span class="line">		Handler-&gt;<span class="built_in">Compile</span>(Context, Node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将纯节点代码内联到需要该纯节点的非纯节点的代码中，并将纯节点撤出列表</span></span><br><span class="line">	TMap&lt; UEdGraphNode*, TSet&lt;UEdGraphNode*&gt; &gt; PureNodesNeeded;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (int32 TestIndex = <span class="number">0</span>; TestIndex &lt; Context.LinearExecutionList.<span class="built_in">Num</span>(); )</span><br><span class="line">	&#123;</span><br><span class="line">		UEdGraphNode* Node = Context.LinearExecutionList[TestIndex];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 此节点依赖的纯节点列表</span></span><br><span class="line">		<span class="keyword">bool</span> bHasAntecedentPureNodes = PureNodesNeeded.<span class="built_in">Contains</span>(Node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">IsNodePure</span>(Node))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 寻找标记为函数入口的节点的 statement</span></span><br><span class="line">			FBlueprintCompiledStatement* ProfilerStatement = <span class="literal">nullptr</span>;</span><br><span class="line">			TArray&lt;FBlueprintCompiledStatement*&gt;* SourceStatementList = Context.StatementsPerNode.<span class="built_in">Find</span>(Node);</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bDidNodeGenerateCode = SourceStatementList != <span class="literal">nullptr</span> &amp;&amp; SourceStatementList-&gt;<span class="built_in">Num</span>() &gt; <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (bDidNodeGenerateCode)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (FBlueprintCompiledStatement* Statement : *SourceStatementList)</span><br><span class="line">				&#123;</span><br><span class="line">                    <span class="comment">// KCST_InstrumentedPureNodeEntry 类型的 statement 对应函数入口纯节点</span></span><br><span class="line">					<span class="keyword">if</span> (Statement &amp;&amp; Statement-&gt;Type == KCST_InstrumentedPureNodeEntry)</span><br><span class="line">					&#123;</span><br><span class="line">						ProfilerStatement = Statement;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 根据输出引脚，将当前节点添加到其他节点的依赖列表中(如果此节点有意义)</span></span><br><span class="line">			<span class="keyword">if</span> (bDidNodeGenerateCode || bHasAntecedentPureNodes)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (int32 PinIndex = <span class="number">0</span>; PinIndex &lt; Node-&gt;Pins.<span class="built_in">Num</span>(); ++PinIndex)</span><br><span class="line">				&#123;</span><br><span class="line">					UEdGraphPin* Pin = Node-&gt;Pins[PinIndex];</span><br><span class="line">					<span class="keyword">if</span> (Pin-&gt;Direction == EGPD_Output &amp;&amp; Pin-&gt;LinkedTo.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">                        <span class="comment">// 记录纯节点中已连接的输出引脚</span></span><br><span class="line">						<span class="keyword">if</span> (ProfilerStatement)</span><br><span class="line">						&#123;</span><br><span class="line">							ProfilerStatement-&gt;PureOutputContextArray.<span class="built_in">AddUnique</span>(Pin);</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">for</span> (UEdGraphPin* LinkedTo : Pin-&gt;LinkedTo)</span><br><span class="line">						&#123;</span><br><span class="line">							UEdGraphNode* NodeUsingOutput = LinkedTo-&gt;<span class="built_in">GetOwningNode</span>();</span><br><span class="line">							<span class="keyword">if</span> (NodeUsingOutput != <span class="literal">nullptr</span>)</span><br><span class="line">							&#123;</span><br><span class="line">                                <span class="comment">// 添加此节点和其他此节点依赖的节点到输出引脚连接的节点的需求列表</span></span><br><span class="line">								TSet&lt;UEdGraphNode*&gt;&amp; TargetNodesRequired = PureNodesNeeded.<span class="built_in">FindOrAdd</span>(NodeUsingOutput);</span><br><span class="line">								TargetNodesRequired.<span class="built_in">Add</span>(Node);</span><br><span class="line">								<span class="keyword">if</span> (bHasAntecedentPureNodes)</span><br><span class="line">								&#123;</span><br><span class="line">									TargetNodesRequired.<span class="built_in">Append</span>(PureNodesNeeded.<span class="built_in">FindChecked</span>(Node));</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 从 LinearExecutionList 中移除此节点，依赖节点将内联此节点的代码</span></span><br><span class="line">			Context.LinearExecutionList.<span class="built_in">RemoveAt</span>(TestIndex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (bHasAntecedentPureNodes)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 如果此节点连接了纯节点的输出引脚，在此将纯节点代码内联到此节点的 statement 中</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 根据执行顺序下标排序节点</span></span><br><span class="line">				TSet&lt;UEdGraphNode*&gt;&amp; AntecedentPureNodes = PureNodesNeeded.<span class="built_in">FindChecked</span>(Node);</span><br><span class="line">				TArray&lt;UEdGraphNode*&gt; SortedPureNodes;</span><br><span class="line">				<span class="keyword">for</span> (TSet&lt;UEdGraphNode*&gt;::TIterator <span class="built_in">It</span>(AntecedentPureNodes); It; ++It)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">OrderedInsertIntoArray</span>(SortedPureNodes, SortKeyMap, *It);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 内联代码</span></span><br><span class="line">				<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; SortedPureNodes.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">				&#123;</span><br><span class="line">					UEdGraphNode* NodeToInline = SortedPureNodes[SortedPureNodes.<span class="built_in">Num</span>() - <span class="number">1</span> - i];</span><br><span class="line"></span><br><span class="line">					Context.<span class="built_in">CopyAndPrependStatements</span>(Node, NodeToInline);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理下一个节点</span></span><br><span class="line">			++TestIndex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，咱的纯节点代码的内联已经结束，且所有纯节点已被移出 LinearExecutionList</span></span><br><span class="line">    <span class="comment">// 接下来，初始化 Context.UnsortedSeparateExecutionGroups (函数上下文中的未排序单独执行组)</span></span><br><span class="line">    <span class="comment">// 此变量类型为 TArray&lt;TSet&lt;UEdGraphNode*&gt;&gt;，每个集合中装着一组独立的执行线</span></span><br><span class="line">	<span class="keyword">if</span> (Context.bIsUbergraph &amp;&amp; CompileOptions.<span class="built_in">DoesRequireCppCodeGeneration</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Context.UnsortedSeparateExecutionGroups = FKismetCompilerUtilities::<span class="built_in">FindUnsortedSeparateExecutionGroups</span>(Context.LinearExecutionList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里有些同学可能会问：<strong>在初始化和使用 <code>PureNodesNeeded</code> 时，怎么保证纯节点一定在非纯节点之前被处理？</strong></p><p>其实是因为在此之前，也就是重编译蓝图的时候，准确地说是预编译函数的时候，我们就已经对 <code>LinearExecutionList</code> 中的节点进行了排序。以下是排序的核心代码：</p><p></p><figure class="highlight c++"><figcaption><span>CreateExecutionSchedule</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用链: CompileClassLayout -&gt; PreCompileFunction -&gt; CreateLocalsAndRegisterNets</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGraphCompilerContext::CreateExecutionSchedule</span><span class="params">(<span class="keyword">const</span> TArray&lt;UEdGraphNode*&gt;&amp; GraphNodes, <span class="comment">/*out*/</span> TArray&lt;UEdGraphNode*&gt;&amp; LinearExecutionSchedule)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TArray&lt;UEdGraphNode*&gt; NodesWithNoEdges;</span><br><span class="line">	TMap&lt;UEdGraphNode*, int32&gt; NumIncomingEdges;</span><br><span class="line">	int32 TotalGraphEdgesLeft = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建没有前项的节点列表，更新每个节点的初始输入边的数量</span></span><br><span class="line">	<span class="keyword">for</span> (int32 NodeIndex = <span class="number">0</span>; NodeIndex &lt; GraphNodes.<span class="built_in">Num</span>(); ++NodeIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		UEdGraphNode* Node = GraphNodes[NodeIndex];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> int32 NumEdges = <span class="built_in">CountIncomingEdges</span>(Node);</span><br><span class="line">		NumIncomingEdges.<span class="built_in">Add</span>(Node, NumEdges);</span><br><span class="line">		TotalGraphEdgesLeft += NumEdges;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (NumEdges == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			NodesWithNoEdges.<span class="built_in">Add</span>(Node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度节点并将可调度的新节点进行排队</span></span><br><span class="line">	<span class="keyword">while</span> (NodesWithNoEdges.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 调度节点，将没有前项的节点添加到 LinearExecutionSchedule 列表中</span></span><br><span class="line">		UEdGraphNode* Node = NodesWithNoEdges[<span class="number">0</span>];</span><br><span class="line">		NodesWithNoEdges.<span class="built_in">RemoveAtSwap</span>(<span class="number">0</span>);</span><br><span class="line">		LinearExecutionSchedule.<span class="built_in">Add</span>(Node);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 减少连接此节点的边的计数，将减少至0的节点添加到 NodesWithNoEdges 数组中，等待下次调度</span></span><br><span class="line">		<span class="keyword">for</span> (int32 PinIndex = <span class="number">0</span>; PinIndex &lt; Node-&gt;Pins.<span class="built_in">Num</span>(); ++PinIndex)</span><br><span class="line">		&#123;</span><br><span class="line">			UEdGraphPin* OutPin = Node-&gt;Pins[PinIndex];</span><br><span class="line">			<span class="keyword">if</span> ((OutPin-&gt;Direction == EGPD_Output) &amp;&amp; <span class="built_in">PinIsImportantForDependancies</span>(OutPin))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (int32 LinkIndex = <span class="number">0</span>; LinkIndex &lt; OutPin-&gt;LinkedTo.<span class="built_in">Num</span>(); ++LinkIndex)</span><br><span class="line">				&#123;</span><br><span class="line">					UEdGraphNode* WasDependentNode = OutPin-&gt;LinkedTo[LinkIndex]-&gt;<span class="built_in">GetOwningNodeUnchecked</span>();</span><br><span class="line">					int32* pNumEdgesLeft = WasDependentNode ? NumIncomingEdges.<span class="built_in">Find</span>(WasDependentNode) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 减少连接该节点的节点的边计数，因为该节点已经被调度</span></span><br><span class="line">					<span class="keyword">if</span> (pNumEdgesLeft)</span><br><span class="line">					&#123;</span><br><span class="line">						int32&amp; NumEdgesLeft = *pNumEdgesLeft;</span><br><span class="line"></span><br><span class="line">						NumEdgesLeft--;</span><br><span class="line">						TotalGraphEdgesLeft--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 不再有任何边计数，则将此连接节点添加到 NodesWithNoEdges 列表中</span></span><br><span class="line">						<span class="keyword">if</span> (NumEdgesLeft == <span class="number">0</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							NodesWithNoEdges.<span class="built_in">Add</span>(WasDependentNode);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>CreateExecutionSchedule</code> 函数是根据所有节点当前是否有输入计数来排序的，没有则入队。然后遍历移除入队节点，并将入队节点的输出引脚所连接的节点的输入计数减一，如果减一后此节点的输入计数为零，则继续入队等待调度。直至可调度节点为零，排序完成。</p><p>举个栗子，如下图中的 <code>Text</code> 函数，处理步骤如下：</p><ul><li>首先，我们的函数入口节点 (以下称为节点 1) 和 <code>HelloBlueprint.get()</code> 节点 (节点 2) 是一开始就没有输入计数的，所以直接入队。(队列元素：1，2)</li><li>接着，取出队列中的节点 1，节点 1 的输出引脚与节点 3 相连，减少节点 3 的输入计数，减少后其计数为 0，节点 3 入队。(队列元素：2，3)</li><li>取出节点 2，节点 4 与节点 2 相连，节点 4 输入计数减一后其计数为 1，不入队 (队列元素：3)</li><li>取出节点 3，节点 4 与节点 3 相连，节点 4 输入计数减一后其计数为 0，入队 (队列元素：4)</li><li>...........</li></ul><p><img data-src="%E5%88%9D%E6%AC%A1%E5%BC%95%E8%84%9A%E6%8E%92%E5%BA%8F.png" alt="初次引脚排序"></p><h4 id="函数编译后处理"><a class="anchor" href="#函数编译后处理">#</a> 函数编译后处理</h4><p><code>PostcompileFunction</code> 的核心任务是 进行线性执行列表的最终排序，处理所有挂起的跳转修复，优化无用跳转。核心代码如下：</p><p></p><figure class="highlight c++"><figcaption><span>PostcompileFunction</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KismetCompiler.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetCompilerContext::PostcompileFunction</span><span class="params">(FKismetFunctionContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 进行线性执行列表的最终排序，处理所有挂起的跳转修复，优化无用跳转</span></span><br><span class="line">	Context.<span class="built_in">ResolveStatements</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数的属性链接，设置编译结束标记，及函数的相关元数据</span></span><br><span class="line">	<span class="built_in">FinishCompilingFunction</span>(Context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetFunctionContext::ResolveStatements</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 进行线性执行列表的最终排序 (下文展开)</span></span><br><span class="line">	<span class="built_in">FinalSortLinearExecList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理所有挂起的跳转</span></span><br><span class="line">	<span class="built_in">ResolveGotoFixups</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FBoolConfigValueHelper <span class="title">OptimizeAdjacentStates</span><span class="params">(TEXT(<span class="string">&quot;Kismet&quot;</span>), TEXT(<span class="string">&quot;bOptimizeAdjacentStates&quot;</span>), GEngineIni)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (OptimizeAdjacentStates)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 优化 LinearExecationList 中的无用跳转</span></span><br><span class="line">		<span class="built_in">MergeAdjacentStates</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>函数上下文中节点的最后排序在 <code>FinalSortLinearExecList()</code> 中进行，其排序步骤如下：</p><ul><li>首先找到入口节点 (下图中的节点 1)，将其排序到 <code>LinearExectionList</code> 中，</li><li>然后查看入口节点的输出执行节点连接的节点 (节点 2)，将其入队 <code>NodesToStartNextChain</code> ，</li><li>将队列中的节点 2 取出并排序 (到 <code>LinearExectionList</code> 中)，将节点 2 输出执行节点连接的节点 (3，4，5，6) 入队。</li><li>将队列中的节点 3 取出并排序，节点 3 输出执行节点并没有连接任何节点，不需要入队。</li><li>将队列中的节点 4 取出并排序，将节点 4 输出执行节点连接的节点 (7，8) 入队。</li><li>将队列中的节点 5，6，7，8 依次取出并排序。</li></ul><p><img data-src="%E6%9C%80%E5%90%8E%E5%BC%95%E8%84%9A%E6%8E%92%E5%BA%8F.png" alt="最后引脚排序"></p><p>核心代码如下：</p><p></p><figure class="highlight c++"><figcaption><span>FinalSortLinearExecList</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KismetCompilerMisc.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetFunctionContext::FinalSortLinearExecList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TSet&lt;UEdGraphNode*&gt; <span class="title">UnsortedExecutionSet</span><span class="params">(LinearExecutionList)</span></span>;</span><br><span class="line">	LinearExecutionList.<span class="built_in">Empty</span>();</span><br><span class="line">	TArray&lt;UEdGraphNode*&gt; SortedLinearExecutionList;</span><br><span class="line">    </span><br><span class="line">    SortedLinearExecutionList.<span class="built_in">Push</span>(EntryPoint);</span><br><span class="line">	UnsortedExecutionSet.<span class="built_in">Remove</span>(EntryPoint);</span><br><span class="line"></span><br><span class="line">	TSet&lt;UEdGraphNode*&gt; NodesToStartNextChain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (UnsortedExecutionSet.<span class="built_in">Num</span>())</span><br><span class="line">	&#123;</span><br><span class="line">        </span><br><span class="line">        UEdGraphNode* NextNode = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get last state target</span></span><br><span class="line">		<span class="keyword">const</span> UEdGraphNode* CurrentNode = SortedLinearExecutionList.<span class="built_in">Last</span>();</span><br><span class="line">		<span class="keyword">const</span> TArray&lt;FBlueprintCompiledStatement*&gt;* CurStatementList = StatementsPerNode.<span class="built_in">Find</span>(CurrentNode);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> CurrentNodeIsValid = CurrentNode &amp;&amp; CurStatementList &amp;&amp; CurStatementList-&gt;<span class="built_in">Num</span>();</span><br><span class="line">		<span class="keyword">const</span> FBlueprintCompiledStatement* LastStatementInCurrentNode = CurrentNodeIsValid ? CurStatementList-&gt;<span class="built_in">Last</span>() : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Find next element in current chain</span></span><br><span class="line">		<span class="keyword">if</span> (LastStatementInCurrentNode &amp;&amp; (LastStatementInCurrentNode-&gt;Type == KCST_UnconditionalGoto))</span><br><span class="line">		&#123;</span><br><span class="line">			UEdGraphNode* TargetNode = FGotoMapUtils::<span class="built_in">TargetNodeFromMap</span>(LastStatementInCurrentNode, GotoFixupRequestMap);</span><br><span class="line">			NextNode = UnsortedExecutionSet.<span class="built_in">Remove</span>(TargetNode) ? TargetNode : <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CurrentNode)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (UEdGraphPin* Pin : CurrentNode-&gt;Pins)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (Pin &amp;&amp; (EEdGraphPinDirection::EGPD_Output == Pin-&gt;Direction) &amp;&amp; K2Schema-&gt;<span class="built_in">IsExecPin</span>(*Pin) &amp;&amp; Pin-&gt;LinkedTo.<span class="built_in">Num</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (UEdGraphPin* Link : Pin-&gt;LinkedTo)</span><br><span class="line">					&#123;</span><br><span class="line">						UEdGraphNode* LinkedNode = Link-&gt;<span class="built_in">GetOwningNodeUnchecked</span>();</span><br><span class="line">						<span class="keyword">if</span> (LinkedNode &amp;&amp; (LinkedNode != NextNode) &amp;&amp; UnsortedExecutionSet.<span class="built_in">Contains</span>(LinkedNode))</span><br><span class="line">						&#123;</span><br><span class="line">							NodesToStartNextChain.<span class="built_in">Add</span>(LinkedNode);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Start next chain if the current is done</span></span><br><span class="line">		<span class="keyword">while</span> (NodesToStartNextChain.<span class="built_in">Num</span>() &amp;&amp; !NextNode)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> Iter = NodesToStartNextChain.<span class="built_in">CreateIterator</span>();</span><br><span class="line">			NextNode = UnsortedExecutionSet.<span class="built_in">Remove</span>(*Iter) ? *Iter : <span class="literal">NULL</span>;</span><br><span class="line">			Iter.<span class="built_in">RemoveCurrent</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!NextNode)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> Iter = UnsortedExecutionSet.<span class="built_in">CreateIterator</span>();</span><br><span class="line">			NextNode = *Iter;</span><br><span class="line">			Iter.<span class="built_in">RemoveCurrent</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SortedLinearExecutionList.<span class="built_in">Push</span>(NextNode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LinearExecutionList = SortedLinearExecutionList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="填充函数体和框架蓝图类的根存函数体"><a class="anchor" href="#填充函数体和框架蓝图类的根存函数体">#</a> 填充函数体和框架蓝图类的根存函数体</h4><p>此步骤在 <code>CompileFunctions</code> 中执行，主要完成 VM 后端的字节码生成和 cpp 后端的代码生成。以下是核心代码：</p><p></p><figure class="highlight c++"><figcaption><span>VMBackend::GenerateCodeFromClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KismetCompilerVMBackend.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetCompilerVMBackend::GenerateCodeFromClass</span><span class="params">(UClass* SourceClass, TIndirectArray&lt;FKismetFunctionContext&gt;&amp; Functions, <span class="keyword">bool</span> bGenerateStubsOnly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 生成字节码</span></span><br><span class="line">	<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Functions.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		FKismetFunctionContext&amp; Function = Functions[i];</span><br><span class="line">		<span class="keyword">if</span> (Function.<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bIsUbergraph = (i == <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">ConstructFunction</span>(Function, bIsUbergraph, bGenerateStubsOnly);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 CalledFunctions 中移除重复的函数</span></span><br><span class="line">	UBlueprintGeneratedClass* ClassBeingBuilt = CastChecked&lt;UBlueprintGeneratedClass&gt;(SourceClass);</span><br><span class="line">	<span class="function">TSet&lt;UFunction*&gt; <span class="title">Unique</span><span class="params">(ClassBeingBuilt-&gt;CalledFunctions)</span></span>;</span><br><span class="line">	ClassBeingBuilt-&gt;CalledFunctions = Unique.<span class="built_in">Array</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FKismetCompilerVMBackend::ConstructFunction</span><span class="params">(FKismetFunctionContext&amp; FunctionContext, <span class="keyword">bool</span> bIsUbergraph, <span class="keyword">bool</span> bGenerateStubOnly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UFunction* Function = FunctionContext.Function;</span><br><span class="line">	UBlueprintGeneratedClass* Class = FunctionContext.NewClass;</span><br><span class="line"></span><br><span class="line">	FString FunctionName;</span><br><span class="line">	Function-&gt;<span class="built_in">GetName</span>(FunctionName);</span><br><span class="line"></span><br><span class="line">	TArray&lt;uint8&gt;&amp; ScriptArray = Function-&gt;Script;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回语句 </span></span><br><span class="line">	FBlueprintCompiledStatement ReturnStatement;</span><br><span class="line">	ReturnStatement.Type = KCST_Return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建脚本书写器，用于书写字节码</span></span><br><span class="line">	<span class="function">FScriptBuilderBase <span class="title">ScriptWriter</span><span class="params">(ScriptArray, Class, Schema, UbergraphStatementLabelMap, bIsUbergraph, ReturnStatement)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bGenerateStubOnly)</span><br><span class="line">	&#123;</span><br><span class="line">		ReturnStatement.bIsJumpTarget = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (FunctionContext.bUseFlowStack)</span><br><span class="line">		&#123;</span><br><span class="line">			ScriptWriter.<span class="built_in">PushReturnAddress</span>(ReturnStatement);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 按 LinearExecutionList 的顺序产出代码(第一个节点总是函数的入口)</span></span><br><span class="line">		<span class="keyword">for</span> (int32 NodeIndex = <span class="number">0</span>; NodeIndex &lt; FunctionContext.LinearExecutionList.<span class="built_in">Num</span>(); ++NodeIndex)</span><br><span class="line">		&#123;</span><br><span class="line">			UEdGraphNode* StatementNode = FunctionContext.LinearExecutionList[NodeIndex];</span><br><span class="line">			TArray&lt;FBlueprintCompiledStatement*&gt;* StatementList = FunctionContext.StatementsPerNode.<span class="built_in">Find</span>(StatementNode);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (StatementList != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (int32 StatementIndex = <span class="number">0</span>; StatementIndex &lt; StatementList-&gt;<span class="built_in">Num</span>(); ++StatementIndex)</span><br><span class="line">				&#123;</span><br><span class="line">					FBlueprintCompiledStatement* Statement = (*StatementList)[StatementIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 为 Statement 生成代码的核心函数，下文解析</span></span><br><span class="line">					ScriptWriter.<span class="built_in">GenerateCodeForStatement</span>(CompilerContext, FunctionContext, *Statement, StatementNode);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">bool</span> bUberGraphFunctionCall = Statement-&gt;FunctionToCall &amp;&amp; (Statement-&gt;FunctionToCall == Class-&gt;UberGraphFunction)</span><br><span class="line">						&amp;&amp; (EKismetCompiledStatementType::KCST_CallFunction == Statement-&gt;Type);</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">bool</span> bIsReducible = FKismetCompilerUtilities::<span class="built_in">IsStatementReducible</span>(Statement-&gt;Type) || bUberGraphFunctionCall;</span><br><span class="line">					bAnyNonReducibleFunctionGenerated |= !bIsReducible;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理函数返回值</span></span><br><span class="line">	ScriptWriter.<span class="built_in">GenerateCodeForStatement</span>(CompilerContext, FunctionContext, ReturnStatement, <span class="literal">NULL</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修复跳转地址</span></span><br><span class="line">	ScriptWriter.<span class="built_in">PerformFixups</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭脚本编辑</span></span><br><span class="line">	ScriptWriter.<span class="built_in">CloseScript</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存ubergraph中的偏移量，以便以后修补存根</span></span><br><span class="line">	<span class="keyword">if</span> (bIsUbergraph)</span><br><span class="line">	&#123;</span><br><span class="line">		ScriptWriter.<span class="built_in">CopyStatementMapToUbergraphMap</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保我们没有超出最大字节数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SCRIPT_LIMIT_BYTECODE_TO_64KB</span></span><br><span class="line">	<span class="keyword">if</span> (ScriptArray.<span class="built_in">Num</span>() &gt; <span class="number">0xFFFF</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageLog.<span class="built_in">Error</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Script exceeded bytecode length limit of 64 KB&quot;</span>));</span><br><span class="line">		ScriptArray.<span class="built_in">Empty</span>();</span><br><span class="line">		ScriptArray.<span class="built_in">Add</span>(EX_EndOfScript);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(CodeSkipSizeType) == <span class="number">4</span>, <span class="string">&quot;Update this code as size changed.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateCodeForStatement</span><span class="params">(FKismetCompilerContext&amp; CompilerContext, FKismetFunctionContext&amp; FunctionContext, FBlueprintCompiledStatement&amp; Statement, UEdGraphNode* SourceNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果此 Statement 被作为跳转目标，则记录此 Statement 起始位置的字节码</span></span><br><span class="line">    <span class="keyword">if</span> (Statement.bIsJumpTarget)</span><br><span class="line">    &#123;</span><br><span class="line">        StatementLabelMap.<span class="built_in">Add</span>(&amp;Statement, Writer.ScriptBuffer.<span class="built_in">Num</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 Statement 的类型使用不同策略生成字节码</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (Statement.Type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> KCST_Nop:</span><br><span class="line">            Writer &lt;&lt; EX_Nothing;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KCST_CallFunction:</span><br><span class="line">            <span class="built_in">EmitFunctionCall</span>(CompilerContext, FunctionContext, Statement, SourceNode);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KCST_CallDelegate:</span><br><span class="line">            <span class="built_in">EmitCallDelegate</span>(Statement);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmitFunctionCall</span><span class="params">(FKismetCompilerContext&amp; CompilerContext, FKismetFunctionContext&amp; FunctionContext, FBlueprintCompiledStatement&amp; Statement, UEdGraphNode* SourceNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UFunction* FunctionToCall = Statement.FunctionToCall;</span><br><span class="line">    </span><br><span class="line">    ClassBeingBuilt-&gt;CalledFunctions.<span class="built_in">Emplace</span>(FunctionToCall);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FunctionToCall-&gt;<span class="built_in">HasAllFunctionFlags</span>(FUNC_Native))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 数组输出参数已被清理，但本地函数在填充数组输出参数前是不需要清理的</span></span><br><span class="line">        <span class="comment">// 所以先获取 Statement 中的数组并写入 Writer 中，生成字节码</span></span><br><span class="line">        int32 NumParams = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="built_in">PropIt</span>(FunctionToCall); PropIt &amp;&amp; (PropIt-&gt;PropertyFlags &amp; CPF_Parm); ++PropIt)</span><br><span class="line">        &#123;</span><br><span class="line">            FProperty* Param = *PropIt;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> bShouldParameterBeCleared = Param-&gt;IsA&lt;FArrayProperty&gt;()</span><br><span class="line">                &amp;&amp; Param-&gt;<span class="built_in">HasAllPropertyFlags</span>(CPF_Parm | CPF_OutParm)</span><br><span class="line">                &amp;&amp; !Param-&gt;<span class="built_in">HasAnyPropertyFlags</span>(CPF_ReferenceParm | CPF_ConstParm | CPF_ReturnParm);</span><br><span class="line">            <span class="keyword">if</span> (bShouldParameterBeCleared)</span><br><span class="line">            &#123;</span><br><span class="line">                Writer &lt;&lt; EX_SetArray;</span><br><span class="line">                FBPTerminal* ArrayTerm = Statement.RHS[NumParams];</span><br><span class="line">                <span class="built_in">EmitTerm</span>(ArrayTerm, Param);</span><br><span class="line">                Writer &lt;&lt; EX_EndArray;</span><br><span class="line">            &#125;</span><br><span class="line">            NumParams += Param-&gt;<span class="built_in">HasAnyPropertyFlags</span>(CPF_ReturnParm) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 TargetLabel 在 UberGraph 中的偏移，并记录到 RHS 中</span></span><br><span class="line">    <span class="keyword">if</span> ((Statement.TargetLabel != <span class="literal">NULL</span>) &amp;&amp; !bIsUbergraph)</span><br><span class="line">    &#123;</span><br><span class="line">        CodeSkipSizeType OffsetWithinUbergraph = UbergraphStatementLabelMap.<span class="built_in">FindChecked</span>(Statement.TargetLabel);</span><br><span class="line"></span><br><span class="line">        Statement.RHS[Statement.UbergraphCallIndex]-&gt;Name = FString::<span class="built_in">FromInt</span>(OffsetWithinUbergraph);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理返回值赋值(如果存在) 注意: Out输出是不生成字节码的</span></span><br><span class="line">    <span class="keyword">bool</span> bHasOutputValue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="built_in">PropIt</span>(FunctionToCall); PropIt &amp;&amp; (PropIt-&gt;PropertyFlags &amp; CPF_Parm); ++PropIt)</span><br><span class="line">    &#123;</span><br><span class="line">        FProperty* FuncParamProperty = *PropIt;</span><br><span class="line">        <span class="keyword">if</span> (FuncParamProperty-&gt;<span class="built_in">HasAnyPropertyFlags</span>(CPF_ReturnParm))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Statement.LHS)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 输出返回值的目标表达式(序列化字节码)</span></span><br><span class="line">                <span class="built_in">EmitDestinationExpression</span>(Statement.LHS);</span><br><span class="line">            &#125;</span><br><span class="line">            bHasOutputValue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (FuncParamProperty-&gt;<span class="built_in">HasAnyPropertyFlags</span>(CPF_OutParm) &amp;&amp; !FuncParamProperty-&gt;<span class="built_in">HasAnyPropertyFlags</span>(CPF_ConstParm))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有 Out 输出 (函数传入引用参数作为输出)</span></span><br><span class="line">            bHasOutputValue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为函数上下文输出字节码，Math函数不需要上下文</span></span><br><span class="line">    <span class="function">FContextEmitter <span class="title">CallContextWriter</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...... 为函数调用类型生成字节码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...... 为函数参数生成字节码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...... 为可变函数的额外数据生成字节码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成 EX_EndFuntionParams 字节码，标志着参数列表字节码生成结束</span></span><br><span class="line">    Writer &lt;&lt; EX_EndFunctionParms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>到此，蓝图编译语句 Statement 的字节码已经生成完成。字节码的具体内容其实是 <code>FScriptBytecodeWriter</code> 根据各种不同数据类型序列化出来的数据，感兴趣的同学可以深入研究一下。</p><p>接下来是 cpp 后端生成代码的过程，核心函数如下：</p><p></p><figure class="highlight c++"><figcaption><span>cppBackend::GenerateCodeFromClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlueprintCompilerCppBackendBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">FBlueprintCompilerCppBackendBase::GenerateCodeFromClass</span><span class="params">(UClass* SourceClass, TIndirectArray&lt;FKismetFunctionContext&gt;&amp; Functions, <span class="keyword">bool</span> bGenerateStubsOnly, <span class="keyword">const</span> FCompilerNativizationOptions&amp; NativizationOptions, FString&amp; OutCppBody)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">CleanBackend</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将每个函数上下文的每个独立节点的 Statements 添加到 UberGraphStatementToExecutionGroup 中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; FunctionContext : Functions)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (FunctionContext.bIsUbergraph)</span><br><span class="line">		&#123;</span><br><span class="line">			UberGraphContext = &amp;FunctionContext;</span><br><span class="line">			<span class="keyword">for</span> (int32 ExecutionGroupIndex = <span class="number">0</span>; ExecutionGroupIndex &lt; FunctionContext.UnsortedSeparateExecutionGroups.<span class="built_in">Num</span>(); ++ExecutionGroupIndex)</span><br><span class="line">			&#123;</span><br><span class="line">				TSet&lt;UEdGraphNode*&gt;&amp; ExecutionGroup = FunctionContext.UnsortedSeparateExecutionGroups[ExecutionGroupIndex];</span><br><span class="line">				<span class="keyword">for</span> (UEdGraphNode* LocNode : ExecutionGroup)</span><br><span class="line">				&#123;</span><br><span class="line">					TArray&lt;FBlueprintCompiledStatement*&gt;* LocStatementsPtr = FunctionContext.StatementsPerNode.<span class="built_in">Find</span>(LocNode);</span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">ensure</span>(LocStatementsPtr))</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span> (FBlueprintCompiledStatement* LocStatement : *LocStatementsPtr)</span><br><span class="line">						&#123;</span><br><span class="line">							UberGraphStatementToExecutionGroup.<span class="built_in">Add</span>(LocStatement, ExecutionGroupIndex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> CleanCppClassName = FEmitHelper::<span class="built_in">GetBaseFilename</span>(SourceClass, NativizationOptions);</span><br><span class="line">	<span class="keyword">auto</span> CppClassName = FEmitHelper::<span class="built_in">GetCppName</span>(SourceClass);</span><br><span class="line">	</span><br><span class="line">	TSharedPtr&lt;FGatherConvertedClassDependencies&gt; Dependencies = FGatherConvertedClassDependencies::<span class="built_in">Get</span>(SourceClass, NativizationOptions);</span><br><span class="line">	FNativizationSummaryHelper::<span class="built_in">RegisterRequiredModules</span>(NativizationOptions.PlatformName, Dependencies-&gt;RequiredModuleNames);</span><br><span class="line">	<span class="function">FEmitterLocalContext <span class="title">EmitterContext</span><span class="params">(Dependencies.ToSharedRef().Get(), NativizationOptions)</span></span>;</span><br><span class="line"></span><br><span class="line">	UClass* OriginalSourceClass = Dependencies-&gt;<span class="built_in">FindOriginalClass</span>(SourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册依赖类</span></span><br><span class="line">	FNativizationSummaryHelper::<span class="built_in">RegisterClass</span>(OriginalSourceClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始写cpp代码！写开头的 #pragma once 和 #include</span></span><br><span class="line">	<span class="built_in">EmitFileBeginning</span>(CleanCppClassName, EmitterContext);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> TCHAR* PlaceholderForInlinedStructInlude = <span class="built_in">TEXT</span>(<span class="string">&quot;//PlaceholderForInlinedStructInlude&quot;</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bIsInterface = SourceClass-&gt;IsChildOf&lt;UInterface&gt;();</span><br><span class="line">	<span class="keyword">if</span> (!bIsInterface)</span><br><span class="line">	&#123;</span><br><span class="line">		EmitterContext.Body.<span class="built_in">AddLine</span>(PlaceholderForInlinedStructInlude);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bHasStaticSearchableValues = FBackendHelperStaticSearchableValues::<span class="built_in">HasSearchableValues</span>(SourceClass);</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 类定义</span></span><br><span class="line">		<span class="keyword">if</span> (bIsInterface)</span><br><span class="line">		&#123;</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;UINTERFACE(Blueprintable, %s)&quot;</span>), *FEmitHelper::<span class="built_in">ReplaceConvertedMetaData</span>(OriginalSourceClass)));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;class %s : public UInterface&quot;</span>), *FEmitHelper::<span class="built_in">GetCppName</span>(SourceClass, <span class="literal">true</span>)));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">IncreaseIndent</span>();</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;GENERATED_BODY()&quot;</span>));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;static void __CustomDynamicClassInitialization(UDynamicClass* InDynamicClass) &#123;&#125;&quot;</span>));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">DecreaseIndent</span>();</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#125;;&quot;</span>));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;class %s&quot;</span>), *CppClassName));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			TArray&lt;FString&gt; AdditionalMD;</span><br><span class="line">			<span class="keyword">const</span> FString ReplaceConvertedMD = FEmitHelper::<span class="built_in">GenerateReplaceConvertedMD</span>(OriginalSourceClass);</span><br><span class="line">			<span class="keyword">if</span> (!ReplaceConvertedMD.<span class="built_in">IsEmpty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				AdditionalMD.<span class="built_in">Add</span>(ReplaceConvertedMD);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (bHasStaticSearchableValues)</span><br><span class="line">			&#123;</span><br><span class="line">				AdditionalMD.<span class="built_in">Add</span>(FBackendHelperStaticSearchableValues::<span class="built_in">GenerateClassMetaData</span>(SourceClass));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">const</span> FString DefinedConfigName = (OriginalSourceClass-&gt;ClassConfigName == NAME_None) ? <span class="built_in">FString</span>() : FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;config=%s, &quot;</span>), *OriginalSourceClass-&gt;ClassConfigName.<span class="built_in">ToString</span>());</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;UCLASS(%s%s%s)&quot;</span>)</span><br><span class="line">				, *DefinedConfigName</span><br><span class="line">				, (!SourceClass-&gt;IsChildOf&lt;UBlueprintFunctionLibrary&gt;()) ? <span class="built_in">TEXT</span>(<span class="string">&quot;Blueprintable, BlueprintType, &quot;</span>) : <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">				, *FEmitHelper::<span class="built_in">HandleMetaData</span>(<span class="built_in">FFieldVariant</span>(), <span class="literal">false</span>, &amp;AdditionalMD)));</span><br><span class="line"></span><br><span class="line">			UClass* SuperClass = SourceClass-&gt;<span class="built_in">GetSuperClass</span>();</span><br><span class="line">			FString ClassDefinition = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;class %s : public %s&quot;</span>), *CppClassName, *FEmitHelper::<span class="built_in">GetCppName</span>(SuperClass));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ImplementedInterface : SourceClass-&gt;Interfaces)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ImplementedInterface.Class)</span><br><span class="line">				&#123;</span><br><span class="line">					ClassDefinition += FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;, public %s&quot;</span>), *FEmitHelper::<span class="built_in">GetCppName</span>(ImplementedInterface.Class));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(ClassDefinition);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始写类内部代码</span></span><br><span class="line">		EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#123;&quot;</span>));</span><br><span class="line">		EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;public:&quot;</span>));</span><br><span class="line">		EmitterContext.Header.<span class="built_in">IncreaseIndent</span>();</span><br><span class="line">		EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;GENERATED_BODY()&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DeclareDelegates</span>(EmitterContext, Functions);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">EmitStructProperties</span>(EmitterContext, SourceClass);</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			IBlueprintCompilerCppBackendModule&amp; BackEndModule = (IBlueprintCompilerCppBackendModule&amp;)IBlueprintCompilerCppBackendModule::<span class="built_in">Get</span>();</span><br><span class="line">			TSharedPtr&lt;FNativizationSummary&gt; NativizationSummary = BackEndModule.<span class="built_in">NativizationSummary</span>();</span><br><span class="line">			<span class="keyword">if</span> (NativizationSummary.<span class="built_in">IsValid</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="built_in">It</span>(SourceClass, EFieldIteratorFlags::ExcludeSuper); It; ++It)</span><br><span class="line">				&#123;</span><br><span class="line">					FProperty* Property = *It;</span><br><span class="line">					<span class="keyword">if</span> (Property &amp;&amp; Property-&gt;<span class="built_in">HasAllPropertyFlags</span>(CPF_Transient | CPF_DuplicateTransient))</span><br><span class="line">					&#123;</span><br><span class="line">						NativizationSummary-&gt;MemberVariablesFromGraph++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TSharedPtr&lt;FGatherConvertedClassDependencies&gt; ParentDependencies;</span><br><span class="line">		<span class="comment">// 写函数声明和定义 (同时写入函数头和函数体)</span></span><br><span class="line">		<span class="keyword">if</span> (!bIsInterface)</span><br><span class="line">		&#123;</span><br><span class="line">			UBlueprintGeneratedClass* BPGC = CastChecked&lt;UBlueprintGeneratedClass&gt;(EmitterContext.<span class="built_in">GetCurrentlyGeneratedClass</span>());</span><br><span class="line">			UBlueprintGeneratedClass* ParentBPGC = Cast&lt;UBlueprintGeneratedClass&gt;(BPGC-&gt;<span class="built_in">GetSuperClass</span>());</span><br><span class="line">			ParentDependencies = FGatherConvertedClassDependencies::<span class="built_in">Get</span>(ParentBPGC, NativizationOptions);</span><br><span class="line"></span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());&quot;</span>), *CppClassName));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;virtual void PostLoadSubobjects(FObjectInstancingGraph* OuterInstanceGraph) override;&quot;</span>));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;static void __CustomDynamicClassInitialization(UDynamicClass* InDynamicClass);&quot;</span>));</span><br><span class="line"></span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;static void __StaticDependenciesAssets(TArray&lt;FBlueprintDependencyData&gt;&amp; AssetsToLoad);&quot;</span>));</span><br><span class="line">			EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;static void __StaticDependencies_DirectlyUsedAssets(TArray&lt;FBlueprintDependencyData&gt;&amp; AssetsToLoad);&quot;</span>));</span><br><span class="line">			<span class="keyword">if</span> (bHasStaticSearchableValues)</span><br><span class="line">			&#123;</span><br><span class="line">				FBackendHelperStaticSearchableValues::<span class="built_in">EmitFunctionDeclaration</span>(EmitterContext);</span><br><span class="line">				FBackendHelperStaticSearchableValues::<span class="built_in">EmitFunctionDefinition</span>(EmitterContext);</span><br><span class="line">			&#125;</span><br><span class="line">			FEmitDefaultValueHelper::<span class="built_in">GenerateConstructor</span>(EmitterContext);</span><br><span class="line">			FEmitDefaultValueHelper::<span class="built_in">GenerateCustomDynamicClassInitialization</span>(EmitterContext, ParentDependencies);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建状态映射</span></span><br><span class="line">		<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Functions.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			StateMapPerFunction.<span class="built_in">Add</span>(<span class="built_in">FFunctionLabelInfo</span>());</span><br><span class="line">			FunctionIndexMap.<span class="built_in">Add</span>(&amp;Functions[i], i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Functions.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Functions[i].<span class="built_in">IsValid</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ConstructFunction</span>(Functions[i], EmitterContext, bGenerateStubsOnly);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		EmitterContext.Header.<span class="built_in">DecreaseIndent</span>();</span><br><span class="line">		EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;public:&quot;</span>));</span><br><span class="line">		EmitterContext.Header.<span class="built_in">IncreaseIndent</span>();</span><br><span class="line"></span><br><span class="line">		FBackendHelperUMG::<span class="built_in">WidgetFunctionsInHeader</span>(EmitterContext);</span><br><span class="line"></span><br><span class="line">		EmitterContext.Header.<span class="built_in">DecreaseIndent</span>();</span><br><span class="line">		EmitterContext.Header.<span class="built_in">AddLine</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#125;;&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!bIsInterface)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 必须在 GenerateConstructor 和 GenerateCustomDynamicClassInitialization 和其他函数调用后执行</span></span><br><span class="line">            <span class="comment">// 现在我们知道源代码中哪些资源是直接使用的</span></span><br><span class="line">			FEmitDefaultValueHelper::<span class="built_in">AddStaticFunctionsForDependencies</span>(EmitterContext, ParentDependencies, NativizationOptions);</span><br><span class="line">			FEmitDefaultValueHelper::<span class="built_in">AddRegisterHelper</span>(EmitterContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		FEmitHelper::<span class="built_in">EmitLifetimeReplicatedPropsImpl</span>(EmitterContext);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bIsInterface)</span><br><span class="line">	&#123;</span><br><span class="line">		FCodeText AdditionalIncludes;</span><br><span class="line">		TSet&lt;FString&gt; DummyStrSet;</span><br><span class="line">		FIncludeHeaderHelper::<span class="built_in">EmitInner</span>(AdditionalIncludes, EmitterContext.StructsUsedAsInlineValues, TSet&lt;UField*&gt;&#123;&#125;, EmitterContext.NativizationOptions, DummyStrSet);</span><br><span class="line">		EmitterContext.Body.Result.<span class="built_in">ReplaceInline</span>(PlaceholderForInlinedStructInlude, *AdditionalIncludes.Result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CleanBackend</span>();</span><br><span class="line"></span><br><span class="line">	OutCppBody = EmitterContext.Body.Result;</span><br><span class="line">	<span class="keyword">return</span> EmitterContext.Header.Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>就是生成此蓝图的 CPP 代码，不展开分析。</p><h2 id="蓝图编辑器的实现"><a class="anchor" href="#蓝图编辑器的实现">#</a> 蓝图编辑器的实现</h2><p>概要：蓝图编辑器相信大家都不陌生了。不知道你是否也与写者一般，刚接触蓝图可视化编程时万分感慨其开发便利性，是否也曾充斥着研究编辑器实现机制的无限热情却力不从心。闲话不多说，让咱先看看蓝图编辑器是怎么工作的吧 😃</p><p>前面编译蓝图时，我们用到了事件表，节点，引脚等对象。这些对象其实是开发者在蓝图编辑器中开发时添加到蓝图中的，然后再通过编译蓝图的方式产出新的 <code>BPGC</code> , <code>CDO</code> , 字节码等，供游戏运行时使用。</p><p>回想一下，我们在使用蓝图开发时，首先要打开某个蓝图，然后可能还会添加一些节点，但有些节点又不是所有蓝图都能使用的。就是这么简单的几个步骤，已经包含了我们需要研究的所有内容。</p><ol><li>打开蓝图，我们需要将蓝图编辑器和图编辑器的 Slate 显示出来 -&gt; <code>SGraphEditor</code></li><li>添加蓝图节点，即 <code>UK2Node</code> 继承于 <code>UGraphNode</code></li><li>某些图不能添加特定节点，由 <code>UEdGraphSchema_K2</code> 控制，继承于 <code>UEdGraphSchema</code></li></ol><p>按 MVC 三层框架即 Model -&gt; <code>UGraphNode</code> , View -&gt; <code>SGraphEditor</code> , Control -&gt; <code>UEdGraphSchema_K2</code> 。接下来，我们将分别分析每个类的内部结构 及其在编辑器中的工作机制。</p><h3 id="node-uedgraphnode"><a class="anchor" href="#node-uedgraphnode">#</a> Node | UEdGraphNode</h3><p><code>UEdGraphNode</code> 译为编辑器图节点，定义了蓝图节点在编辑器中的位置，该节点所包含的引脚，该节点在当前蓝图中是否可用，该节点的复制粘贴方法等。以下是 <code>UEdGraphNode</code> 的一些常用属性与方法：</p><p></p><figure class="highlight c++"><figcaption><span>UEdGraphNode</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ENGINE_API</span> <span class="title">UEdGraphNode</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 此节点的所有引脚，包含输入与输出引脚 */</span></span><br><span class="line">    TArray&lt;UEdGraphPin*&gt; Pins;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 此节点在编辑器中 X 方向的位置 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	int32 NodePosX;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此节点在编辑器中 Y 方向的位置 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	int32 NodePosY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此节点在编辑器中的宽度; 只在节点允许改变大小时使用 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	int32 NodeWidth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此节点在编辑器中的宽高度; 只在节点允许改变大小时使用 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	int32 NodeHeight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 此节点所包含的高级引脚的显示方式。是否显示 */</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TEnumAsByte&lt;ENodeAdvancedPins::Type&gt; AdvancedPinDisplay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 使用提供的信息为此节点创建新引脚，并返回此引脚 */</span></span><br><span class="line">	<span class="function">UEdGraphPin* <span class="title">CreatePin</span><span class="params">(EEdGraphPinDirection Dir, <span class="keyword">const</span> FName PinCategory, <span class="keyword">const</span> FName PinName, <span class="keyword">const</span> FCreatePinParams&amp; PinParams = FCreatePinParams())</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">CreatePin</span>(Dir, PinCategory, NAME_None, <span class="literal">nullptr</span>, PinName, PinParams);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 销毁特定引脚，不修改其所属的引脚的引脚列表 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DestroyPin</span><span class="params">(UEdGraphPin* Pin)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 寻找此节点中特定名称和类型(输入或输出)的引脚 */</span></span><br><span class="line">	<span class="function">UEdGraphPin* <span class="title">FindPin</span><span class="params">(<span class="keyword">const</span> FName PinName, <span class="keyword">const</span> EEdGraphPinDirection Direction = EGPD_MAX)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 基于节点类型为给定节点分配默认引脚.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return	引脚创建成功返回帧，否则返回假(如函数调用引脚寻找函数失败)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AllocateDefaultPins</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 获取节点名称，在标题栏中显示 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetNodeTitle</span><span class="params">(ENodeTitleType::Type TitleType)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 当此节点的任何一个引脚的默认值在编辑器中被改变时调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PinDefaultValueChanged</span><span class="params">(UEdGraphPin* Pin)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 用于寻找此节点的关键词 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetKeywords</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">/** 定义此类型节点可以在哪些特定的图中被创建 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsCompatibleWithGraph</span><span class="params">(UEdGraph <span class="keyword">const</span>* Graph)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 当任意引脚的连接列表在编辑器中发生改变时调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PinConnectionListChanged</span><span class="params">(UEdGraphPin* Pin)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 编辑图时，获取给定引脚的悬停提示文本 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetPinHoverText</span><span class="params">(<span class="keyword">const</span> UEdGraphPin&amp; Pin, FString&amp; HoverTextOut)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于改变初始化的新节点; 只在新节点创建时调用一次，在 AutowireNewNode 或 AllocateDefaultPins 调用之前调用</span></span><br><span class="line">	<span class="comment">// 此方法在新节点被重构时不会调用</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostPlacedNewNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 添加节点数据到搜索元数据，重写以收集更多需要用于搜索的数据</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param OutTaggedMetaData		返回此节点的标记元数据数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddSearchMetaDataInfo</span><span class="params">(TArray&lt;struct FSearchTagDataPair&gt;&amp; OutTaggedMetaData)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 为每个直接连接此节点的相邻节点执行一次给定函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ForEachNodeDirectlyConnected</span><span class="params">(TFunctionRef&lt;<span class="keyword">void</span>(UEdGraphNode*)&gt; Func)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>相信以上属性和函数对于用过蓝图的你来说并不难理解。这些虚方法在我们自定义蓝图节点时经常需要用到，建议了解一下 😃</p><h3 id="node-uk2node"><a class="anchor" href="#node-uk2node">#</a> Node | UK2Node</h3><p><code>UK2Node</code> 即是所有蓝图节点的抽象基类。无论是引擎内置的函数 (如: <code>Sequence</code> 等) 亦或是我们自己写的 BlueprintCallable 函数，都会被创建成一个 <code>UK2Node</code> 节点，以便蓝图使用。以下是 <code>UK2Node</code> 的一些常用函数：</p><p></p><figure class="highlight c++"><figcaption><span>UK2Node</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(abstract, MinimalAPI)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UK2Node</span> :</span> <span class="keyword">public</span> UEdGraphNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line">      </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 返回此节点是否依赖外部结构。</span></span><br><span class="line"><span class="comment">	 * 如果 OptionalOutput 不为空，则应填充已知依赖物品(类，结构，函数等)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HasExternalDependencies</span><span class="params">(TArray&lt;class UStruct*&gt;* OptionalOutput = <span class="literal">nullptr</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 在编辑器中，此节点的某个引脚的连接列表发生改变时调用，在引脚清除连线之后*/</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NotifyPinConnectionListChanged</span><span class="params">(UEdGraphPin* Pin)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 在蓝图的结构改变后清空所有需要被重新生成的缓存数据 */</span></span><br><span class="line">	<span class="function">BLUEPRINTGRAPH_API <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ClearCachedBlueprintData</span><span class="params">(UBlueprint* Blueprint)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 执行节点特定的弃用修复，这可能删除此节点并用另一个节点代替它 */</span></span><br><span class="line">	<span class="function">BLUEPRINTGRAPH_API <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ConvertDeprecatedNode</span><span class="params">(UEdGraph* Graph, <span class="keyword">bool</span> bOnlySafeChanges)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 创建节点句柄函子，在编译 UK2Node 时调用 */</span></span><br><span class="line">    <span class="function">BLUEPRINTGRAPH_API <span class="keyword">virtual</span> class FNodeHandlingFunctor* <span class="title">CreateNodeHandler</span><span class="params">(class FKismetCompilerContext&amp; CompilerContext)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用于函数入口或出口节点的引脚</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param	Function	入口或出口节点所用于的，被执行的函数</span></span><br><span class="line"><span class="comment">	 * @param	bForFunctionEntry	真则表示函数入口节点，假则表示出口节点</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return	成功则返回真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">CreatePinsForFunctionEntryExit</span><span class="params">(<span class="keyword">const</span> UFunction* Function, <span class="keyword">bool</span> bForFunctionEntry)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 查询忽略此节点是否安全(如.注释节点或其他可以在不警告的情况下删除的非结构型注释)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return	可安全忽略此节点则返回真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsNodeSafeToIgnore</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在重新构造时重新分配引脚，默认情况下忽略旧的引脚并调用 AllocateDefaultPins()。</span></span><br><span class="line"><span class="comment">	 * 如果你重写此函数以创建更多的引脚，你可能需要调用 RestoreSplitPins 以恢复所有被分裂的引脚(如.向量引脚分离为多个常量)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">BLUEPRINTGRAPH_API <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ReallocatePinsDuringReconstruction</span><span class="params">(TArray&lt;UEdGraphPin*&gt;&amp; OldPins)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 此函数返回任意数量的属性，用于描述此节点的分析事件 */</span></span><br><span class="line">	<span class="function">BLUEPRINTGRAPH_API <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetNodeAttributes</span><span class="params">( TArray&lt;TKeyValuePair&lt;FString, FString&gt;&gt;&amp; OutNodeAttributes )</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 用于代替 GetMenuEntries(). 重写以添加特定的关于子类类型的UBlueprintNodeSpawners</span></span><br><span class="line"><span class="comment">	 * 提供将新节点和游戏模块节点添加到上下文菜单中的扩展方式</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param  ActionListOut	用于填充新生成器的列表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetMenuActions</span><span class="params">(FBlueprintActionDatabaseRegistrar&amp; ActionRegistrar)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写以提供默认分类，连接的特定节点类型在此分类下被列出</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return 本地分类字符串(如果此节点在菜单的根中被列出，则返回空字符串)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FText <span class="title">GetMenuCategory</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> FText::<span class="built_in">GetEmpty</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ........ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>UK2Node</code> 只是 <code>UEdGraphNode</code> 特定于蓝图节点的函数拓展，包括对蓝图数据的编辑，重构引脚等。&lt;a id=&quot;SpawnActor&quot;&gt;&lt;/a&gt;</p><p>这里可以填一下之前挖的坑：<strong>为什么 <code>SpawnActorFromClass</code> 蓝图节点在一些 <code>UObject</code> 蓝图中不能使用？</strong></p><p>因为 <code>SpawnActorFromClass</code> 节点要求使用此节点的蓝图对象的 <code>GetWorld()</code> 函数的返回值不为空指针，原始的 <code>UObject</code> 默认是不放置在关卡中的，所以 <code>GetWorld()</code> 的返回值理应为空。我们只需要将其 <code>GetWorld()</code> 函数设置好即可。办法不唯一，可以调用 <code>Owner</code> (如果是 Actor) 的 <code>GetWorld()</code> 也可以直接从 <code>GEngine</code> 中获取等等。</p><p>限制函数如下：</p><p></p><figure class="highlight c++"><figcaption><span>SpawnActorFromClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// K2Node_SpawnActorFromClass.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UK2Node_SpawnActorFromClass::IsCompatibleWithGraph</span><span class="params">(<span class="keyword">const</span> UEdGraph* TargetGraph)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UBlueprint* Blueprint = FBlueprintEditorUtils::<span class="built_in">FindBlueprintForGraph</span>(TargetGraph);</span><br><span class="line">	<span class="keyword">return</span> Super::<span class="built_in">IsCompatibleWithGraph</span>(TargetGraph) &amp;&amp; (!Blueprint || (FBlueprintEditorUtils::<span class="built_in">FindUserConstructionScript</span>(Blueprint) != TargetGraph &amp;&amp; Blueprint-&gt;GeneratedClass-&gt;<span class="built_in">GetDefaultObject</span>()-&gt;<span class="built_in">ImplementsGetWorld</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UObject::ImplementsGetWorld</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DO_CHECK</span></span><br><span class="line">	<span class="built_in">check</span>(<span class="built_in">IsInGameThread</span>());</span><br><span class="line">	bGetWorldOverridden = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">return</span> bGetWorldOverridden;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>IsCompatibleWithGraph</code> 函数用于判断此节点与传入图是否兼容，如果兼容则显示在蓝图的可选函数列表中。</p><h3 id="schema-uedgraphschema"><a class="anchor" href="#schema-uedgraphschema">#</a> Schema | UEdGraphSchema</h3><p></p><figure class="highlight c++"><figcaption><span>UEdGraphSchema</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EdGraphSchema.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(abstract)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ENGINE_API</span> <span class="title">UEdGraphSchema</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取在图上单击鼠标右键或在图中从引脚处拖动时可以执行的所有操作</span></span><br><span class="line"><span class="comment">	 * @param [in,out]	ContextMenuBuilder	上下文(图，拖动引脚等)和输出菜单构造器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetGraphContextActions</span><span class="params">(FGraphContextMenuBuilder&amp; ContextMenuBuilder)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 定义两个引脚是否可以创建连接。连接合法返回空字符串，否则返回不可连接的原因信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> FPinConnectionResponse <span class="title">CanCreateConnection</span><span class="params">(<span class="keyword">const</span> UEdGraphPin* A, <span class="keyword">const</span> UEdGraphPin* B)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FPinConnectionResponse</span>(CONNECT_RESPONSE_DISALLOW, <span class="built_in">TEXT</span>(<span class="string">&quot;Not implemented by this schema&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 定义两个节点是否可以合并。合并合法返回空字符串，否则返回不可合并的原因信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> FPinConnectionResponse <span class="title">CanMergeNodes</span><span class="params">(<span class="keyword">const</span> UEdGraphNode* A, <span class="keyword">const</span> UEdGraphNode* B)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FPinConnectionResponse</span>(CONNECT_RESPONSE_DISALLOW, <span class="built_in">TEXT</span>(<span class="string">&quot;Not implemented by this schema&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试在两个引脚间创建连接</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">TryCreateConnection</span><span class="params">(UEdGraphPin* A, UEdGraphPin* B)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试在两个引脚间创建自动类型转换节点，成功则返回真，否则返回假。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CreateAutomaticConversionNodeAndConnections</span><span class="params">(UEdGraphPin* A, UEdGraphPin* B)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 将节点分离到为子元素 (vector -&gt; x,y,z) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SplitPin</span><span class="params">(UEdGraphPin* Pin, <span class="keyword">bool</span> bNotify = <span class="literal">true</span>)</span> <span class="keyword">const</span> </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将分离的子节点合并为一个节点(x,y,z -&gt; vector) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RecombinePin</span><span class="params">(UEdGraphPin* Pin)</span> <span class="keyword">const</span> </span>&#123; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用默认节点填充新图</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateDefaultNodesForGraph</span><span class="params">(UEdGraph&amp; Graph)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重构传入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ReconstructNode</span><span class="params">(UEdGraphNode&amp; TargetNode, <span class="keyword">bool</span> bIsBatchRequest=<span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 允许模式在特定资源拖动到特定节点时，生成工具提示信息(图案&amp;信息) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetAssetsPinHoverMessage</span><span class="params">(<span class="keyword">const</span> TArray&lt;struct FAssetData&gt;&amp; Assets, <span class="keyword">const</span> UEdGraphPin* HoverPin, FString&amp; OutTooltipText, <span class="keyword">bool</span>&amp; OutOkIcon)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		OutTooltipText = <span class="built_in">FString</span>();</span><br><span class="line">		OutOkIcon = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 此图是否可以被拷贝 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanDuplicateGraph</span><span class="params">(UEdGraph* InSourceGraph)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将引脚拖动到节点中时触发，某些节点可以生成新引脚，如: 函数入口节点</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UEdGraphPin* <span class="title">DropPinOnNode</span><span class="params">(UEdGraphNode* InTargetNode, <span class="keyword">const</span> FName&amp; InSourcePinName, <span class="keyword">const</span> FEdGraphPinType&amp; InSourcePinType, EEdGraphPinDirection InSourcePinDirection)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 如果模式希望重写添加新节点时蓝图标脏的行为，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">MarkBlueprintDirtyFromNewNode</span><span class="params">(UBlueprint* InBlueprint, UEdGraphNode* InEdGraphNode)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>UEdGraphSchema</code> (编辑器图模式) 定义了开发者在编辑器中进行的相关操作是否可行，可行后将如何处理。在此类的帮助下，开发者可以避免很多不必要的节点可用性分析，是辅助蓝图开发的利器。</p><h3 id="schema-uedgraphschema_k2"><a class="anchor" href="#schema-uedgraphschema_k2">#</a> Schema | UEdGraphSchema_K2</h3><p></p><figure class="highlight c++"><figcaption><span>UEdGraphSchema_K2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EdGraphSchema_K2.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(config=Editor)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BLUEPRINTGRAPH_API</span> <span class="title">UEdGraphSchema_K2</span> :</span> <span class="keyword">public</span> UEdGraphSchema</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 创建新的变量获取节点，并将其添加到父图中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> class UK2Node_VariableGet* <span class="title">SpawnVariableGetNode</span><span class="params">(<span class="keyword">const</span> FVector2D GraphPosition, class UEdGraph* ParentGraph, FName VariableName, UStruct* Source)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 传入节点是否默认使用引用类型 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsAutoCreateRefTerm</span><span class="params">(<span class="keyword">const</span> UEdGraphPin* Pin)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 寻找给定节点及方向的第一个执行引脚(Sequence节点的输出方向有多个执行引脚，返回第一个) */</span></span><br><span class="line">	<span class="function">UEdGraphPin* <span class="title">FindExecutionPin</span><span class="params">(<span class="keyword">const</span> UEdGraphNode&amp; Node, EEdGraphPinDirection PinDirection)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 替换当前图节点引用对象到新对象中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReplaceSelectedNode</span><span class="params">(UEdGraphNode* SourceNode, AActor* TargetActor)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 返回此函数的参数列表，函数在编译器中自动为未连接的引用参数填充终端 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetAutoEmitTermParameters</span><span class="params">(<span class="keyword">const</span> UFunction* Function, TArray&lt;FString&gt;&amp; AutoEmitParameterNames)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 为新函数图填充入口节点和返回节点(如果有) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFunctionGraphTerminators</span><span class="params">(UEdGraph&amp; Graph, UClass* Class)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** 返回传入属性的类型信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> FText <span class="title">TypeToText</span><span class="params">(FProperty* <span class="keyword">const</span> Property)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 设置引脚默认值，但在引脚构造时不自动生成默认值，与 TrySetDefaultValue 类似，但不进行验证和回调 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetPinDefaultValueAtConstruction</span><span class="params">(UEdGraphPin* Pin, <span class="keyword">const</span> FString&amp; DefaultValueString)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 返回给定函数中传入属性的默认值 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">FindFunctionParameterDefaultValue</span><span class="params">(<span class="keyword">const</span> UFunction* Function, <span class="keyword">const</span> FProperty* Param, FString&amp; OutString)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>与 <code>UEdGraphSchema</code> 类似，进一步确定蓝图的编辑规范，如：引脚和默认值的使用规范。</p><h3 id="sgrapheditor"><a class="anchor" href="#sgrapheditor">#</a> SGraphEditor</h3><p>图编辑器 Slate 是图编辑器众多 Widgets 的包装器，实现了编辑器视图的相关操作 (如：视图跳转，调整聚焦等)，且可以优雅地处理图编辑模组 (GraphEditorModule) 的卸载</p><p></p><figure class="highlight c++"><figcaption><span>SGraphEditor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGraphEditor</span> :</span> <span class="keyword">public</span> SCompoundWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 将两个图编辑器锁定到一起 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LockToGraphEditor</span><span class="params">(TWeakPtr&lt;SGraphEditor&gt; Other)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 解锁两个编辑器 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UnlockFromGraphEditor</span><span class="params">(TWeakPtr&lt;SGraphEditor&gt; Other)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将视图(屏幕显示)移动到特定节点 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">JumpToNode</span><span class="params">( <span class="keyword">const</span> class UEdGraphNode* JumpToMe, <span class="keyword">bool</span> bRequestRename = <span class="literal">false</span>, <span class="keyword">bool</span> bSelectNode = <span class="literal">true</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将视图(屏幕显示)移动到特定引脚 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">JumpToPin</span><span class="params">( <span class="keyword">const</span> class UEdGraphPin* JumpToMe )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 设置引脚可见模式 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetPinVisibility</span><span class="params">(EPinVisibility InVisibility)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 清空选择项 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ClearSelectionSet</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 聚焦到合适的可以包含所有节点或包含所有选定节点的大小</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ZoomToFit</span><span class="params">(<span class="keyword">bool</span> bOnlySelection)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取所有选定节点的边框，未选定则返回假 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">GetBoundsForSelectedNodes</span><span class="params">(class FSlateRect&amp; Rect, <span class="keyword">float</span> Padding)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StraightenConnections</span><span class="params">(UEdGraphPin* SourcePin, UEdGraphPin* PinToAlign = <span class="literal">nullptr</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RefreshNode</span><span class="params">(UEdGraphNode&amp; Node)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行以使此 widget 知道 GraphEditor 模组被重载</span></span><br><span class="line">	<span class="function">UNREALED_API <span class="keyword">void</span> <span class="title">OnModuleReloaded</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行以使此 widget 知道 GraphEditor 模组被卸载</span></span><br><span class="line">	<span class="function">UNREALED_API <span class="keyword">void</span> <span class="title">OnModuleUnloading</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 在图被改变时调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NotifyGraphChanged</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 正在编辑的图 */</span></span><br><span class="line">	UEdGraph* EdGraphObj;</span><br><span class="line"></span><br><span class="line">	TWeakPtr&lt;FAssetEditorToolkit&gt; AssetEditorToolkit;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** GraphEditor的实际执行体 */</span></span><br><span class="line">	TSharedPtr&lt;SGraphEditor&gt; Implementation;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 活跃的 GraphEditor 的包装器，在模组卸载时通知他们进行优雅的处理 */</span></span><br><span class="line">	UNREALED_API <span class="keyword">static</span> TArray&lt; TWeakPtr&lt;SGraphEditor&gt; &gt; AllInstances;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当图模组重加载时触发此回调</span></span><br><span class="line">	FEdGraphEvent OnGraphModuleReloadedCallback;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 图编辑模组需要访问所有实例</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FGraphEditorModule</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h3 id="蓝图编辑器工作机制"><a class="anchor" href="#蓝图编辑器工作机制">#</a> 蓝图编辑器工作机制</h3><ol><li>打开蓝图，资源编辑子系统 ( <code>UAssetEditorSubsystem</code> ) 将调用 <code>OpenEditorForAsset</code> ，根据不同的资源类型 (蓝图类型)，创建对应的编辑器并加载正在打开的资源 (蓝图)，</li><li>初始化编辑器时将创建对应的 <code>Slate</code> ，菜单栏等，接着将蓝图信息 (节点，引脚，连线，属性默认值等) 加载到 <code>Slate</code> 中，</li><li>开发者在编辑器中的操作将被引擎解释为对 <code>UBlueprint</code> 数据的操作，但操作受到 <code>UEdGraphSchema_K2</code> 的限制，</li><li>编译蓝图，生成对应 <code>BPGC</code> ， <code>CDO</code> ，字节码等，</li><li>保存蓝图，将蓝图序列化到磁盘中。</li></ol><hr><p>结语：本篇主要围绕蓝图创建和编译的实现机制展开，蓝图保存主要是序列化的过程，想深入研究的同学可以参考我的另一篇博客。最后是蓝图编辑器的相关类，及其工作原理的介绍。掌握 <code>UGraph</code> ， <code>UGraphNode</code> ， <code>UK2_Node</code> , <code>UEdGraphSchema_K2</code> 这些类是实现自定义蓝图节点的前提。另外，编辑器界面都是由 Slate 搭建起来的，本篇并没有对蓝图编辑器的搭建进行展开，因为在其他博客里面已经介绍过类似的编辑器了，想研究的同学请自行翻看。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-02-11 18:21:03" itemprop="dateModified" datetime="2022-02-11T18:21:03+08:00">2022-02-11</time> </span><span id="2022/01/08/UE4/UE4CPP/Unreal 蓝图底层实现机制/" class="item leancloud_visitors" data-flag-title="Unreal 蓝图底层实现机制" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2022/01/08/UE4/UE4CPP/Unreal%20%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" title="Unreal 蓝图底层实现机制">https://kotori_suki.github.io/2022/01/08/UE4/UE4CPP/Unreal 蓝图底层实现机制/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclflwv2aj20zk0m84qp.jpg" title="Unreal MovementComponent 源码解析"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal MovementComponent 源码解析</h3></a></div><div class="item right"><a href="/2022/02/12/UE4/UE4CPP/Unreal%20%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicit31ffoj20zk0m8naf.jpg" title="Unreal MotionMatching"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal MotionMatching</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unreal-%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">Unreal 蓝图底层实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E6%A6%82%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">蓝图底层实现机制概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%93%9D%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">创建蓝图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%93%9D%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">编译蓝图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BC%96%E8%AF%91%E8%93%9D%E5%9B%BE"><span class="toc-number">1.3.1.</span> <span class="toc-text">重编译蓝图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">编译函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8D%95%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">编译单个函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">函数编译后处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E4%BD%93%E5%92%8C%E6%A1%86%E6%9E%B6%E8%93%9D%E5%9B%BE%E7%B1%BB%E7%9A%84%E6%A0%B9%E5%AD%98%E5%87%BD%E6%95%B0%E4%BD%93"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">填充函数体和框架蓝图类的根存函数体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%9D%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">蓝图编辑器的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node-uedgraphnode"><span class="toc-number">1.4.1.</span> <span class="toc-text">Node | UEdGraphNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-uk2node"><span class="toc-number">1.4.2.</span> <span class="toc-text">Node | UK2Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schema-uedgraphschema"><span class="toc-number">1.4.3.</span> <span class="toc-text">Schema | UEdGraphSchema</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schema-uedgraphschema_k2"><span class="toc-number">1.4.4.</span> <span class="toc-text">Schema | UEdGraphSchema_K2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sgrapheditor"><span class="toc-number">1.4.5.</span> <span class="toc-text">SGraphEditor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%93%9D%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">蓝图编辑器工作机制</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li><li><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" rel="bookmark" title="Unreal Slate">Unreal Slate</a></li><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li><li><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></li><li><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="bookmark" title="Custom Item Module">Custom Item Module</a></li><li><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></li><li><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></li><li class="active"><a href="/2022/01/08/UE4/UE4CPP/Unreal%20%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" rel="bookmark" title="Unreal 蓝图底层实现机制">Unreal 蓝图底层实现机制</a></li><li><a href="/2022/02/12/UE4/UE4CPP/Unreal%20%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/" rel="bookmark" title="Unreal MotionMatching">Unreal MotionMatching</a></li><li><a href="/2022/03/15/UE4/UE4CPP/Unreal%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E4%B9%8B%E4%B8%80/" rel="bookmark" title="Unreal 常用接口源码分析 之一">Unreal 常用接口源码分析 之一</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">57</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/02/12/UE4/UE4CPP/Unreal%20%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/2021/08/16/ComputerBase/Algorithm/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/Gameplay/" title="分类于 Gameplay">Gameplay</a></div><span><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" title="Gameplay —— 总览 &amp; UEngine &amp; UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/23/CPPBase/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/" title="迭代器失效问题">迭代器失效问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 结构型模式">结构型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/Bridge/" title="桥接模式">桥接模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 结构型模式">结构型模式</a></div><span><a href="/2021/08/18/CPPBase/DesignPattern/Adapter/" title="适配器模式">适配器模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/16/CPPBase/map%E4%B8%8Eunordered_map%E7%9A%84%E5%8C%BA%E5%88%AB/" title="map与unordered_map">map与unordered_map</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" title="Unreal Slate">Unreal Slate</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 结构型模式">结构型模式</a></div><span><a href="/2021/08/18/CPPBase/DesignPattern/Proxy/" title="代理模式">代理模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/01/08/UE4/UE4CPP/Unreal 蓝图底层实现机制/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>