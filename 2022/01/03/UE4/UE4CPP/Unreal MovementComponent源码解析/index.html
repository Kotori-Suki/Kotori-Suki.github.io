<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><title>Unreal MovementComponent 源码解析 - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unreal MovementComponent 源码解析</h1><div class="meta"><span class="item" title="创建时间：2022-01-03 14:05:26"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-01-03T14:05:26+08:00">2022-01-03</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeyonbf9j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciundwu5j20zk0m8n9e.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitzannuj20zk0m8b29.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="unreal-movementcomponent-源码解析"><a class="anchor" href="#unreal-movementcomponent-源码解析">#</a> Unreal MovementComponent 源码解析</h1><p>简介：本篇将从玩家的移动输入函数 <code>AddMovementInput()</code> 开始，探究移动组件从玩家输入到客户端本地预测，再到服务器模拟并矫正客户端移动，最后将正确的移动同步到模拟代理客户端中进行模拟。本地预测和服务器模拟移动时，自然少不了要计算不同状态下 (如：行走，飞行等) 各种因素 (如：根运动，摩擦力，玩家输入，路径追踪等) 对速度的影响，以及每帧的位移增量与旋转值的变化。模拟代理客户端的移动模拟因为其数据本就是服务器同步过来的计算好的数据，所以只需要直接平滑处理其移动即可。</p><h2 id="从-addmovementinput-出发"><a class="anchor" href="#从-addmovementinput-出发">#</a> 从 <code>AddMovementInput</code> 出发</h2><p>接触过 UE4 开发的小伙伴应该对这个函数都不陌生，其作用即 使指定角色沿着给定向量的方向，移动一定距离。此函数是 <code>Pawn</code> 类中的函数，但 <code>Pawn</code> 并不会自动应用移动，因为 <code>Pawn</code> 实际上是没有移动组件的，其子类如 <code>Character</code> 和 <code>DefaultPawn</code> 则会自动处理移动输入。以下是 <code>AddMovementInput</code> 的源代码及解析：</p><p></p><figure class="highlight c++"><figcaption><span>AddMovementInput</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pawn.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">APawn::AddMovementInput</span><span class="params">(FVector WorldDirection, <span class="keyword">float</span> ScaleValue, <span class="keyword">bool</span> bForce <span class="comment">/*=false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UPawnMovementComponent* MovementComponent = <span class="built_in">GetMovementComponent</span>();</span><br><span class="line">	<span class="keyword">if</span> (MovementComponent)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 将第一个参数作为世界加速度加到角色的 ControllerInputVector(控制器输入向量) 中</span></span><br><span class="line">		MovementComponent-&gt;<span class="built_in">AddInputVector</span>(WorldDirection * ScaleValue, bForce);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Internal_AddMovementInput</span>(WorldDirection * ScaleValue, bForce);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此函数并不处理角色移动，只将传入的单位向量与缩放相乘得到的新的移动输入添加到 <code>APawn.ControllerInputVector</code> 中。此变量为挂起变量，等待下一帧组件更新时使用。接下来，咱看看这个挂起变量是怎么被使用的。</p><h2 id="tickcomponent-acharactermovementcomponent"><a class="anchor" href="#tickcomponent-acharactermovementcomponent">#</a> TickComponent (ACharacterMovementComponent)</h2><p><code>ACharacterMovementComponent</code> 继承于 <code>APawnMovementComponent</code> ，负责处理角色移动的相关逻辑。而 <code>TickComponent</code> 则是处理角色每帧的移动预测，移动矫正，力的应用，导航系统的更新等操作的主要函数。</p><p></p><figure class="highlight c++"><figcaption><span>ACharacterMovementComponent.TickComponent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::TickComponent</span><span class="params">(<span class="keyword">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 消费输入向量，将其重置为 0</span></span><br><span class="line">	<span class="keyword">const</span> FVector InputVector = <span class="built_in">ConsumeInputVector</span>();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>() || <span class="built_in">ShouldSkipUpdate</span>(DeltaTime))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类 Tick 可能销毁/使 CharacterOwner 或 UpdatedComponent 失效，所以我们需要再次确认</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">HasValidData</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看我们是否已经掉出世界</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bIsSimulatingPhysics = UpdatedComponent-&gt;<span class="built_in">IsSimulatingPhysics</span>();</span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_Authority &amp;&amp; (!bCheatFlying || bIsSimulatingPhysics) &amp;&amp; !CharacterOwner-&gt;<span class="built_in">CheckStillInWorld</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果启用模拟物理，则不更新(如: 布娃娃)</span></span><br><span class="line">	<span class="keyword">if</span> (bIsSimulatingPhysics)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 更新相机，确保客户端即使因物理移动远离了模拟开始点，也能得到更新</span></span><br><span class="line">		<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_AutonomousProxy &amp;&amp; <span class="built_in">IsNetMode</span>(NM_Client))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">MarkForClientCameraUpdate</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将挂起脉冲，挂起力，挂起发射速度重置为 0</span></span><br><span class="line">		<span class="built_in">ClearAccumulatedForces</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少回避速度锁定的剩余时间(回避速度指避免组件间产生碰撞而添加的速度)</span></span><br><span class="line">	AvoidanceLockTimer -= DeltaTime;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() &gt; ROLE_SimulatedProxy)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementNonSimulated);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 客户端接收来自服务器的移动矫正(如果有)</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bIsClient = (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_AutonomousProxy &amp;&amp; <span class="built_in">IsNetMode</span>(NM_Client));</span><br><span class="line">		<span class="keyword">if</span> (bIsClient)</span><br><span class="line">		&#123;</span><br><span class="line">			FNetworkPredictionData_Client_Character* ClientData = <span class="built_in">GetPredictionData_Client_Character</span>();</span><br><span class="line">			<span class="keyword">if</span> (ClientData &amp;&amp; ClientData-&gt;bUpdatePosition)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 此函数将根据 ClientPredictionData.bUpdatePosition(客户端预测数据的位置是否被更新)，决定是否在代理客户端再现服务器的移动矫正</span></span><br><span class="line">				<span class="built_in">ClientUpdatePositionAfterServerUpdate</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 允许根运动(RootMotion)移动没有控制器的角色</span></span><br><span class="line">		<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">IsLocallyControlled</span>() || (!CharacterOwner-&gt;Controller &amp;&amp; bRunPhysicsWithNoController) || (!CharacterOwner-&gt;Controller &amp;&amp; CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 处理本地移动预测，其中包括加速度的应用，物理模拟中增量时间的更新，新旧动作的合并，</span></span><br><span class="line">            <span class="comment">// 本地移动的执行，最后将新移动添加到缓存列表中，如果保存的移动可提交到服务器，</span></span><br><span class="line">            <span class="comment">// 则将类似的移动合并后提交以减少带宽(调用 CallServerMove 提交)。</span></span><br><span class="line">            <span class="comment">// 缓存列表中的移动在被服务器确认后清除，未确认的移动则根据服务器的移动矫正进行确认。</span></span><br><span class="line">			<span class="built_in">ControlledCharacterMove</span>(InputVector, DeltaTime);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetRemoteRole</span>() == ROLE_AutonomousProxy)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 服务器 Tick，在客户端的网络更新期间，如果基于另一个对象，则需要更新位置。</span></span><br><span class="line">            <span class="comment">// 否则，对象将在中间帧移动，我们不会跟随它。</span></span><br><span class="line">			<span class="built_in">MaybeUpdateBasedMovement</span>(DeltaTime);</span><br><span class="line">			<span class="built_in">MaybeSaveBaseLocation</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 监听服务器中对于远程客户端的本地视图的平滑处理。我们可能以不同于自身的 tick 速率来接收更新</span></span><br><span class="line">			<span class="keyword">if</span> (CharacterMovementCVars::NetEnableListenServerSmoothing &amp;&amp; !bNetworkSmoothingComplete &amp;&amp; <span class="built_in">IsNetMode</span>(NM_ListenServer))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">SmoothClientPosition</span>(DeltaTime);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_SimulatedProxy)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (bShrinkProxyCapsule)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">AdjustProxyCapsuleSize</span>();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 模拟代理移动组件的 Tick 更新函数</span></span><br><span class="line">		<span class="built_in">SimulatedTick</span>(DeltaTime);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bUseRVOAvoidance)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 更新 RVO 回避管理器的数据(Reciprocal Velocity Obstacles，避免自身组件的碰撞)</span></span><br><span class="line">		<span class="built_in">UpdateDefaultAvoidance</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bEnablePhysicsInteraction)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharPhysicsInteraction);</span><br><span class="line">		<span class="built_in">ApplyDownwardForce</span>(DeltaTime); <span class="comment">// 应用向下的力(如:重力)</span></span><br><span class="line">		<span class="built_in">ApplyRepulsionForce</span>(DeltaTime); <span class="comment">// 应用互斥的力(如:碰撞)</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>TickComponent</code> 函数看似简单，实则别有洞天。其主要处理移动在网络游戏中的同步机制 (大量 RPC)，移动在服务器中的计算，移动在代理客户端中的预测与矫正，移动在模拟客户端的平滑处理等。以下是 <code>TickComponent</code> 在客户端与服务器中交互的流程图：</p><p><img data-src="CharacterMovementComponent.TickComponent.png" alt="CharacterMovementComponent.TickComponent"></p><p>以下是对上图一些细节上的补充：</p><ul><li><p>服务器实际上不会定期 Tick 移动来与游戏的 Tick 循环同步，而是等待代理客户端调用 <code>ServerMove</code> 后，才计算本次移动数据是否正确，并修改服务器预测数据。最后在 <code>UNetDriver::ServerReplicateActors()</code> 中通过判断服务器预测数据的修改结果来决定不同的客户端行为。</p></li><li><p>如果服务器预测数据的 <code>PendingAdjustment.bAckGoodMove</code> 标记为 <code>true</code> ，则将调用 <code>ClientAckGoodMove</code> RPC 来确认移动，告知所属客户端机器上的自主代理该移动为有效。这将从所属客户端的 <code>SavedMoves</code> 缓冲中移除原始移动，并将其记录为 <code>LastAckedMove</code> ，用于编译未来的预测数据。</p></li><li><p>如果为 <code>false</code> ，则将调用客户端调整函数 ( <code>ServerSendMoveResponse</code> )，将最终矫正发送到客户端。而客户端将在移动组件下一帧 Tick 时矫正自身移动。</p></li><li><p>至于模拟代理的 Tick 移动则会在 <code>SimulatedTick</code> 中进行，此函数将根据服务器提供的最新移动复制数据继续移动。执行标准移动物理效果时，调用 <code>SimulateMove</code> 函数，然后使用 <code>SmoothClientPosition</code> 执行最终的验证和网络平滑。</p></li></ul><p>现在我们已经对多人游戏中的角色移动网络复制有了大致上的了解。接下来我们将分析执行移动预测和矫正移动预测的具体实现方法，但在此之前我们需要先了解以下什么是 <strong>根运动 (RootMotion)</strong> 移动</p><h3 id="动画根运动-rootmotion"><a class="anchor" href="#动画根运动-rootmotion">#</a> 动画根运动 RootMotion</h3><p>了解过 ue4 中角色的移动和动画之间的配合的同学应该都知道 动画和移动的实现实际上是分开的。也就是说，角色的动画和移动是完全可以脱离对方而单独执行的，即 将两大系统互相解耦 (但解耦归解耦，动画的执行还是基于移动的，否则动画就会显得很突兀)。</p><p>试想一下：如果有一个非常复杂的移动 (通常是释放技能的运动)，如只狼中 &quot;心中的一心&quot;(Boss) 的技能，其动作大致可描述为：加速飞起后减速停在空中挥舞剑气后向下加速沿曲线劈砍 (如下图)。像这种复杂而精细的技能在动作游戏中并不少见，通过纯计算处理这些移动显然是不合适的 (首先确定移动函数的成本过高，其次质量可能也不尽人意，因为函数可能并不能完全模拟设计师想要的技能轨迹)。</p><p><img data-src="AbilityMove.png" alt="AbilityMove"></p><p>为了应对这种复杂情况，unreal 内置了 &quot;RootMotion&quot; 的解决方案。即 动画的根运动可以影响胶囊体移动的速度，从而改变胶囊体的运动轨迹。实现方法即 在做动画时，不同的动画帧需要确定此时刻动作的根所在的位置，而这个根位置的移动将以 &quot;RootMotion&quot; 的方式被计算成速度并应用到胶囊体的移动中。其实现类似于在动画中添加了一条确定位移的曲线，以避免我们对复杂位移的速度变化的计算。</p><p>所以一般比较简单的动作都无需使用 &quot;RootMotion&quot;，通常是固定动作的根 而通过移动组件根据移动状态的不同采取不同的计算角色移动的策略。</p><h3 id="客户端移动预测"><a class="anchor" href="#客户端移动预测">#</a> 客户端移动预测</h3><h4 id="controlledcharactermove"><a class="anchor" href="#controlledcharactermove">#</a> ControlledCharacterMove</h4><p>此函数主要计算玩家输入对角色加速度的影响，并用算出来的加速度作为参数调用 <code>ReplicateMoveToServer</code> 函数，以执行本地移动预测，提交移动数据到服务器等操作。</p><p></p><figure class="highlight c++"><figcaption><span>ControlledCharacterMove</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::ControlledCharacterMove</span><span class="params">(<span class="keyword">const</span> FVector&amp; InputVector, <span class="keyword">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharUpdateAcceleration);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调整输入加速度前，我们需要检查跳跃状态，以最小化延迟，并确保加速度适用与潜在的下落状态</span></span><br><span class="line">		CharacterOwner-&gt;<span class="built_in">CheckJumpInput</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将输入应用到加速度中</span></span><br><span class="line">		Acceleration = <span class="built_in">ScaleInputAcceleration</span>(<span class="built_in">ConstrainInputAcceleration</span>(InputVector));</span><br><span class="line">		AnalogInputModifier = <span class="built_in">ComputeAnalogInputModifier</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_Authority)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 主要用于监听服务器，独立服务器不 Tick 移动组件</span></span><br><span class="line">		<span class="built_in">PerformMovement</span>(DeltaSeconds);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_AutonomousProxy &amp;&amp; <span class="built_in">IsNetMode</span>(NM_Client))</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 执行移动，并将移动缓存，等待提交间隔到达最小差量时间后，将移动数据提交给服务器</span></span><br><span class="line">		<span class="built_in">ReplicateMoveToServer</span>(DeltaSeconds, Acceleration);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="replicatemovetoserver"><a class="anchor" href="#replicatemovetoserver">#</a> ReplicateMoveToServer</h4><p>此函数将尝试合并新移动，并调用 <code>PerformMovement</code> 执行本地移动。如果到达差量时间，则调用 <code>CallServerMove</code> 将移动提交到服务器</p><p></p><figure class="highlight c++"><figcaption><span>ReplicateMoveToServer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::ReplicateMoveToServer</span><span class="params">(<span class="keyword">float</span> DeltaTime, <span class="keyword">const</span> FVector&amp; NewAcceleration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ....... 省略有效性检查</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新物理模拟的增量时间</span></span><br><span class="line">	DeltaTime = ClientData-&gt;<span class="built_in">UpdateTimeStampAndDeltaTime</span>(DeltaTime, *CharacterOwner, *<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 寻找最旧的未被服务器确认的重要移动。</span></span><br><span class="line">    <span class="comment">// 不包含最后的移动，因为其可能与新移动合并。</span></span><br><span class="line">	FSavedMovePtr OldMove = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>( ClientData-&gt;LastAckedMove.<span class="built_in">IsValid</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> int32 NumSavedMoves = ClientData-&gt;SavedMoves.<span class="built_in">Num</span>();</span><br><span class="line">		<span class="keyword">for</span> (int32 i=<span class="number">0</span>; i &lt; NumSavedMoves<span class="number">-1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> FSavedMovePtr&amp; CurrentMove = ClientData-&gt;SavedMoves[i];</span><br><span class="line">			<span class="keyword">if</span> (CurrentMove-&gt;<span class="built_in">IsImportantMove</span>(ClientData-&gt;LastAckedMove))</span><br><span class="line">			&#123;</span><br><span class="line">				OldMove = CurrentMove;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 SaveMove 对象以保存移动</span></span><br><span class="line">	FSavedMovePtr NewMovePtr = ClientData-&gt;<span class="built_in">CreateSavedMove</span>();</span><br><span class="line">	FSavedMove_Character* <span class="keyword">const</span> NewMove = NewMovePtr.<span class="built_in">Get</span>();</span><br><span class="line">	<span class="keyword">if</span> (NewMove == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NewMove-&gt;<span class="built_in">SetMoveFor</span>(CharacterOwner, DeltaTime, NewAcceleration, *ClientData);</span><br><span class="line">	<span class="keyword">const</span> UWorld* MyWorld = <span class="built_in">GetWorld</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 观察两个移动(PendingMove 和 NewMove)是否可以合并</span></span><br><span class="line">	<span class="comment">// 不要合并两个时间戳不同的移动</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">const</span> FSavedMove_Character* PendingMove = ClientData-&gt;PendingMove.<span class="built_in">Get</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (PendingMove-&gt;<span class="built_in">CanCombineWith</span>(NewMovePtr, CharacterOwner, ClientData-&gt;MaxMoveDeltaTime * CharacterOwner-&gt;<span class="built_in">GetActorTimeDilation</span>(*MyWorld)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementCombineNetMove);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 仅当合并后不会与新事物发生碰撞的情况下，才能合并到初始位置</span></span><br><span class="line">			<span class="keyword">const</span> FVector OldStartLocation = PendingMove-&gt;<span class="built_in">GetRevertedLocation</span>();</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bAttachedToObject = (NewMovePtr-&gt;StartAttachParent != <span class="literal">nullptr</span>);</span><br><span class="line">			<span class="keyword">if</span> (bAttachedToObject || !<span class="built_in">OverlapTest</span>(OldStartLocation, PendingMove-&gt;StartRotation.<span class="built_in">Quaternion</span>(), UpdatedComponent-&gt;<span class="built_in">GetCollisionObjectType</span>(), <span class="built_in">GetPawnCapsuleCollisionShape</span>(SHRINK_None), CharacterOwner))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 避免在传送回来期间将网格骨骼更新为物理，因为 PerformMovement 将马上更新(非模拟物理是移动组件操控移动的必要条件)</span></span><br><span class="line">				<span class="comment">// 注意: 这必须在 FScopedMovementUpdate 之前，因为这是移动角色和网格体的实际范围</span></span><br><span class="line">				<span class="function">FScopedMeshBoneUpdateOverride <span class="title">ScopedNoMeshBoneUpdate</span><span class="params">(CharacterOwner-&gt;GetMesh(), EKinematicBonesUpdateToPhysics::SkipAllBones)</span></span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 累积多个变化更新直至超出范围</span></span><br><span class="line">				<span class="function">FScopedMovementUpdate <span class="title">ScopedMovementUpdate</span><span class="params">(UpdatedComponent, EScopedUpdate::DeferredUpdates)</span></span>;</span><br><span class="line">				<span class="built_in">UE_LOG</span>(LogNetPlayerMovement, VeryVerbose, <span class="built_in">TEXT</span>(<span class="string">&quot;CombineMove: add delta %f + %f and revert from %f %f to %f %f&quot;</span>), DeltaTime, PendingMove-&gt;DeltaTime, UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>().X, UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>().Y, OldStartLocation.X, OldStartLocation.Y);</span><br><span class="line"></span><br><span class="line">				NewMove-&gt;<span class="built_in">CombineWith</span>(PendingMove, CharacterOwner, PC, OldStartLocation);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (PC)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 我们将位置恢复到挂起移动开始时的位置(如上所述)，</span></span><br><span class="line">                    <span class="comment">// 但是一些代码希望在角色移动发生之前正确设置旋转，所以在此尝试设置旋转</span></span><br><span class="line">					CharacterOwner-&gt;<span class="built_in">FaceRotation</span>(PC-&gt;<span class="built_in">GetControlRotation</span>(), NewMove-&gt;DeltaTime);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">SaveBaseLocation</span>();</span><br><span class="line">				NewMove-&gt;<span class="built_in">SetInitialPosition</span>(CharacterOwner);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 从移动列表中移除挂起移动。这将是列表中的最后一个移动</span></span><br><span class="line">				<span class="keyword">if</span> (ClientData-&gt;SavedMoves.<span class="built_in">Num</span>() &gt; <span class="number">0</span> &amp;&amp; ClientData-&gt;SavedMoves.<span class="built_in">Last</span>() == ClientData-&gt;PendingMove)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">bool</span> bAllowShrinking = <span class="literal">false</span>;</span><br><span class="line">					ClientData-&gt;SavedMoves.<span class="built_in">Pop</span>(bAllowShrinking);</span><br><span class="line">				&#125;</span><br><span class="line">				ClientData-&gt;<span class="built_in">FreeMove</span>(ClientData-&gt;PendingMove);</span><br><span class="line">				ClientData-&gt;PendingMove = <span class="literal">nullptr</span>;</span><br><span class="line">				PendingMove = <span class="literal">nullptr</span>; <span class="comment">// 避免挂起引用。已在上面被删除</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">UE_LOG</span>(LogNetPlayerMovement, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;Not combining move [would collide at start location]&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UE_LOG</span>(LogNetPlayerMovement, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;Not combining move [not allowed by CanCombineWith()]&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加速度应与我们发送给服务器的匹配，并添加服务器强制执行的其他限制</span></span><br><span class="line">	Acceleration = NewMove-&gt;Acceleration.<span class="built_in">GetClampedToMaxSize</span>(<span class="built_in">GetMaxAcceleration</span>());</span><br><span class="line">	AnalogInputModifier = <span class="built_in">ComputeAnalogInputModifier</span>(); <span class="comment">// 加速度可能已改变，重新计算加速度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行本地移动</span></span><br><span class="line">	CharacterOwner-&gt;ClientRootMotionParams.<span class="built_in">Clear</span>();</span><br><span class="line">	CharacterOwner-&gt;SavedRootMotion.<span class="built_in">Clear</span>();</span><br><span class="line">	<span class="built_in">PerformMovement</span>(NewMove-&gt;DeltaTime);	<span class="comment">// 正在执行组件移动逻辑的函数</span></span><br><span class="line"></span><br><span class="line">	NewMove-&gt;<span class="built_in">PostUpdate</span>(CharacterOwner, FSavedMove_Character::PostUpdate_Record);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加新移动到移动列表中</span></span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">IsReplicatingMovement</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">check</span>(NewMove == NewMovePtr.<span class="built_in">Get</span>());</span><br><span class="line">		ClientData-&gt;SavedMoves.<span class="built_in">Push</span>(NewMovePtr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bCanDelayMove = (CharacterMovementCVars::NetEnableMoveCombining != <span class="number">0</span>) &amp;&amp; <span class="built_in">CanDelaySendingMove</span>(NewMovePtr);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (bCanDelayMove &amp;&amp; ClientData-&gt;PendingMove.<span class="built_in">IsValid</span>() == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 决定是否延迟提交移动到服务器</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">float</span> NetMoveDelta = FMath::<span class="built_in">Clamp</span>(<span class="built_in">GetClientNetSendDeltaTime</span>(PC, ClientData, NewMovePtr), <span class="number">1.f</span>/<span class="number">120.f</span>, <span class="number">1.f</span>/<span class="number">5.f</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((MyWorld-&gt;TimeSeconds - ClientData-&gt;ClientUpdateTime) * MyWorld-&gt;<span class="built_in">GetWorldSettings</span>()-&gt;<span class="built_in">GetEffectiveTimeDilation</span>() &lt; NetMoveDelta)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 延迟提交移动</span></span><br><span class="line">				ClientData-&gt;PendingMove = NewMovePtr;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ClientData-&gt;ClientUpdateTime = MyWorld-&gt;TimeSeconds;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ..... 省略日志输出</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> bSendServerMove = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果此角色开启移动复制，则提交移动到服务器</span></span><br><span class="line">		<span class="keyword">if</span> (bSendServerMove)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementCallServerMove);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">ShouldUsePackedMovementRPCs</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">CallServerMovePacked</span>(NewMove, ClientData-&gt;PendingMove.<span class="built_in">Get</span>(), OldMove.<span class="built_in">Get</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">CallServerMove</span>(NewMove, OldMove.<span class="built_in">Get</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ClientData-&gt;PendingMove = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="performmovement"><a class="anchor" href="#performmovement">#</a> PerformMovement</h4><p>此函数客户端和服务器都会调用，客户端在 <code>ReplicateMoveToServer</code> 中调用，而服务器则在 <code>MoveAutonomous</code> 中调用。在客户端中，此函数需要计算因为力的作用与根运动而改变的速度，并根据计算后的速度与运动状态改变其位置，紧接着更新其旋转值，调用移动更新代理，最后缓存新的位置和速度。服务器在此之上，还需要判断本次移动与移动前的区别是否大到需要重新进行网络同步，并判断是否需要更新服务器时间戳。</p><p></p><figure class="highlight c++"><figcaption><span>PerformMovement</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::PerformMovement</span><span class="params">(<span class="keyword">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementPerformMovement);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> UWorld* MyWorld = <span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>() || MyWorld == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果我们不能移动或已开启移动组件的物理模拟则不移动</span></span><br><span class="line">	<span class="keyword">if</span> (MovementMode == MOVE_None || UpdatedComponent-&gt;Mobility != EComponentMobility::Movable || UpdatedComponent-&gt;<span class="built_in">IsSimulatingPhysics</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!CharacterOwner-&gt;bClientUpdating &amp;&amp; !CharacterOwner-&gt;bServerMoveIgnoreRootMotion)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 消费根运动</span></span><br><span class="line">			<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>() &amp;&amp; CharacterOwner-&gt;<span class="built_in">GetMesh</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">TickCharacterPose</span>(DeltaSeconds);</span><br><span class="line">				RootMotionParams.<span class="built_in">Clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (CurrentRootMotion.<span class="built_in">HasActiveRootMotionSources</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				CurrentRootMotion.<span class="built_in">Clear</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清除挂起的物理力(开启物理模拟后，移动组件将不起作用)</span></span><br><span class="line">		<span class="built_in">ClearAccumulatedForces</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果上次更新我们已移动到 CharacterMovement 之外，则强制检测(可站立的)有效地板</span></span><br><span class="line">	bForceNextFloorCheck |= (<span class="built_in">IsMovingOnGround</span>() &amp;&amp; UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>() != LastUpdateLocation);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用自上次更新以来对角色速度所做的任何外部更改 更新缓存的 LastPreAdditiveVelocity</span></span><br><span class="line">	<span class="keyword">if</span>( CurrentRootMotion.<span class="built_in">HasAdditiveVelocity</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> FVector Adjustment = (Velocity - LastUpdateVelocity);</span><br><span class="line">		CurrentRootMotion.LastPreAdditiveVelocity += Adjustment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FVector OldVelocity;</span><br><span class="line">	FVector OldLocation;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动范围更新可以提高多移动组件调用的性能 (FScopedMovementUpdate创建移动范围，移动的传播将被延迟到移动到达此范围之外或移动被提交)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">FScopedMovementUpdate <span class="title">ScopedMovementUpdate</span><span class="params">(UpdatedComponent, bEnableScopedMovementUpdates ? EScopedUpdate::DeferredUpdates : EScopedUpdate::ImmediateUpdates)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">MaybeUpdateBasedMovement</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 清空无效根运动源，包括自然结束的根运动源</span></span><br><span class="line">		<span class="comment">// 他们可能想对速度或重载进行 clamp，所以我们希望这发生在 ApplyAccumulatedForces 和 HandlePendingLaunch 之前，以避免使其失效 </span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bHasRootMotionSources = <span class="built_in">HasRootMotionSources</span>();</span><br><span class="line">		<span class="keyword">if</span> (bHasRootMotionSources &amp;&amp; !CharacterOwner-&gt;bClientUpdating &amp;&amp; !CharacterOwner-&gt;bServerMoveIgnoreRootMotion)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementRootMotionSourceCalculate);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">const</span> FVector VelocityBeforeCleanup = Velocity;</span><br><span class="line">			CurrentRootMotion.<span class="built_in">CleanUpInvalidRootMotion</span>(DeltaSeconds, *CharacterOwner, *<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		OldVelocity = Velocity;</span><br><span class="line">		OldLocation = UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ApplyAccumulatedForces</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在我们进行移动之前，更新角色状态</span></span><br><span class="line">		<span class="built_in">UpdateCharacterStateBeforeMovement</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (MovementMode == MOVE_NavWalking &amp;&amp; bWantsToLeaveNavWalking)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TryToLeaveNavWalking</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Character::LaunchCharacter() 已被延迟至此</span></span><br><span class="line">		<span class="built_in">HandlePendingLaunch</span>();</span><br><span class="line">		<span class="built_in">ClearAccumulatedForces</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用因 ApplyAccumulatedForces/HandlePendingLaunch 对角色速度所做的任何外部更改，更新保存的LastPreAdditiveVelocity</span></span><br><span class="line">		<span class="keyword">if</span>( CurrentRootMotion.<span class="built_in">HasAdditiveVelocity</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> FVector Adjustment = (Velocity - OldVelocity);</span><br><span class="line">			CurrentRootMotion.LastPreAdditiveVelocity += Adjustment;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 准备根运动(从根运动源中生成/累积，以便以后使用)</span></span><br><span class="line">		<span class="keyword">if</span> (bHasRootMotionSources &amp;&amp; !CharacterOwner-&gt;bClientUpdating &amp;&amp; !CharacterOwner-&gt;bServerMoveIgnoreRootMotion)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 动画根运动 - 如果使用动画根运动，在运行物理之前 tick 动画</span></span><br><span class="line">			<span class="keyword">if</span>( CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>() &amp;&amp; CharacterOwner-&gt;<span class="built_in">GetMesh</span>() )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">TickCharacterPose</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 确保动画没有激活销毁我们自身的事件</span></span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 本地客户端，缓存根运动数据，以便其可用于移动网络代码</span></span><br><span class="line">				<span class="keyword">if</span>( CharacterOwner-&gt;<span class="built_in">IsLocallyControlled</span>() &amp;&amp; (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_AutonomousProxy) &amp;&amp; CharacterOwner-&gt;<span class="built_in">IsPlayingNetworkedRootMotionMontage</span>() )</span><br><span class="line">				&#123;</span><br><span class="line">					CharacterOwner-&gt;ClientRootMotionParams = RootMotionParams;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 从动画以外的源中生成用于此帧的根运动</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementRootMotionSourceCalculate);</span><br><span class="line">				CurrentRootMotion.<span class="built_in">PrepareRootMotion</span>(DeltaSeconds, *CharacterOwner, *<span class="keyword">this</span>, <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 本地客户端代码，缓存根运动数据，以便其可用于网络代码中的移动</span></span><br><span class="line">			<span class="keyword">if</span>( CharacterOwner-&gt;<span class="built_in">IsLocallyControlled</span>() &amp;&amp; (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_AutonomousProxy) )</span><br><span class="line">			&#123;</span><br><span class="line">				CharacterOwner-&gt;SavedRootMotion = CurrentRootMotion;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 应用根运动到速度中</span></span><br><span class="line">		<span class="keyword">if</span>( CurrentRootMotion.<span class="built_in">HasOverrideVelocity</span>() || <span class="built_in">HasAnimRootMotion</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 动画根运动重载速度，且当前不允许任何其他根运动源</span></span><br><span class="line">			<span class="keyword">if</span>( <span class="built_in">HasAnimRootMotion</span>() )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 转换到世界空间(动画根运动总是本地空间的)</span></span><br><span class="line">				USkeletalMeshComponent * SkelMeshComp = CharacterOwner-&gt;<span class="built_in">GetMesh</span>();</span><br><span class="line">				<span class="keyword">if</span>( SkelMeshComp )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 转换本地空间根动画到世界空间。</span></span><br><span class="line">                    <span class="comment">// 在使用物理前确保我们使用最新的 transforms，因为 translation 是相对于 rotation 的</span></span><br><span class="line">					RootMotionParams.<span class="built_in">Set</span>( <span class="built_in">ConvertLocalRootMotionToWorld</span>(RootMotionParams.<span class="built_in">GetRootMotionTransform</span>()) );</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 然后将根运动转化为速度，以供各种 PhysicsMode 使用</span></span><br><span class="line">				&#123;</span><br><span class="line">					AnimRootMotionVelocity = <span class="built_in">CalcAnimRootMotionVelocity</span>(RootMotionParams.<span class="built_in">GetRootMotionTransform</span>().<span class="built_in">GetTranslation</span>(), DeltaSeconds, Velocity);</span><br><span class="line">					Velocity = <span class="built_in">ConstrainAnimRootMotionVelocity</span>(AnimRootMotionVelocity, Velocity);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// ..... 省略日志输出</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 我们没有动画根运动，所以应用其他源</span></span><br><span class="line">				<span class="keyword">if</span>( DeltaSeconds &gt; <span class="number">0.f</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementRootMotionSourceApply);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">const</span> FVector VelocityBeforeOverride = Velocity;</span><br><span class="line">					FVector NewVelocity = Velocity;</span><br><span class="line">					CurrentRootMotion.<span class="built_in">AccumulateOverrideRootMotionVelocity</span>(DeltaSeconds, *CharacterOwner, *<span class="keyword">this</span>, NewVelocity);</span><br><span class="line">					Velocity = NewVelocity;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 追踪非有限速度值(Nan或Inf)</span></span><br><span class="line">		<span class="built_in">devCode</span>(<span class="built_in">ensureMsgf</span>(!Velocity.<span class="built_in">ContainsNaN</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;UCharacterMovementComponent::PerformMovement: Velocity contains NaN (%s)\n%s&quot;</span>), *<span class="built_in">GetPathNameSafe</span>(<span class="keyword">this</span>), *Velocity.<span class="built_in">ToString</span>()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里清除跳跃输入，以允许移动事件激活它进行下一次更新</span></span><br><span class="line">		CharacterOwner-&gt;<span class="built_in">ClearJumpInput</span>(DeltaSeconds);</span><br><span class="line">		NumJumpApexAttempts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据移动状态改变位置(最终通过调用 MoveUpdateComponent 来更新位置和旋转)</span></span><br><span class="line">		<span class="built_in">StartNewPhysics</span>(DeltaSeconds, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 基于移动的改变更新角色状态</span></span><br><span class="line">		<span class="built_in">UpdateCharacterStateAfterMovement</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((bAllowPhysicsRotationDuringAnimRootMotion || !<span class="built_in">HasAnimRootMotion</span>()) &amp;&amp; !CharacterOwner-&gt;<span class="built_in">IsMatineeControlled</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">PhysicsRotation</span>(DeltaSeconds);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在移动完成后，应用根运动旋转</span></span><br><span class="line">		<span class="keyword">if</span>( <span class="built_in">HasAnimRootMotion</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> FQuat OldActorRotationQuat = UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>();</span><br><span class="line">			<span class="keyword">const</span> FQuat RootMotionRotationQuat = RootMotionParams.<span class="built_in">GetRootMotionTransform</span>().<span class="built_in">GetRotation</span>();</span><br><span class="line">			<span class="keyword">if</span>( !RootMotionRotationQuat.<span class="built_in">IsIdentity</span>() )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">const</span> FQuat NewActorRotationQuat = RootMotionRotationQuat * OldActorRotationQuat;</span><br><span class="line">				<span class="built_in">MoveUpdatedComponent</span>(FVector::ZeroVector, NewActorRotationQuat, <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 根运动已被使用，清除</span></span><br><span class="line">			RootMotionParams.<span class="built_in">Clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (CurrentRootMotion.<span class="built_in">HasActiveRootMotionSources</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			FQuat RootMotionRotationQuat;</span><br><span class="line">			<span class="keyword">if</span> (CharacterOwner &amp;&amp; UpdatedComponent &amp;&amp; CurrentRootMotion.<span class="built_in">GetOverrideRootMotionRotation</span>(DeltaSeconds, *CharacterOwner, *<span class="keyword">this</span>, RootMotionRotationQuat))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">const</span> FQuat OldActorRotationQuat = UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>();</span><br><span class="line">				<span class="keyword">const</span> FQuat NewActorRotationQuat = RootMotionRotationQuat * OldActorRotationQuat;</span><br><span class="line">				<span class="built_in">MoveUpdatedComponent</span>(FVector::ZeroVector, NewActorRotationQuat, <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bHasRequestedVelocity = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">OnMovementUpdated</span>(DeltaSeconds, OldLocation, OldVelocity);</span><br><span class="line">	&#125; <span class="comment">// 结束范围移动更新</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用外部的 post-movement 事件。这些将在范围移动完成之后发生，以便事件可以使用重叠的当前状态等</span></span><br><span class="line">	<span class="built_in">CallMovementUpdateDelegate</span>(DeltaSeconds, OldLocation, OldVelocity);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SaveBaseLocation</span>();</span><br><span class="line">	<span class="built_in">UpdateComponentVelocity</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bHasAuthority = CharacterOwner &amp;&amp; CharacterOwner-&gt;<span class="built_in">HasAuthority</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果我们移动，我们希望在复制注意到这一变化之前避免长时间的延迟，特别是当它限制了我们的速度时</span></span><br><span class="line">	<span class="keyword">if</span> (bHasAuthority &amp;&amp; UNetDriver::<span class="built_in">IsAdaptiveNetUpdateFrequencyEnabled</span>() &amp;&amp; UpdatedComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		UNetDriver* NetDriver = MyWorld-&gt;<span class="built_in">GetNetDriver</span>();</span><br><span class="line">		<span class="keyword">if</span> (NetDriver &amp;&amp; NetDriver-&gt;<span class="built_in">IsServer</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			FNetworkObjectInfo* NetActor = NetDriver-&gt;<span class="built_in">FindOrAddNetworkObjectInfo</span>(CharacterOwner);</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span> (NetActor &amp;&amp; MyWorld-&gt;<span class="built_in">GetTimeSeconds</span>() &lt;= NetActor-&gt;NextUpdateTime &amp;&amp; NetDriver-&gt;<span class="built_in">IsNetworkActorUpdateFrequencyThrottled</span>(*NetActor))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">ShouldCancelAdaptiveReplication</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					NetDriver-&gt;<span class="built_in">CancelAdaptiveReplication</span>(*NetActor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> FVector NewLocation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>() : FVector::ZeroVector;</span><br><span class="line">	<span class="keyword">const</span> FQuat NewRotation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>() : FQuat::Identity;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bHasAuthority &amp;&amp; UpdatedComponent &amp;&amp; !<span class="built_in">IsNetMode</span>(NM_Client))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bLocationChanged = (NewLocation != LastUpdateLocation);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bRotationChanged = (NewRotation != LastUpdateRotation);</span><br><span class="line">		<span class="keyword">if</span> (bLocationChanged || bRotationChanged)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 更新 ServerLastTransformUpdateTimeStamp. </span></span><br><span class="line">            <span class="comment">// 这用于客户端线性插值位置的平滑处理，所以时间戳应该基于客户端移动增量(ServerAccumulatedClientTimeStamp)，而不是接收 RPC 时的服务器时间</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bIsRemotePlayer = (CharacterOwner-&gt;<span class="built_in">GetRemoteRole</span>() == ROLE_AutonomousProxy);</span><br><span class="line">			<span class="keyword">const</span> FNetworkPredictionData_Server_Character* ServerData = bIsRemotePlayer ? <span class="built_in">GetPredictionData_Server_Character</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">if</span> (bIsRemotePlayer &amp;&amp; ServerData &amp;&amp; CharacterMovementCVars::NetUseClientTimestampForReplicatedTransform)</span><br><span class="line">			&#123;</span><br><span class="line">				ServerLastTransformUpdateTimeStamp = <span class="built_in"><span class="keyword">float</span></span>(ServerData-&gt;ServerAccumulatedClientTimeStamp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ServerLastTransformUpdateTimeStamp = MyWorld-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LastUpdateLocation = NewLocation;</span><br><span class="line">	LastUpdateRotation = NewRotation;</span><br><span class="line">	LastUpdateVelocity = Velocity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="startnewphysics"><a class="anchor" href="#startnewphysics">#</a> StartNewPhysics</h4><p>此函数将基于角色当前速度与移动状态 (Walking，Swimming 等) ，采取不同的方式计算其在此帧中的增量位移向量和旋转值，最终调用 <code>MoveUpdatedComponent()</code> 来更新角色的位置与旋转。(我们当然也可以按需求实现自己想要的移动状态 (如：爬墙) 以及计算移动位置的方法)，其定义如下：</p><p></p><figure class="highlight c++"><figcaption><span>StartNewPhysics</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::StartNewPhysics</span><span class="params">(<span class="keyword">float</span> deltaTime, int32 Iterations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...... 差量时间过小或应用物理模拟直接返回</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bSavedMovementInProgress = bMovementInProgress;</span><br><span class="line">	bMovementInProgress = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据移动状态处理角色位置</span></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> ( MovementMode )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> MOVE_None:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MOVE_Walking:</span><br><span class="line">		<span class="built_in">PhysWalking</span>(deltaTime, Iterations);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MOVE_NavWalking:</span><br><span class="line">		<span class="built_in">PhysNavWalking</span>(deltaTime, Iterations);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MOVE_Falling:</span><br><span class="line">		<span class="built_in">PhysFalling</span>(deltaTime, Iterations);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MOVE_Flying:</span><br><span class="line">		<span class="built_in">PhysFlying</span>(deltaTime, Iterations);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MOVE_Swimming:</span><br><span class="line">		<span class="built_in">PhysSwimming</span>(deltaTime, Iterations);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MOVE_Custom:</span><br><span class="line">		<span class="built_in">PhysCustom</span>(deltaTime, Iterations);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogCharacterMovement, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;%s has unsupported movement mode %d&quot;</span>), *CharacterOwner-&gt;<span class="built_in">GetName</span>(), <span class="built_in">int32</span>(MovementMode));</span><br><span class="line">		<span class="built_in">SetMovementMode</span>(MOVE_None);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bMovementInProgress = bSavedMovementInProgress;</span><br><span class="line">	<span class="keyword">if</span> ( bDeferUpdateMoveComponent )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 处理组件重叠，注册组件与主体的碰撞避免</span></span><br><span class="line">		<span class="built_in">SetUpdatedComponent</span>(DeferredUpdatedMoveComponent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以状态机的方式，只要运动状态改变即调用此函数重新计算玩家在新状态下继承原状态的速度后的移动。自定义状态可以模仿对应相似的状态来实现 (如：爬墙可模仿飞行)。Phys* 函数过多，其实就是应用加速度等计算最终位移，并处理潜在的状态改变等。此块留给感兴趣的读者自行研究。</p><h3 id="服务器移动验证"><a class="anchor" href="#服务器移动验证">#</a> 服务器移动验证</h3><p>当代理客户端角色开启服务器复制移动且移动更新到达指定差量时间时，角色移动组件的 <code>TickComponent</code> 即会调用 <code>CallServerMove</code> 向服务器提交移动的相关数据，以验证客户端距离上次验证之后所做的所有预测移动是否正确。 <code>CallServerMove</code> 的调用链较长，其中包括两个移动 (最旧移动和最新移动) 与一个移动 (最新移动) 的不同处理方法，我们直接从最后的 <code>ServerMove_Implementation</code> 开始分析</p><h4 id="servermove_implementation"><a class="anchor" href="#servermove_implementation">#</a> ServerMove_Implementation</h4><p>此函数主要用客户端传进来的参数设置服务器的网络预测数据及玩家控制器的旋转值，并调用 <code>MoveAutonomous</code> 执行实际移动，最后根据实际移动的结果调用 <code>ServerMoveHandleClientError</code> 对正确移动进行确认，错误移动进行矫正</p><p></p><figure class="highlight c++"><figcaption><span>ServerMove_Implementation</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::ServerMove_Implementation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">float</span> TimeStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">	FVector_NetQuantize10 InAccel,</span></span></span><br><span class="line"><span class="params"><span class="function">	FVector_NetQuantize100 ClientLoc,</span></span></span><br><span class="line"><span class="params"><span class="function">	uint8 MoveFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	uint8 ClientRoll,</span></span></span><br><span class="line"><span class="params"><span class="function">	uint32 View,</span></span></span><br><span class="line"><span class="params"><span class="function">	UPrimitiveComponent* ClientMovementBase,</span></span></span><br><span class="line"><span class="params"><span class="function">	FName ClientBaseBoneName,</span></span></span><br><span class="line"><span class="params"><span class="function">	uint8 ClientMovementMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ........ 检查组件和客户端时间戳的有效性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建服务器网络预测数据，该对象在角色生命周期内存在。</span></span><br><span class="line"><span class="comment">     * 此对象将存储信息，以供后面再现所属客户端的移动时使用</span></span><br><span class="line"><span class="comment">     * 此对象在服务器接收数据时，在后台被不断修改</span></span><br><span class="line"><span class="comment">     * 其参数包括用于计算服务器差量时间的时间戳，待定的客户端调整，解决时间差异相关的标记，知识服务器确认还是矫正移动的标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FNetworkPredictionData_Server_Character* ServerData = <span class="built_in">GetPredictionData_Server_Character</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> bServerReadyForClient = <span class="literal">true</span>;</span><br><span class="line">	APlayerController* PC = Cast&lt;APlayerController&gt;(CharacterOwner-&gt;<span class="built_in">GetController</span>());</span><br><span class="line">	<span class="keyword">if</span> (PC)</span><br><span class="line">	&#123;</span><br><span class="line">		bServerReadyForClient = PC-&gt;<span class="built_in">NotifyServerReceivedClientData</span>(CharacterOwner, TimeStamp);</span><br><span class="line">		<span class="keyword">if</span> (!bServerReadyForClient)</span><br><span class="line">		&#123;</span><br><span class="line">			InAccel = FVector::ZeroVector;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 视图组件</span></span><br><span class="line">	<span class="keyword">const</span> uint16 ViewPitch = (View &amp; <span class="number">65535</span>);</span><br><span class="line">	<span class="keyword">const</span> uint16 ViewYaw = (View &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> FVector Accel = InAccel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算差量时间，使用服务器时间戳以避免客户端加快本地时间作弊</span></span><br><span class="line">	<span class="keyword">const</span> UWorld* MyWorld = <span class="built_in">GetWorld</span>();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> DeltaTime = ServerData-&gt;<span class="built_in">GetServerMoveDeltaTime</span>(TimeStamp, CharacterOwner-&gt;<span class="built_in">GetActorTimeDilation</span>(*MyWorld));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置用于验证移动是否需要矫正的数据</span></span><br><span class="line">	ServerData-&gt;CurrentClientTimeStamp = TimeStamp;</span><br><span class="line">	ServerData-&gt;ServerAccumulatedClientTimeStamp += DeltaTime;</span><br><span class="line">	ServerData-&gt;ServerTimeStamp = MyWorld-&gt;<span class="built_in">GetTimeSeconds</span>();</span><br><span class="line">	ServerData-&gt;ServerTimeStampLastServerMove = ServerData-&gt;ServerTimeStamp;</span><br><span class="line">	FRotator ViewRot;</span><br><span class="line">	ViewRot.Pitch = FRotator::<span class="built_in">DecompressAxisFromShort</span>(ViewPitch);</span><br><span class="line">	ViewRot.Yaw = FRotator::<span class="built_in">DecompressAxisFromShort</span>(ViewYaw);</span><br><span class="line">	ViewRot.Roll = FRotator::<span class="built_in">DecompressAxisFromByte</span>(ClientRoll);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PC)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 服务器重新构造所属玩家控制器的控制旋转</span></span><br><span class="line">		PC-&gt;<span class="built_in">SetControlRotation</span>(ViewRot);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bServerReadyForClient)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行实际移动，处理角色的加速、旋转和跳跃输入等</span></span><br><span class="line">	<span class="keyword">if</span> ((MyWorld-&gt;<span class="built_in">GetWorldSettings</span>()-&gt;<span class="built_in">GetPauserPlayerState</span>() == <span class="literal">NULL</span>) &amp;&amp; (DeltaTime &gt; <span class="number">0.f</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (PC)</span><br><span class="line">		&#123;</span><br><span class="line">			PC-&gt;<span class="built_in">UpdateRotation</span>(DeltaTime);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器执行移动，并验证其数据是否正确</span></span><br><span class="line">		<span class="built_in">MoveAutonomous</span>(TimeStamp, DeltaTime, MoveFlags, Accel);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ....... 省略日志输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矫正客户端移动或确认移动 (更新移动缓存数组)</span></span><br><span class="line">	<span class="built_in">ServerMoveHandleClientError</span>(TimeStamp, DeltaTime, Accel, ClientLoc, ClientMovementBase, ClientBaseBoneName, ClientMovementMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="moveautonomous"><a class="anchor" href="#moveautonomous">#</a> MoveAutonomous</h4><p>此函数将根据传入的参数重新处理数据，并根据这些数据和上一步计算出来的差量时间调用 <code>PerformMovement</code> 函数模拟角色移动的物理效果，并记录对应结果用于后面判断是否需要矫正客户端移动。</p><p></p><figure class="highlight c++"><figcaption><span>MoveAutonomous</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::MoveAutonomous</span></span></span><br><span class="line"><span class="function">	<span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">float</span> ClientTimeStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">float</span> DeltaTime,</span></span></span><br><span class="line"><span class="params"><span class="function">	uint8 CompressedFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> FVector&amp; NewAccel</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UpdateFromCompressedFlags</span>(CompressedFlags);</span><br><span class="line">	CharacterOwner-&gt;<span class="built_in">CheckJumpInput</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算加速度</span></span><br><span class="line">	Acceleration = <span class="built_in">ConstrainInputAcceleration</span>(NewAccel);</span><br><span class="line">	Acceleration = Acceleration.<span class="built_in">GetClampedToMaxSize</span>(<span class="built_in">GetMaxAcceleration</span>());</span><br><span class="line">	AnalogInputModifier = <span class="built_in">ComputeAnalogInputModifier</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> FVector OldLocation = UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line">	<span class="keyword">const</span> FQuat OldRotation = UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bWasPlayingRootMotion = CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据之前重新构造的数据和上一步中提供的差量时间来模拟角色移动物理效果。</span></span><br><span class="line">	<span class="built_in">PerformMovement</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查数据是否有效，因为 PerformMovement 可能将角色标记为挂起销毁</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有根运动，在物理之后 tick 动画。在这里执行以下代码是为了使事件、通知、状态和转换与客户端更新保持同步</span></span><br><span class="line">	<span class="keyword">if</span>( CharacterOwner &amp;&amp; !CharacterOwner-&gt;bClientUpdating &amp;&amp; !CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>() &amp;&amp; CharacterOwner-&gt;<span class="built_in">GetMesh</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!bWasPlayingRootMotion)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TickCharacterPose</span>(DeltaTime);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 立即激活事件，因为我们可能每帧接收多个 ServerMoves</span></span><br><span class="line">		CharacterOwner-&gt;<span class="built_in">GetMesh</span>()-&gt;<span class="built_in">ConditionallyDispatchQueuedAnimEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner &amp;&amp; UpdatedComponent)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 平滑处理监听服务器上的远程客户端的本地视图</span></span><br><span class="line">		<span class="keyword">if</span> (CharacterMovementCVars::NetEnableListenServerSmoothing &amp;&amp;</span><br><span class="line">			CharacterOwner-&gt;<span class="built_in">GetRemoteRole</span>() == ROLE_AutonomousProxy &amp;&amp;</span><br><span class="line">			<span class="built_in">IsNetMode</span>(NM_ListenServer))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SmoothCorrection</span>(OldLocation, OldRotation, UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>(), UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="servermovehandleclienterror"><a class="anchor" href="#servermovehandleclienterror">#</a> ServerMoveHandleClientError</h4><p>此函数决定是否矫正客户端的移动。其首先检查 WithinUpdateDelayBounds 的返回值，如果其小于最小时间量则延迟矫正，以避免频繁发送矫正而导致带宽紧张。接着调用 <code>ServerCheckClientError()</code> 检查服务器和客户端之间的误差是否达到需要矫正，如果是 (或因故被强制要求矫正) 则将 <code>PendingAdjustment.bAckGoodMove</code> 设为 <code>false</code> ，并填充 <code>PendingAdjustment</code> 的相关数据 (包括：位置、旋转、速度和可能充当角色移动基础的对象)。否则将 <code>PendingAdjustment.bAckGoodMove</code> 设为 <code>true</code> ，将客户端移动标记为有效。</p><p></p><figure class="highlight c++"><figcaption><span>ServerMoveHandleClientError</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::ServerMoveHandleClientError</span><span class="params">(<span class="keyword">float</span> ClientTimeStamp, <span class="keyword">float</span> DeltaTime, <span class="keyword">const</span> FVector&amp; Accel, <span class="keyword">const</span> FVector&amp; RelativeClientLoc, UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">ShouldUsePackedMovementRPCs</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (RelativeClientLoc == <span class="built_in">FVector</span>(<span class="number">1.f</span>,<span class="number">2.f</span>,<span class="number">3.f</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FNetworkPredictionData_Server_Character* ServerData = <span class="built_in">GetPredictionData_Server_Character</span>();</span><br><span class="line">	<span class="built_in">check</span>(ServerData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了避免频繁发送矫正导致带宽紧张，并导致客户端过于频繁地重新模拟大量已保存的移动</span></span><br><span class="line">    <span class="comment">// 因此先检查 WithinUpdateDelayBounds 的返回值，如果为 ture，则延迟更新客户端</span></span><br><span class="line">	APlayerController* PC = Cast&lt;APlayerController&gt;(CharacterOwner-&gt;<span class="built_in">GetController</span>());</span><br><span class="line">	<span class="keyword">if</span>( (ServerData-&gt;LastUpdateTime != <span class="built_in">GetWorld</span>()-&gt;TimeSeconds))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> AGameNetworkManager* GameNetworkManager = (<span class="keyword">const</span> AGameNetworkManager*)(AGameNetworkManager::<span class="built_in">StaticClass</span>()-&gt;<span class="built_in">GetDefaultObject</span>());</span><br><span class="line">		<span class="keyword">if</span> (GameNetworkManager-&gt;<span class="built_in">WithinUpdateDelayBounds</span>(PC, ServerData-&gt;LastUpdateTime))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 偏移可能是相对于基类组件的</span></span><br><span class="line">	FVector ClientLoc = RelativeClientLoc;</span><br><span class="line">	<span class="keyword">if</span> (MovementBaseUtility::<span class="built_in">UseRelativeLocation</span>(ClientMovementBase))</span><br><span class="line">	&#123;</span><br><span class="line">		FVector BaseLocation;</span><br><span class="line">		FQuat BaseRotation;</span><br><span class="line">		MovementBaseUtility::<span class="built_in">GetMovementBaseTransform</span>(ClientMovementBase, ClientBaseBoneName, BaseLocation, BaseRotation);</span><br><span class="line">		ClientLoc += BaseLocation;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ClientLoc = FRepMovement::<span class="built_in">RebaseOntoLocalOrigin</span>(ClientLoc, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当行走在没有相对位置的地基上时，客户端可能会发送空的移动组件以节省带宽。此时应使用服务器的移动组件</span></span><br><span class="line">	<span class="keyword">if</span> (ClientMovementBase == <span class="literal">nullptr</span> &amp;&amp; ClientMovementMode == MOVE_Walking)</span><br><span class="line">	&#123;</span><br><span class="line">		ClientMovementBase = CharacterOwner-&gt;<span class="built_in">GetBasedMovement</span>().MovementBase;</span><br><span class="line">		ClientBaseBoneName = CharacterOwner-&gt;<span class="built_in">GetBasedMovement</span>().BoneName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用服务器位置计算客户端是否移动错误。如果客户端累积了明显的位置错误，则将其矫正</span></span><br><span class="line">	bNetworkLargeClientCorrection = ServerData-&gt;bForceClientUpdate;</span><br><span class="line">	<span class="keyword">if</span> (ServerData-&gt;bForceClientUpdate || <span class="built_in">ServerCheckClientError</span>(ClientTimeStamp, DeltaTime, Accel, ClientLoc, RelativeClientLoc, ClientMovementBase, ClientBaseBoneName, ClientMovementMode))</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 设置相关矫正信息</span></span><br><span class="line">		UPrimitiveComponent* MovementBase = CharacterOwner-&gt;<span class="built_in">GetMovementBase</span>();</span><br><span class="line">		ServerData-&gt;PendingAdjustment.NewVel = Velocity;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.NewBase = MovementBase;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.NewBaseBoneName = CharacterOwner-&gt;<span class="built_in">GetBasedMovement</span>().BoneName;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.NewLoc = FRepMovement::<span class="built_in">RebaseOntoZeroOrigin</span>(UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>(), <span class="keyword">this</span>);</span><br><span class="line">		ServerData-&gt;PendingAdjustment.NewRot = UpdatedComponent-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line"></span><br><span class="line">		ServerData-&gt;PendingAdjustment.bBaseRelativePosition = MovementBaseUtility::<span class="built_in">UseRelativeLocation</span>(MovementBase);</span><br><span class="line">		<span class="keyword">if</span> (ServerData-&gt;PendingAdjustment.bBaseRelativePosition)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 设置矫正信息中的相对位置</span></span><br><span class="line">			ServerData-&gt;PendingAdjustment.NewLoc = CharacterOwner-&gt;<span class="built_in">GetBasedMovement</span>().Location;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置相关矫正信息</span></span><br><span class="line">		ServerData-&gt;LastUpdateTime = <span class="built_in">GetWorld</span>()-&gt;TimeSeconds;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.DeltaTime = DeltaTime;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.TimeStamp = ClientTimeStamp;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.bAckGoodMove = <span class="literal">false</span>;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.MovementMode = <span class="built_in">PackNetworkMovementMode</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ServerShouldUseAuthoritativePosition</span>(ClientTimeStamp, DeltaTime, Accel, ClientLoc, RelativeClientLoc, ClientMovementBase, ClientBaseBoneName, ClientMovementMode))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> FVector LocDiff = UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>() - ClientLoc; </span><br><span class="line">			<span class="keyword">if</span> (!LocDiff.<span class="built_in">IsZero</span>() || ClientMovementMode != <span class="built_in">PackNetworkMovementMode</span>() || <span class="built_in">GetMovementBase</span>() != ClientMovementBase || (CharacterOwner &amp;&amp; CharacterOwner-&gt;<span class="built_in">GetBasedMovement</span>().BoneName != ClientBaseBoneName))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 只设置位置，在后续移动中，我们将解决最初的重叠条件</span></span><br><span class="line">				UpdatedComponent-&gt;<span class="built_in">SetWorldLocation</span>(ClientLoc, <span class="literal">false</span>); <span class="comment">//-V595</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 信任客户端的移动模式</span></span><br><span class="line">				<span class="built_in">ApplyNetworkMovementMode</span>(ClientMovementMode);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 更新移动组件和新位置的地板</span></span><br><span class="line">				<span class="built_in">SetBase</span>(ClientMovementBase, ClientBaseBoneName);</span><br><span class="line">				<span class="built_in">UpdateFloorFromAdjustment</span>();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 重新计算相对偏移</span></span><br><span class="line">				<span class="built_in">SaveBaseLocation</span>();</span><br><span class="line"></span><br><span class="line">				LastUpdateLocation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>() : FVector::ZeroVector;</span><br><span class="line">				LastUpdateRotation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>() : FQuat::Identity;</span><br><span class="line">				LastUpdateVelocity = Velocity;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 确认移动正确</span></span><br><span class="line">		ServerData-&gt;PendingAdjustment.TimeStamp = ClientTimeStamp;</span><br><span class="line">		ServerData-&gt;PendingAdjustment.bAckGoodMove = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ServerData-&gt;bForceClientUpdate = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>可以看到，此函数并没有直接给客户端发送 RPC 通知其移动是否成功，而是等到服务端 Tick 结束时，在 <code>UNetDriver::ServerReplicateActors</code> 中调用 <code>SendClientAdjustment</code> 来通知客户端移动是否成功。 <code>SendClientAdjustment</code> 函数会根据之前步骤中编译的预测数据的标记方式来决定其操作方式。</p><p>若服务器预测数据的 <code>PendingAdjustment</code> 的 <code>bAckGoodMove</code> 标记为 <code>true</code> ，则将调用 <code>ClientAckGoodMove</code> RPC 来确认移动，告知所属客户端机器上的自主代理该移动为有效。这将从所属客户端的 <code>SavedMoves</code> 缓冲中移除原始移动，并将其记录为 <code>LastAckedMove</code> ，用于编译未来的预测数据。</p><p>若 <code>PendingAdjustment</code> 的 <code>bAckGoodMove</code> 标记为 false，则将调用客户端调整函数 (分情况调用不同函数)，将最终矫正发送到客户端 (下一帧的 <code>ClientUpdatePositionAfterServerUpdate</code> 中 )。</p><h3 id="客户端移动矫正"><a class="anchor" href="#客户端移动矫正">#</a> 客户端移动矫正</h3><p>移动矫正 是在服务器 PRC 通知我们移动错误后的下一帧的 <code>TickComponent</code> 中进行的，处理函数为 <code>ClientUpdatePositionAfterServerUpdate</code> 。之前缓存但却没有被服务器确认的移动将在此函数中进行回放， 其定义如下：</p><p></p><figure class="highlight c++"><figcaption><span>SendClientAdjustment</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UCharacterMovementComponent::ClientUpdatePositionAfterServerUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ....... 省略相关检查逻辑(数据有效性，是否更新位置，以及是否开启物理模拟)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ClientData-&gt;SavedMoves.<span class="built_in">Num</span>() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 没有缓存的移动需要重新模拟，服务器更新给我们的移动即是我们完成的最后一个移动，不需要重新模拟</span></span><br><span class="line">		CharacterOwner-&gt;bClientResimulateRootMotion = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (CharacterOwner-&gt;bClientResimulateRootMotionSources)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 不重新模拟，将将当前根运动更新为服务器发送给我们的根运动</span></span><br><span class="line">			CurrentRootMotion.<span class="built_in">UpdateStateFrom</span>(CharacterOwner-&gt;SavedRootMotion);</span><br><span class="line">			CharacterOwner-&gt;bClientResimulateRootMotionSources = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存可能被回放修改的重要的值</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> SavedAnalogInputModifier = AnalogInputModifier;</span><br><span class="line">	<span class="keyword">const</span> FRootMotionMovementParams BackupRootMotionParams = RootMotionParams; </span><br><span class="line">	<span class="keyword">const</span> FRootMotionSourceGroup BackupRootMotion = CurrentRootMotion;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bRealJump = CharacterOwner-&gt;bPressedJump;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bRealCrouch = bWantsToCrouch;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bRealForceMaxAccel = bForceMaxAccel;</span><br><span class="line">	CharacterOwner-&gt;bClientWasFalling = (MovementMode == MOVE_Falling);</span><br><span class="line">	CharacterOwner-&gt;bClientUpdating = <span class="literal">true</span>;</span><br><span class="line">	bForceNextFloorCheck = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回放没有被确认的移动</span></span><br><span class="line">	<span class="keyword">for</span> (int32 i=<span class="number">0</span>; i&lt;ClientData-&gt;SavedMoves.<span class="built_in">Num</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		FSavedMove_Character* <span class="keyword">const</span> CurrentMove = ClientData-&gt;SavedMoves[i].<span class="built_in">Get</span>();</span><br><span class="line">		<span class="built_in">checkSlow</span>(CurrentMove != <span class="literal">nullptr</span>);</span><br><span class="line">		CurrentMove-&gt;<span class="built_in">PrepMoveFor</span>(CharacterOwner);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ShouldUsePackedMovementRPCs</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 使当前移动数据可供 MoveAutonomy 或任何其他可能需要他的函数访问</span></span><br><span class="line">			<span class="keyword">if</span> (FCharacterNetworkMoveData* NewMove = <span class="built_in">GetNetworkMoveDataContainer</span>().<span class="built_in">GetNewMoveData</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">SetCurrentNetworkMoveData</span>(NewMove);</span><br><span class="line">				NewMove-&gt;<span class="built_in">ClientFillNetworkMoveData</span>(*CurrentMove, FCharacterNetworkMoveData::ENetworkMoveType::NewMove);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">MoveAutonomous</span>(CurrentMove-&gt;TimeStamp, CurrentMove-&gt;DeltaTime, CurrentMove-&gt;<span class="built_in">GetCompressedFlags</span>(), CurrentMove-&gt;Acceleration);</span><br><span class="line"></span><br><span class="line">		CurrentMove-&gt;<span class="built_in">PostUpdate</span>(CharacterOwner, FSavedMove_Character::PostUpdate_Replay);</span><br><span class="line">		<span class="built_in">SetCurrentNetworkMoveData</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FSavedMove_Character* <span class="keyword">const</span> PendingMove = ClientData-&gt;PendingMove.<span class="built_in">Get</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		PendingMove-&gt;bForceNoCombine = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复保存的值</span></span><br><span class="line">	AnalogInputModifier = SavedAnalogInputModifier;</span><br><span class="line">	RootMotionParams = BackupRootMotionParams;</span><br><span class="line">	CurrentRootMotion = BackupRootMotion;</span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner-&gt;bClientResimulateRootMotionSources)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果我们重新模拟根运动源，是因为我们的状态和服务器的不匹配</span></span><br><span class="line">        <span class="comment">// 我们刚重新模拟 SaveMoves，现在需要用最新的良好状态来恢复 CurrentRootMotion</span></span><br><span class="line">		CurrentRootMotion.<span class="built_in">UpdateStateFrom</span>(CharacterOwner-&gt;SavedRootMotion);</span><br><span class="line">		CharacterOwner-&gt;bClientResimulateRootMotionSources = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CharacterOwner-&gt;SavedRootMotion.<span class="built_in">Clear</span>();</span><br><span class="line">	CharacterOwner-&gt;bClientResimulateRootMotion = <span class="literal">false</span>;</span><br><span class="line">	CharacterOwner-&gt;bClientUpdating = <span class="literal">false</span>;</span><br><span class="line">	CharacterOwner-&gt;bPressedJump = bRealJump;</span><br><span class="line">	bWantsToCrouch = bRealCrouch;</span><br><span class="line">	bForceMaxAccel = bRealForceMaxAccel;</span><br><span class="line">	bForceNextFloorCheck = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (ClientData-&gt;SavedMoves.<span class="built_in">Num</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="客户端模拟移动"><a class="anchor" href="#客户端模拟移动">#</a> 客户端模拟移动</h3><p>模拟客户端代理的移动组件，即非玩家控制的角色的移动。其移动是完全根据服务器同步过来的数据 (包括基础移动数据和角色移动模式) 进行模拟的。执行模拟的函数为 <code>TickComponent.SimulatedTick</code> 。此函数将执行移动及物理效果的模拟 ( <code>SimulateRootMotion</code> , <code>SimulateMovement</code> )，并执行移动验证 ( <code>SmoothClientPosition</code> ) 和网络平滑 ( <code>SmoothClientPosition</code> )</p><h4 id="simulatedtick"><a class="anchor" href="#simulatedtick">#</a> SimulatedTick</h4><p></p><figure class="highlight c++"><figcaption><span>SimulatedTick</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::SimulatedTick</span><span class="params">(<span class="keyword">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementSimulated);</span><br><span class="line">	<span class="built_in">checkSlow</span>(CharacterOwner != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重播模式下插值模拟角色位置</span></span><br><span class="line">	<span class="keyword">if</span> (NetworkSmoothingMode == ENetworkSmoothingMode::Replay)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> FVector OldLocation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>() : FVector::ZeroVector;</span><br><span class="line">		<span class="keyword">const</span> FVector OldVelocity = Velocity;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在适当的样本之间插值</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SCOPE_CYCLE_COUNTER</span>( STAT_CharacterMovementSmoothClientPosition );</span><br><span class="line">			<span class="built_in">SmoothClientPosition</span>( DeltaSeconds );</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新复制的移动模式</span></span><br><span class="line">		<span class="built_in">ApplyNetworkMovementMode</span>( <span class="built_in">GetCharacterOwner</span>()-&gt;<span class="built_in">GetReplicatedMovementMode</span>() );</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UpdateComponentVelocity</span>();</span><br><span class="line">		bJustTeleported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CharacterOwner)</span><br><span class="line">		&#123;</span><br><span class="line">			CharacterOwner-&gt;RootMotionRepMoves.<span class="built_in">Empty</span>();</span><br><span class="line">			CurrentRootMotion.<span class="built_in">Clear</span>();</span><br><span class="line">			CharacterOwner-&gt;SavedRootMotion.<span class="built_in">Clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note: 我们不调用执行预测的基类实现，但仍然需要调用这些回调</span></span><br><span class="line">		<span class="built_in">OnMovementUpdated</span>(DeltaSeconds, OldLocation, OldVelocity);</span><br><span class="line">		<span class="built_in">CallMovementUpdateDelegate</span>(DeltaSeconds, OldLocation, OldVelocity);</span><br><span class="line"></span><br><span class="line">		LastUpdateLocation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>() : FVector::ZeroVector;</span><br><span class="line">		LastUpdateRotation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>() : FQuat::Identity;</span><br><span class="line">		LastUpdateVelocity = Velocity;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// TickCharacterPose( DeltaSeconds );</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果我们正在播放根运动蒙太奇</span></span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">IsPlayingNetworkedRootMotionMontage</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		bWasSimulatingRootMotion = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogRootMotion, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;UCharacterMovementComponent::SimulatedTick&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在处理物理之前，Tick动画(更新角色动作，累积角色根运动)</span></span><br><span class="line">		<span class="keyword">if</span>( CharacterOwner &amp;&amp; CharacterOwner-&gt;<span class="built_in">GetMesh</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TickCharacterPose</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 确保动画没有激活时间销毁自身</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟根运动物理</span></span><br><span class="line">		<span class="keyword">if</span>( RootMotionParams.bHasRootMotion )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">const</span> FQuat OldRotationQuat = UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>();</span><br><span class="line">			<span class="keyword">const</span> FVector OldLocation = UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line">			<span class="built_in">SimulateRootMotion</span>(DeltaSeconds, RootMotionParams.<span class="built_in">GetRootMotionTransform</span>());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果我们的位置因为动画而更新，则处理位置校正(如果有从服务器中收到的挂起更新)</span></span><br><span class="line">		<span class="keyword">if</span>( CharacterOwner &amp;&amp; (CharacterOwner-&gt;RootMotionRepMoves.<span class="built_in">Num</span>() &gt; <span class="number">0</span>) )</span><br><span class="line">		&#123;</span><br><span class="line">			CharacterOwner-&gt;<span class="built_in">SimulatedRootMotionPositionFixup</span>(DeltaSeconds);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CurrentRootMotion.<span class="built_in">HasActiveRootMotionSources</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 我们有根运动源且可能有动画的根运动</span></span><br><span class="line">		bWasSimulatingRootMotion = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogRootMotion, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;UCharacterMovementComponent::SimulatedTick&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果我们有 RootMotionRepMoves，寻找最新的重要移动，且将位置/旋转设置到其上</span></span><br><span class="line">		<span class="keyword">bool</span> bCorrectedToServer = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">const</span> FVector OldLocation = UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line">		<span class="keyword">const</span> FQuat OldRotation = UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>();</span><br><span class="line">		<span class="keyword">if</span>( CharacterOwner-&gt;RootMotionRepMoves.<span class="built_in">Num</span>() &gt; <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将 Actor 移回此缓存移动的位置中(服务器复制位置)</span></span><br><span class="line">			FSimulatedRootMotionReplicatedMove&amp; RootMotionRepMove = CharacterOwner-&gt;RootMotionRepMoves.<span class="built_in">Last</span>();</span><br><span class="line">			<span class="keyword">if</span>( CharacterOwner-&gt;<span class="built_in">RestoreReplicatedMove</span>(RootMotionRepMove) )</span><br><span class="line">			&#123;</span><br><span class="line">				bCorrectedToServer = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Acceleration = RootMotionRepMove.RootMotion.Acceleration;</span><br><span class="line"></span><br><span class="line">			CharacterOwner-&gt;<span class="built_in">PostNetReceiveVelocity</span>(RootMotionRepMove.RootMotion.LinearVelocity);</span><br><span class="line">			LastUpdateVelocity = RootMotionRepMove.RootMotion.LinearVelocity;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将 RootMotionSource Server IDs 转换为 AuthoritativeRootMotion 中的 Local IDs</span></span><br><span class="line">            <span class="comment">// 并剔除无效源，以便在我们使用此根移动时，其拥有正确的 IDs</span></span><br><span class="line">			<span class="built_in">ConvertRootMotionServerIDsToLocalIDs</span>(CurrentRootMotion, RootMotionRepMove.RootMotion.AuthoritativeRootMotion, RootMotionRepMove.Time);</span><br><span class="line">			RootMotionRepMove.RootMotion.AuthoritativeRootMotion.<span class="built_in">CullInvalidSources</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 设置根运动状态为 repped</span></span><br><span class="line">			CurrentRootMotion.<span class="built_in">UpdateStateFrom</span>(RootMotionRepMove.RootMotion.AuthoritativeRootMotion, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 清除现有的 RootMotionRepMoves，因为我们已使用最新的</span></span><br><span class="line">			<span class="built_in">UE_LOG</span>(LogRootMotion, Log,  <span class="built_in">TEXT</span>(<span class="string">&quot;\tClearing old moves in SimulatedTick (%d)&quot;</span>), CharacterOwner-&gt;RootMotionRepMoves.<span class="built_in">Num</span>());</span><br><span class="line">			CharacterOwner-&gt;RootMotionRepMoves.<span class="built_in">Reset</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行移动</span></span><br><span class="line">		<span class="built_in">PerformMovement</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 移动校正后，若存在位置偏差，则将其平滑处理</span></span><br><span class="line">		<span class="keyword">if</span>( bCorrectedToServer || CurrentRootMotion.<span class="built_in">NeedsSimulatedSmoothing</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SmoothCorrection</span>(OldLocation, OldRotation, UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>(), UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 未播放根运动蒙太奇</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果我们正在模拟根运动，我们忽略常规 ReplicatedMovement 更新</span></span><br><span class="line">		<span class="comment">// 如果我们不再模拟根运动，强制同步 Movement 变量</span></span><br><span class="line">		<span class="comment">// (根运动可能使速度与 ReplicatedMovement 不同步)</span></span><br><span class="line">		<span class="keyword">if</span>( bWasSimulatingRootMotion )</span><br><span class="line">		&#123;</span><br><span class="line">			bWasSimulatingRootMotion = <span class="literal">false</span>;</span><br><span class="line">			CharacterOwner-&gt;RootMotionRepMoves.<span class="built_in">Empty</span>();</span><br><span class="line">			CharacterOwner-&gt;<span class="built_in">OnRep_ReplicatedMovement</span>();</span><br><span class="line">			CharacterOwner-&gt;<span class="built_in">OnRep_ReplicatedBasedMovement</span>();</span><br><span class="line">			<span class="built_in">ApplyNetworkMovementMode</span>(<span class="built_in">GetCharacterOwner</span>()-&gt;<span class="built_in">GetReplicatedMovementMode</span>());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">IsReplicatingMovement</span>() &amp;&amp; UpdatedComponent)</span><br><span class="line">		&#123;</span><br><span class="line">			USkeletalMeshComponent* Mesh = CharacterOwner-&gt;<span class="built_in">GetMesh</span>();</span><br><span class="line">			<span class="keyword">const</span> FVector SavedMeshRelativeLocation = Mesh ? Mesh-&gt;<span class="built_in">GetRelativeLocation</span>() : FVector::ZeroVector; </span><br><span class="line">			<span class="keyword">const</span> FQuat SavedCapsuleRotation = UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>();</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bPreventMeshMovement = !bNetworkSmoothingComplete;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果由 SmoothClientPosition 处理网格体，则防止在移动期间移动</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function"><span class="keyword">const</span> FScopedPreventAttachedComponentMove <span class="title">PreventMeshMovement</span><span class="params">(bPreventMeshMovement ? Mesh : <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">				<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">IsMatineeControlled</span>() || CharacterOwner-&gt;<span class="built_in">IsPlayingRootMotion</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">PerformMovement</span>(DeltaSeconds);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">SimulateMovement</span>(DeltaSeconds);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用线性平滑时，我们需要知道旋转是否改变，因为网格体应随之变化</span></span><br><span class="line">            <span class="comment">// 旋转在模拟期间的改变是比较少见的，但可能在 ShouldRemainVertical() 改变或站在移动的基座上时发生</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bValidateRotation = bPreventMeshMovement &amp;&amp; (NetworkSmoothingMode == ENetworkSmoothingMode::Linear);</span><br><span class="line">			<span class="keyword">if</span> (bValidateRotation &amp;&amp; UpdatedComponent)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 拥有不同旋转的网格体</span></span><br><span class="line">				<span class="keyword">const</span> FQuat NewCapsuleRotation = UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>();</span><br><span class="line">				<span class="keyword">if</span> (Mesh == CharacterOwner-&gt;<span class="built_in">GetMesh</span>() &amp;&amp; !NewCapsuleRotation.<span class="built_in">Equals</span>(SavedCapsuleRotation, <span class="number">1e-6</span>f) &amp;&amp; ClientPredictionData)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 平滑应向着新的旋转目标进行插值，否则尝试返回到旧的旋转</span></span><br><span class="line">					ClientPredictionData-&gt;MeshRotationTarget = NewCapsuleRotation;</span><br><span class="line">					Mesh-&gt;<span class="built_in">SetRelativeLocationAndRotation</span>(SavedMeshRelativeLocation, CharacterOwner-&gt;<span class="built_in">GetBaseRotationOffset</span>());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动胶囊体后，平滑网格体位置</span></span><br><span class="line">	<span class="keyword">if</span> (!bNetworkSmoothingComplete)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_CharacterMovementSmoothClientPosition);</span><br><span class="line">		<span class="built_in">SmoothClientPosition</span>(DeltaSeconds);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogCharacterNetSmoothing, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;Skipping network smoothing for %s.&quot;</span>), *<span class="built_in">GetNameSafe</span>(CharacterOwner));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>源码中主要分三种情况模拟移动，大致过程如下：</p><ul><li>播放根运动蒙太奇：首先调用 <code>TickCharacterPose</code> 更新角色姿势并累积根运动，然后调用 <code>SimulateRootMotion</code> 在模拟代理中模拟根运动，最后修复模拟根运动后的位置。</li><li>有待使用的根运动源：预处理根运动复制移动后，调用 <code>PerformMovement</code> 执行移动，最后调用 <code>SmoothCorrection</code> 平滑处理位置上出现的错误</li><li>不使用根运动蒙太奇：调用 <code>SimulateMovement</code> 通过服务器同步过来的移动数据直接对胶囊体模拟移动，网格体暂时保持原位不移动，在调用 <code>SmoothClientPosition</code> 平滑处理 Mesh 的移动 (插值)</li></ul><p>前两种情况都是基于根运动蒙太奇更新移动的，其处理方式与自治代理客户端的类似，不再赘述。以下分析模拟代理客户端特有的平滑处理角色移动的方法 <code>SimulateMovement</code> ，与平滑处理网格体位置的方法 <code>SmoothClientPosition</code></p><h4 id="simulatemovement"><a class="anchor" href="#simulatemovement">#</a> SimulateMovement</h4><p></p><figure class="highlight c++"><figcaption><span>SimulateMovement</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CharacterMovementComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::SimulateMovement</span><span class="params">(<span class="keyword">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasValidData</span>() || UpdatedComponent-&gt;Mobility != EComponentMobility::Movable || UpdatedComponent-&gt;<span class="built_in">IsSimulatingPhysics</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bIsSimulatedProxy = (CharacterOwner-&gt;<span class="built_in">GetLocalRole</span>() == ROLE_SimulatedProxy);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> FRepMovement&amp; ConstRepMovement = CharacterOwner-&gt;<span class="built_in">GetReplicatedMovement</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最初未更新复制时的解决办法</span></span><br><span class="line">	<span class="keyword">if</span> (bIsSimulatedProxy &amp;&amp;</span><br><span class="line">		ConstRepMovement.Location.<span class="built_in">IsZero</span>() &amp;&amp;</span><br><span class="line">		ConstRepMovement.Rotation.<span class="built_in">IsZero</span>() &amp;&amp;</span><br><span class="line">		ConstRepMovement.LinearVelocity.<span class="built_in">IsZero</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果基座(角色站立的东西)没有被客户端处理，则不进行模拟直接返回If base is not resolved on the client, we should not try to simulate at all</span></span><br><span class="line">	<span class="keyword">if</span> (CharacterOwner-&gt;<span class="built_in">GetReplicatedBasedMovement</span>().<span class="built_in">IsBaseUnresolved</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogCharacterMovement, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;Base for simulated character &#x27;%s&#x27; is not resolved on client, skipping SimulateMovement&quot;</span>), *CharacterOwner-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FVector OldVelocity;</span><br><span class="line">	FVector OldLocation;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 作用域更新可以提高多移动组件调用的性能(作用域内不进行更新，作用域后统一更新)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">FScopedMovementUpdate <span class="title">ScopedMovementUpdate</span><span class="params">(UpdatedComponent, bEnableScopedMovementUpdates ? EScopedUpdate::DeferredUpdates : EScopedUpdate::ImmediateUpdates)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> bHandledNetUpdate = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (bIsSimulatedProxy)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 处理来自服务器的更改</span></span><br><span class="line">			<span class="keyword">if</span> (bNetworkUpdateReceived)</span><br><span class="line">			&#123;</span><br><span class="line">				bNetworkUpdateReceived = <span class="literal">false</span>;</span><br><span class="line">				bHandledNetUpdate = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">UE_LOG</span>(LogCharacterMovement, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;Proxy %s received net update&quot;</span>), *CharacterOwner-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">				<span class="keyword">if</span> (bNetworkMovementModeChanged)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">ApplyNetworkMovementMode</span>(CharacterOwner-&gt;<span class="built_in">GetReplicatedMovementMode</span>());</span><br><span class="line">					bNetworkMovementModeChanged = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (bJustTeleported || bForceNextFloorCheck)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 确保地面使用的当前的。我们将继续使用复制的基座，如果有</span></span><br><span class="line">					bJustTeleported = <span class="literal">false</span>;</span><br><span class="line">					<span class="built_in">UpdateFloorFromAdjustment</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (bForceNextFloorCheck)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">UpdateFloorFromAdjustment</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UpdateCharacterStateBeforeMovement</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (MovementMode != MOVE_None)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//<span class="doctag">TODO:</span> Also ApplyAccumulatedForces()?</span></span><br><span class="line">			<span class="built_in">HandlePendingLaunch</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ClearAccumulatedForces</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (MovementMode == MOVE_None)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bSimGravityDisabled = (bIsSimulatedProxy &amp;&amp; CharacterOwner-&gt;bSimGravityDisabled);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">bool</span> bZeroReplicatedGroundVelocity = (bIsSimulatedProxy &amp;&amp; <span class="built_in">IsMovingOnGround</span>() &amp;&amp; ConstRepMovement.LinearVelocity.<span class="built_in">IsZero</span>());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// bSimGravityDisabled 意味着当复制或被卡住时，速度为0。避免速度的外部变化</span></span><br><span class="line">		<span class="comment">// 由于模拟在地面上运动的速度为零，所以不能安全地模拟代理速度，因为我们可能无法从服务器获得任何进一步的更新</span></span><br><span class="line">		<span class="keyword">if</span> (bSimGravityDisabled || bZeroReplicatedGroundVelocity)</span><br><span class="line">		&#123;</span><br><span class="line">			Velocity = FVector::ZeroVector;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新基座(角色所站立的东西)</span></span><br><span class="line">		<span class="built_in">MaybeUpdateBasedMovement</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟 pawn 的预测位置</span></span><br><span class="line">		OldVelocity = Velocity;</span><br><span class="line">		OldLocation = UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UpdateProxyAcceleration</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可能只需要在我们没有收到新的位置更新的帧上模拟前向</span></span><br><span class="line">		<span class="keyword">if</span> (!bHandledNetUpdate || !bNetworkSkipProxyPredictionOnNetUpdate || !CharacterMovementCVars::NetEnableSkipProxyPredictionOnNetUpdate)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UE_LOG</span>(LogCharacterMovement, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;Proxy %s simulating movement&quot;</span>), *<span class="built_in">GetNameSafe</span>(CharacterOwner));</span><br><span class="line">			FStepDownResult StepDownResult;</span><br><span class="line">			<span class="built_in">MoveSmooth</span>(Velocity, DeltaSeconds, &amp;StepDownResult); <span class="comment">// 真正模拟胶囊体移动的函数</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 寻找地面并检查角色是否处于下落状态</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">IsMovingOnGround</span>() || MovementMode == MOVE_Falling)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (StepDownResult.bComputedFloor)</span><br><span class="line">				&#123;</span><br><span class="line">					CurrentFloor = StepDownResult.FloorResult;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Velocity.Z &lt;= <span class="number">0.f</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">FindFloor</span>(UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>(), CurrentFloor, Velocity.<span class="built_in">IsZero</span>(), <span class="literal">NULL</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					CurrentFloor.<span class="built_in">Clear</span>();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (!CurrentFloor.<span class="built_in">IsWalkableFloor</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (!bSimGravityDisabled)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 没有地面则一定处于下落状态</span></span><br><span class="line">						<span class="keyword">if</span> (Velocity.Z &lt;= <span class="number">0.f</span> || bApplyGravityWhileJumping || !CharacterOwner-&gt;<span class="built_in">IsJumpProvidingForce</span>())</span><br><span class="line">						&#123;</span><br><span class="line">							Velocity = <span class="built_in">NewFallVelocity</span>(Velocity, <span class="built_in">FVector</span>(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="built_in">GetGravityZ</span>()), DeltaSeconds);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">SetMovementMode</span>(MOVE_Falling);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 可行走地面</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="built_in">IsMovingOnGround</span>())</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">AdjustFloorHeight</span>();</span><br><span class="line">						<span class="built_in">SetBase</span>(CurrentFloor.HitResult.Component.<span class="built_in">Get</span>(), CurrentFloor.HitResult.BoneName);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (MovementMode == MOVE_Falling)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (CurrentFloor.FloorDist &lt;= MIN_FLOOR_DIST || (bSimGravityDisabled &amp;&amp; CurrentFloor.FloorDist &lt;= MAX_FLOOR_DIST))</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">// 在地面上</span></span><br><span class="line">							<span class="built_in">SetPostLandedPhysics</span>(CurrentFloor.HitResult);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (!bSimGravityDisabled)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">// 继续下落</span></span><br><span class="line">								Velocity = <span class="built_in">NewFallVelocity</span>(Velocity, <span class="built_in">FVector</span>(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="built_in">GetGravityZ</span>()), DeltaSeconds);</span><br><span class="line">							&#125;</span><br><span class="line">							CurrentFloor.<span class="built_in">Clear</span>();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UE_LOG</span>(LogCharacterMovement, Verbose, <span class="built_in">TEXT</span>(<span class="string">&quot;Proxy %s SKIPPING simulate movement&quot;</span>), *<span class="built_in">GetNameSafe</span>(CharacterOwner));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UpdateCharacterStateAfterMovement</span>(DeltaSeconds);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 消费路径追踪请求的速度</span></span><br><span class="line">		bHasRequestedVelocity = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">OnMovementUpdated</span>(DeltaSeconds, OldLocation, OldVelocity);</span><br><span class="line">	&#125; <span class="comment">// 结束作用域移动更新</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用消费后处理移动事件。这些在作用域移动完成之后调用，以备事件可以使用当前状态下的重叠等</span></span><br><span class="line">	<span class="built_in">CallMovementUpdateDelegate</span>(DeltaSeconds, OldLocation, OldVelocity);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SaveBaseLocation</span>();</span><br><span class="line">	<span class="built_in">UpdateComponentVelocity</span>();</span><br><span class="line">	bJustTeleported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	LastUpdateLocation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentLocation</span>() : FVector::ZeroVector;</span><br><span class="line">	LastUpdateRotation = UpdatedComponent ? UpdatedComponent-&gt;<span class="built_in">GetComponentQuat</span>() : FQuat::Identity;</span><br><span class="line">	LastUpdateVelocity = Velocity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>SimulatedMovement</code> 函数负责移动模拟代理角色。除了会被 <code>SimulatedTick</code> 调用，还会被 <code>OnRep_ReplicatedMovement</code> 调用 (即 根组件的移动数据被更新时调用)，其执行步骤大致如下：</p><ol><li>调用所属角色的 GetReplicatedMovement 函数，获取对 <code>RelicatedMovement</code> 的引用</li><li>执行安全检查，确保复制的移动数据有效，并解析客户端角色所站立的基座</li><li>检查是否收到新的网络更新</li><li>调用 <code>GetReplicatedMovementMode()</code> 获取服务器中同步过来的角色移动模式</li><li>重置有关网络更新的所有标记，如： <code>bNetworkMovementModeChanged</code></li><li>基于当前 <code>MovementMode</code> 和角色的当前状态信息执行模拟移动的逻辑 (调用 <code>MoveSmooth</code> )</li><li>更新角色触碰到的地面组件，未找到则将角色状态置为 MOVE_Falling，并触发响应事件 (如：Falling)</li><li>调用 <code>OnMovementUpdated</code> ， <code>CallMovementUpdateDelegate</code> 回调，并同步最新的位置，旋转和速度。</li></ol><h4 id="smoothclientposition"><a class="anchor" href="#smoothclientposition">#</a> SmoothClientPosition</h4><p></p><figure class="highlight c++"><figcaption><span>SmoothClientPosition</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UCharacterMovementComponent::SmoothClientPosition</span><span class="params">(<span class="keyword">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...... 省略有效性检测，网络平滑模式与代理模式的检测</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">SmoothClientPosition_Interpolate</span>(DeltaSeconds);</span><br><span class="line">	<span class="built_in">SmoothClientPosition_UpdateVisuals</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此函数用于更新角色的静态网格体，函数体内调用的两条函数作用分别为：</p><ul><li><code>SmoothClientPosition_Interpolate</code> ：插值计算网格体此帧中的位置</li><li><code>SmoothClientPosition_UpdateVisuals</code> ：利用插值计算的偏移量，更新网格体的可视化位置</li></ul><p>值得注意的是， <code>SmoothClientPosition_Interpolate</code> 中的插值方法有多种，如：指数型 (先快后慢)，线型 (均速)，重播型 (重播模式下使用的特殊线型) 等，留给感兴趣的同学自行研究。</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9JbnRlcmFjdGl2ZUV4cGVyaWVuY2VzL05ldHdvcmtpbmcvQ2hhcmFjdGVyTW92ZW1lbnRDb21wb25lbnQv">虚幻官方文档 - 角色移动组件</span></li></ul><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>Unreal 的所有模块都是默认支持网络游戏开发的，而网络游戏中经常需要考虑到客户端和服务器间数据交互的延迟问题。为了降低玩家输入到角色做出反应的时间 (省去了等待服务器确认输入的时间，提高游戏体验)，在移动组件的设计上 Unreal 采用 &quot;客户端先于服务器&quot; 的方式处理，即 客户端不等待服务器确认输入是否有效，而先预测自治角色的行为，若服务器之后判断此输入无效则强制客户端回滚。这种网络同步模式其实并不只用在移动组件上，像 技能组件 或其他需要网络同步的环境交互中也都是可以使用的。</p><p>另外，通过研读源码，我们也发现了虚幻在处理移动组件数据的网络复制时，对于一些细节上的处理和优化。如：</p><ul><li>移动组件的数据更新是非常频繁的，所以必须设置更新差量时间，以降低网络更新频率，减少带宽消耗。</li><li>也正是因为移动组件的数据更新非常频繁，对于一些已经过时的数据，我们通常会直接丢弃。所以我们对于移动的网络更新，我们通常选择使用不可靠的 RPC，以减少带宽与性能上的消耗。</li><li>对于客户端请求服务器验证移动时发送的移动数据包的处理上，将相似的移动合并以减少带宽消耗。</li><li>对于移动矫正，虚幻设置了可容忍范围，减少误差不是很大的 非必要的移动矫正</li><li>对于模拟代理角色的移动更新使用属性复制而非 RPC，因为模拟代理角色的移动是无法预测的 (由其他客户端或服务器控制)，所以我们只需要在服务器同步其属性时，通知模拟代理客户端调用 <code>OnRep_ReplicatedMovement</code> 回调，平滑处理其移动即可</li><li>.......</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-01-12 19:29:49" itemprop="dateModified" datetime="2022-01-12T19:29:49+08:00">2022-01-12</time> </span><span id="2022/01/03/UE4/UE4CPP/Unreal MovementComponent源码解析/" class="item leancloud_visitors" data-flag-title="Unreal MovementComponent 源码解析" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Unreal MovementComponent 源码解析">https://kotori_suki.github.io/2022/01/03/UE4/UE4CPP/Unreal MovementComponent源码解析/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipey84bjtj20zk0m8hdt.jpg" title="Unreal 异步与并行编程"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal 异步与并行编程</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unreal-movementcomponent-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Unreal MovementComponent 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-addmovementinput-%E5%87%BA%E5%8F%91"><span class="toc-number">1.1.</span> <span class="toc-text">从 AddMovementInput 出发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tickcomponent-acharactermovementcomponent"><span class="toc-number">1.2.</span> <span class="toc-text">TickComponent (ACharacterMovementComponent)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E6%A0%B9%E8%BF%90%E5%8A%A8-rootmotion"><span class="toc-number">1.2.1.</span> <span class="toc-text">动画根运动 RootMotion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A7%BB%E5%8A%A8%E9%A2%84%E6%B5%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">客户端移动预测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#controlledcharactermove"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">ControlledCharacterMove</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicatemovetoserver"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">ReplicateMoveToServer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#performmovement"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">PerformMovement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#startnewphysics"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">StartNewPhysics</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%BB%E5%8A%A8%E9%AA%8C%E8%AF%81"><span class="toc-number">1.2.3.</span> <span class="toc-text">服务器移动验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#servermove_implementation"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">ServerMove_Implementation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moveautonomous"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">MoveAutonomous</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#servermovehandleclienterror"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">ServerMoveHandleClientError</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A7%BB%E5%8A%A8%E7%9F%AB%E6%AD%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">客户端移动矫正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E6%8B%9F%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">客户端模拟移动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#simulatedtick"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">SimulatedTick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#simulatemovement"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">SimulateMovement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#smoothclientposition"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">SmoothClientPosition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li><li><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" rel="bookmark" title="Unreal Slate">Unreal Slate</a></li><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li><li><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></li><li><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="bookmark" title="Custom Item Module">Custom Item Module</a></li><li><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></li><li class="active"><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">54</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/2021/08/16/ComputerBase/Algorithm/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/2021/08/16/ComputerBase/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/Gameplay/" title="分类于 Gameplay">Gameplay</a></div><span><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" title="Gameplay —— 总览 &amp; UEngine &amp; UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 结构型模式">结构型模式</a></div><span><a href="/2021/08/18/CPPBase/DesignPattern/Proxy/" title="代理模式">代理模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/21/CPPBase/DesignPattern/Decorater/" title="装饰器模式">装饰器模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2021/08/16/ComputerBase/ComputerNetworks/TCPUDP%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/" title="TCP&#x2F;UDP传输层协议">TCP/UDP传输层协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" title="反射系统API  解析和使用">反射系统API 解析和使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/11/20/CPPBase/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E5%A4%8D%E5%88%BB/" title="C++智能指针 复刻">C++智能指针 复刻</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/01/03/UE4/UE4CPP/Unreal MovementComponent源码解析/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>