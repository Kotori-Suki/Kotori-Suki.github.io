<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/"><title>Gameplay —— AActor & UActorComponent - Gameplay - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Gameplay —— AActor & UActorComponent</h1><div class="meta"><span class="item" title="创建时间：2021-12-06 09:13:52"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-12-06T09:13:52+08:00">2021-12-06</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicliierfjj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/Gameplay/" itemprop="item" rel="index" title="分类于 Gameplay"><span itemprop="name">Gameplay</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h2 id="gameplay-aactor-uactorcomponent"><a class="anchor" href="#gameplay-aactor-uactorcomponent">#</a> Gameplay —— AActor &amp; UActorComponent</h2><p>简介：AActor 与 UActorComponent 是客户端开发经常需要使用到的两个类，所有可以渲染到屏幕上的物体 (不包括 UI) 都继承于 AActor，而 UActorComponent 往往负责 AActor 的某项可复用的功能，比如渲染、物理等。接下来咱去看看源码中 AActor 和 UActorComponent 都是怎么实现的，都给我们提供了什么好用的 API 吧～～～</p><h3 id="aactor"><a class="anchor" href="#aactor">#</a> AActor</h3><p>&quot;AActor&quot; 的 源码中基本都是一些实用 API。在分析源码之前，我们需要先看看虚幻对于 &quot;AActor&quot; 的介绍，以及一些需要注意的地方。说明如下：</p><p><img data-src="AActor.png" alt="AActor"></p><p>虚幻告诉我们：</p><ul><li>Actor 其实就是可以放置 或 生成 (包括一些 GameMode 之类的) 在 level 中的 Object 的基类。</li><li>Actors 包含一个 ActorConponents 的收集器，可以用于控制 actors 移动，渲染等。</li><li>Actor 的其他主要函数是，属性的复制 和 游戏时通过网络调用的函数。</li><li>Actor 的初始化有多个步骤，重要的可见的函数调用顺序如下：<ul><li>UObject::PostLoad -&gt; 对于静态放置在关卡中的 actors，编辑器中或游戏开始时都会调用该函数。但对于新生成的 actors 不会调用</li><li>UActorComponent::OnComponentCreated -&gt; 当一个 actor 在编辑器中或游戏开始时 被生成，任何本机组件都会调用此函数。对于 blueprint 创建的组件，在该组件的构建过程中会调用它。对于从关卡中加载的组件，不调用此命令函数</li><li>AActor::PreRegisterAllComponents -&gt; 对于静态放置的 actors 和 拥有本地根组件生成的 actors，此函数会立即被调用。对于没有本地根组件的蓝图 actors，这些注册函数都会在构造函数后才被调用</li><li>UActorComponent::RegisterComponent -&gt; 所有组件在编辑器中或运行时被注册，此函数创建他们的物理 / 视觉表示。这些调用可以分布在多个帧上，但总是在 PreRegisterAllComponents (预注册所有组件) 之后。未注册的组件也可能调用该函数来将自身从世界中移除掉。</li><li>AActor::PostRegisterAllComponents -&gt; 无论是在编辑器中还是在游戏开始时都为所有 actors 调用，这也是所有情况下最后调用的函数。</li><li>AActor::PostActorCreated -&gt; 当一个 actor 在编辑器中或游戏开始时被创建，此函数会在构造函数前调用。从关卡中加载的组件则不会调用</li><li>AActor::UserConstructionScript -&gt; 提供给蓝图实现的构造函数脚本</li><li>AActor::OnConstruction -&gt; 在 ExecuteConstruction (调用了蓝图构造函数脚本) 后调用。在所有蓝图创建的组件被完全创建和注册后调用。只在游戏开始时调用以生成 actors，编辑器下改变蓝图时可能会被重新运行</li><li>AActor::PreInitializeComponents -&gt; 在 InitializeComponent 被 actor 组件调用之前调用。且只在游戏开始时和某些编辑器预览窗口中调用。</li><li>UActorComponent::Activate -&gt; 这只会在组件被设置为自动激活的情况下调用。也会在手动将组件激活时调用。</li><li>UActorComponent::InitializeComponent -&gt; 这只会在组件被设置为 &quot;想初始化组件集&quot; 时调用。此函数只会在每个游戏会话开始时调用一次</li><li>AActor::PostInitializeComponents -&gt; 在 actor 的组件被初始化后调用，只在游戏开始时和一些编辑器预览</li><li>AActor::BeginPlay -&gt; 当关卡将开始 tick 时调用，只在游戏真正开始时。通常在 PostInitializeComponents 后，但可能会因为网络或子 actors 而延迟调用。</li></ul></li></ul><p>翻译官？确实是翻译官。因为官方已经总结得很好了，咱最多也就做些展开。但既然咱都要读源码的，展开似乎也就没什么必要了，所以直接源码，开冲！</p><p></p><figure class="highlight c++"><figcaption><span>AActor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actor.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(BlueprintType, Blueprintable, config=Engine, meta=(ShortTooltip=<span class="string">&quot;An Actor is an object that can be placed or spawned in the world.&quot;</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ENGINE_API</span> <span class="title">AActor</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">AActor</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** AActor 的构造函数，使用一个 ObjectInitializer 参数以便向后兼容 */</span></span><br><span class="line">	<span class="built_in">AActor</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 从构造函数中调用，以将类初始化为其默认设定 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InitializeDefaults</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 返回用于网络复制的属性，有本地复制属性的 actor 类需要重载该函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 主要 Actor tick 函数，调用 TickActor()</span></span><br><span class="line"><span class="comment">	 * Tick 函数可以通过配置来控制 是否允许 ticking，在一帧中的什么时候开始更新，并设置 tick 依赖</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Tick)</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FActorTickFunction</span> <span class="title">PrimaryActorTick</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果为 true，则在生成 actor 时，它将被发送到客户端，但之后不会从服务器接收进一步的复制更新 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	uint8 bNetTemporary:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果为 true，该 actor 从 map 中被直接加载，出于网络原因，可以通过其完整路径名进行寻址 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	uint8 bNetStartup:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果为真，此 actor 只和它的 owner 相关。如果此标志在游戏中被改变，所有的无主通道都需要被显示关闭。 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Category=Replication, EditDefaultsOnly, BlueprintReadOnly)</span><br><span class="line">	uint8 bOnlyRelevantToOwner:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 总是和网络相关 (重载 bOnlyRelevantToOwner) */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Category=Replication, EditDefaultsOnly, BlueprintReadWrite)</span><br><span class="line">	uint8 bAlwaysRelevant:<span class="number">1</span>;    </span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当更新的 bReplicateMovement 的值被接此 actor 收到时，在客户端中调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRep_ReplicateMovement</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...... 省略 是否复制移动，是否显示，是否拆除等 布尔属性 (190行)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 此 actor 是否有一个负责网络复制的 owner (APlayerController 类型)</span></span><br><span class="line"><span class="comment">	 * 如果 actor 可以调用 RPCs 则返回 true，如果没有这样的 owner 链存在则返回 false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HasNetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 此 actor 是否有一个本地被控制的 owner，负责网络复制(APlyaerController 类型)</span></span><br><span class="line"><span class="comment">	 * 如果 actor 可以调用 RPCs 则返回 true，如果没有这样的 owner 链存在则返回 false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HasLocalNetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">GetAutoDestroyWhenFinished</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bAutoDestroyWhenFinished; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintSetter)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetAutoDestroyWhenFinished</span><span class="params">(<span class="keyword">bool</span> bVal)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 该 actor 是否将复制倒远端机器中 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category=Replication)</span><br><span class="line">	uint8 bReplicates:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此函数应仅在需要设置 RemoteRole 以实现向后兼容性的类的构造函数中使用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetRemoteRoleForBackwardsCompat</span><span class="params">(<span class="keyword">const</span> ENetRole InRemoteRole)</span> </span>&#123; RemoteRole = InRemoteRole; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当 owner 改变时调用，默认不做任何事情，但可以重载 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRep_Owner</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ........ 省略用于确定状态的若干布尔变量 (342行)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取通过关卡流加载时用于更新 Overlaps() 的方法。将 &quot;UseConfigDefault&quot; 选项解析为配置中指定的类默认值。 */</span></span><br><span class="line">	<span class="function">EActorUpdateOverlapsMethod <span class="title">GetUpdateOverlapsMethodDuringLevelStreaming</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当 &#x27;UpdateOverlapsMethodDuringLevelStreaming&#x27; 被选为 &#x27;UseConfigDefault&#x27; 时，</span></span><br><span class="line"><span class="comment">	 * 从配置文件中获得该类的默认值。允许每个类配置不同的默认值。</span></span><br><span class="line"><span class="comment">	 * 例如，对于 actor，它可以在 &quot;DefaultEngine.ini&quot; 中如下定义: </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * [/Script/Engine.Actor]</span></span><br><span class="line"><span class="comment">	 * DefaultUpdateOverlapsMethodDuringLevelStreaming = OnlyUpdateMovable</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 另一个子类也可以设置一个自己的不同的默认值，例如:</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * [/Script/Engine.BlockingVolume]</span></span><br><span class="line"><span class="comment">	 * DefaultUpdateOverlapsMethodDuringLevelStreaming = NeverUpdate</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Config, Category = Collision, VisibleAnywhere)</span><br><span class="line">	EActorUpdateOverlapsMethod DefaultUpdateOverlapsMethodDuringLevelStreaming;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 内部辅助函数，在 Actor initialization/BeginPlay 期间，基于 UpdateOverlapsMethodDuringLevelStreaming 和 bGenerateOverlapEventsDuringLevelStreaming 正确更新覆盖  */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateInitialOverlaps</span><span class="params">(<span class="keyword">bool</span> bFromLevelStreaming)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 描述远端机器的控制权限 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Replicated, Transient)</span><br><span class="line">	TEnumAsByte&lt;<span class="class"><span class="keyword">enum</span> <span class="title">ENetRole</span>&gt;</span> RemoteRole;	</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置此 actor 是否复制到网络客户端中。当此 actor 在服务器中生成时，他也将被发送到客户端</span></span><br><span class="line"><span class="comment">	 * 当其在服务端发生更改时，是否会复制并更新到其他客户端的标志</span></span><br><span class="line"><span class="comment">	 * 在内部更改 RemoteRole 属性，并处理需要将 actor 添加到网络 actor 列表中的情况。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param bInReplicates 该 actor 是否复制到其他网络客户端</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintAuthorityOnly, Category=Replication)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetReplicates</span><span class="params">(<span class="keyword">bool</span> bInReplicates)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置是否将此 actor 的移动复制到其他网络客户端中 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=Replication)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetReplicateMovement</span><span class="params">(<span class="keyword">bool</span> bInReplicateMovement)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 设置此 actor 是否是自治代理 (在网络客户端中的actor，并由该客户端的玩家操控) */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetAutonomousProxy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> bInAutonomousProxy, <span class="keyword">const</span> <span class="keyword">bool</span> bAllowForcePropertyCompare=<span class="literal">true</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 从另一个 actor 中复制 RomoteRole，并添加此 actor 到网络 actor 列表中，如果需要  */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CopyRemoteRoleFrom</span><span class="params">(<span class="keyword">const</span> AActor* CopyFromActor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回本地机器对此 actor 有多少控制权 */</span> </span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=Replication)</span><br><span class="line">	<span class="function">ENetRole <span class="title">GetLocalRole</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Role; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回远端机器对此 actor 有多少控制权 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=Replication)</span><br><span class="line">	<span class="function">ENetRole <span class="title">GetRemoteRole</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** 用于复制咱的根组件的位置和速度 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, ReplicatedUsing=OnRep_ReplicatedMovement, Category=Replication, AdvancedDisplay)</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FRepMovement</span> <span class="title">ReplicatedMovement</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 该 actor 在被销毁之前可以生存多久，0表示永远。注意这是初始值，在开始游戏后不得修改 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category=Actor)</span><br><span class="line">	<span class="keyword">float</span> InitialLifeSpan;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 允许每一个 actor 以不同的速度运行。</span></span><br><span class="line"><span class="comment">     * 一帧的 DeltaTime 是需要乘上全局的 TimeDilation (在 WorldSettings 中)的</span></span><br><span class="line"><span class="comment">     * 但对于此 actor ，改而乘上这个 CustomTImeDilation 作为 DeltaTime，来更新 tick 函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, AdvancedDisplay, Category=Actor)</span><br><span class="line">	<span class="keyword">float</span> CustomTimeDilation;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 创建的时间点，相对于 World-&gt;GetTimeSeconds() */</span></span><br><span class="line">	<span class="keyword">float</span> CreationTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用于复制附着于此 actor 上的根组件到另外一个 actor 上</span></span><br><span class="line"><span class="comment">	 * 当 RootComponent 具有 AttachParent 时，将通过 GathereCurrentMovement() 来初始化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient, ReplicatedUsing=OnRep_AttachmentReplication)</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FRepAttachment</span> <span class="title">AttachmentReplication</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 Actor 的 Owner，主要用于网络复制(bNetUseOwnerRelevancy &amp; bOnlyRelevantToOwner) 和 可见性(PrimitiveComponent bOwnerNoSee and bOnlyOwnerSee) */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_Owner)</span><br><span class="line">	AActor* Owner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 用于指定 网络复制用的 网络驱动（默认网络驱动为 NAME_None 或 NAME_GameNetDriver） */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	FName NetDriverName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 获取对当前 AttachmentReplication 的只读访问权限 */</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> struct FRepAttachment&amp; <span class="title">GetAttachmentReplication</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> AttachmentReplication; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 更新的 AttachmentReplication 的值被此 actor 接收时调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 描述本地机器拥有此 actor 的多少控制权 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">	TEnumAsByte&lt;<span class="class"><span class="keyword">enum</span> <span class="title">ENetRole</span>&gt;</span> Role;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 为 actor 设置休眠，使其脱离复制列表而不在客户端中被销毁 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditDefaultsOnly, Category=Replication)</span><br><span class="line">	TEnumAsByte&lt;<span class="class"><span class="keyword">enum</span> <span class="title">ENetDormancy</span>&gt;</span> NetDormancy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使 actor 有机会暂停复制给传入的网络驱动的玩家。仅在服务器中调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsReplicationPausedForConnection</span><span class="params">(<span class="keyword">const</span> FNetViewer&amp; ConnectionOwnerNetViewer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当复制暂停值改变时，在客户端中调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnReplicationPausedChanged</span><span class="params">(<span class="keyword">bool</span> bIsReplicationPaused)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 控制如何处理与其他对象冲突的情况下生成此actor，默认意味着总是生成 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=Actor)</span><br><span class="line">	ESpawnActorCollisionHandlingMethod SpawnCollisionHandlingMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 自动注册此 actor 接收玩家的输入 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category=Input)</span><br><span class="line">	TEnumAsByte&lt;EAutoReceiveInput::Type&gt; AutoReceiveInput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此输入组件压入栈的优先级 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category=Input)</span><br><span class="line">	int32 InputPriority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理此 actor 的输入的组件，如果输入被允许 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(DuplicateTransient)</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">UInputComponent</span>* <span class="title">InputComponent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此 actor 相对于客户端视口的最大距离的平方，将被复制 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadOnly, EditDefaultsOnly, Category=Replication)</span><br><span class="line">	<span class="keyword">float</span> NetCullDistanceSquared;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 内部的 - 用于 UNetDriver */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	int32 NetTag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此 actor 每秒复制的频率如何，用于决定 NetUpdateTime */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Category=Replication, EditDefaultsOnly, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">float</span> NetUpdateFrequency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于确定需要复制的属性不经常更改时要降低到的复制频率 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Category=Replication, EditDefaultsOnly, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">float</span> MinNetUpdateFrequency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此 actor 的优先级在低带宽或饱和情况下检查复制时，较高的优先级意味着它更有可能进行复制*/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Category=Replication, EditDefaultsOnly, BlueprintReadWrite)</span><br><span class="line">	<span class="keyword">float</span> NetPriority;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 最后一次渲染此 actor 的一个组件的那一帧中 WorldSettings-&gt;TimeSeconds的值。</span></span><br><span class="line"><span class="comment">	 * 这是由渲染线程书写的，渲染线程会在游戏线程的下一帧执行，</span></span><br><span class="line"><span class="comment">	 * 所以你应该允许这个时间最少是游戏线程的世界时间后的一个帧，然后考虑 actor 不可见</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">float</span> LastRenderTime;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FActorLastRenderTime</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置与此 actor 关联的网络驱动的名称。将把此 actor 从旧的网络 actors 列表中移动到新的列表中</span></span><br><span class="line"><span class="comment">	 * @param NewNetDriverName 新网络驱动程序关联的名称</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetNetDriverName</span><span class="params">(FName NewNetDriverName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回与此 actor 关联的网络驱动的名称(所有 RPCs 都将通过该连接出去) */</span></span><br><span class="line">	<span class="function">FName <span class="title">GetNetDriverName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> NetDriverName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 允许 actor 在自己的 actor 通道中复制子对象的函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ReplicateSubobjects</span><span class="params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当一个新的子对象通过复制动态创建时，在此 actor 中调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSubobjectCreatedFromReplication</span><span class="params">(UObject *NewSubobject)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当一个子对象通过复制动态销毁时，在此 actor 中调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSubobjectDestroyFromReplication</span><span class="params">(UObject *Subobject)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Called on the actor right before replication occurs. </span></span><br><span class="line"><span class="comment">	 * Only called on Server, and for autonomous proxies if recording a Client Replay.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PreReplication</span><span class="params">(IRepChangedPropertyTracker &amp; ChangedPropertyTracker)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在进行复制之前调用，以便在录制客户端回放时为每个人调用，包括模拟代理客户端 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PreReplicationForReplay</span><span class="params">(IRepChangedPropertyTracker &amp; ChangedPropertyTracker)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在回放期间，cheakpoint 数据被应用前，在 actor 中调用 (bReplayRewindable 必须为true) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RewindForReplay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 由网络系统调用，以调用此 actor 及其组件上的 PreReplication (预复制) ，使用给定的 NetDriver 查找或创建RepChangedPropertyTracker */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CallPreReplication</span><span class="params">(UNetDriver* NetDriver)</span></span>;	</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** 为此 actor 造成的伤害和其他 gameplay 事件负责的 Pawn */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintReadWrite, ReplicatedUsing=OnRep_Instigator, meta=(ExposeOnSpawn=<span class="literal">true</span>, AllowPrivateAccess=<span class="literal">true</span>), Category=Actor)</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">APawn</span>* <span class="title">Instigator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 当 Instigator 被复制时调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRep_Instigator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 存着 Owner为此Actor的Actors 的数组，他们不需要由 UChildActorComponent 生成 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TArray&lt;AActor*&gt; Children;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/** 定义了此 Actor 在世界中的变化(位置，旋转，缩放)的组件，所有其他组件必须以某种方式附加到此组件上 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintGetter=K2_GetRootComponent, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	USceneComponent* RootComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 控制此 actor 的 matinee actors */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TArray&lt;<span class="class"><span class="keyword">class</span> <span class="title">AMatineeActor</span>*&gt;</span> ControllingMatineeActors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 高效管理 LifeSpanExpired 计时器的句柄 */</span></span><br><span class="line">	FTimerHandle TimerHandle_LifeSpanExpired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回BallowReceivetickeventonIficatedServer的值，</span></span><br><span class="line"><span class="comment">     * 指示 Blueprint ReceiveTick() 事件是否将在专用服务器上执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">AllowReceiveTickEventOnDedicatedServer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bAllowReceiveTickEventOnDedicatedServer; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回该 actor 当前是否正在运行用户构造脚本 */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">IsRunningUserConstructionScript</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bRunningUserConstructionScript; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此 actor 所属的层。这在仅编辑器数据之外，允许在运行时隐藏 LD-specified 层以进行分析 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt; FName &gt; Layers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 拥有此 actor 的 UChildActorComponent */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TWeakObjectPtr&lt;UChildActorComponent&gt; ParentComponent;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取此 actor 的打包模式</span></span><br><span class="line"><span class="comment">	 * 如果此 actor 被打包与其关卡包不同的额外包里，则返回 true</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsPackageExternal</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">HasAnyFlags</span>(RF_HasExternalPackage);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 当 actor 被构造时设置。用于确保不会再次进行构造 */</span></span><br><span class="line">	uint8 bActorIsBeingConstructed : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 标签数组，可以用于分组或分类 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, AdvancedDisplay, Category=Actor)</span><br><span class="line">	TArray&lt;FName&gt; Tags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//~==============================================================================================</span></span><br><span class="line">	<span class="comment">// Delegates</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 当 actor 受到任何形式的伤害时调用 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Game|Damage&quot;</span>)</span><br><span class="line">	FTakeAnyDamageSignature OnTakeAnyDamage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当 actor 受到点伤害时调用 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Game|Damage&quot;</span>)</span><br><span class="line">	FTakePointDamageSignature OnTakePointDamage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当 actor 受到辐射状伤害时的调用 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Game|Damage&quot;</span>)</span><br><span class="line">	FTakeRadialDamageSignature OnTakeRadialDamage;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当另一个 actor 开始与该参与者重叠时调用，例如，一个玩家走进触发器。</span></span><br><span class="line"><span class="comment">	 * 关于对象发生阻挡碰撞时的事件，例如玩家撞墙，请参见 &#x27;hit&#x27; 事件。</span></span><br><span class="line"><span class="comment">	 * 注意: 此 actor 和其他 actor 上的组件必须将 bGenerateOverlapEvents 设置为 true 才能生成重叠事件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	FActorBeginOverlapSignature OnActorBeginOverlap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 当另一个 actor 停止与此 actor 重叠时调用</span></span><br><span class="line"><span class="comment">	 * 注意: 此 actor 和其他 actor 上的组件必须将 bGenerateOverlapEvents 设置为 true 才能发生重叠事件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	FActorEndOverlapSignature OnActorEndOverlap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....... 省略 光标略过事件，点击事件，触碰事件的定义(838行)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 当此 Actor 碰撞到其他固体时调用。这可能因为角色移动 (启用通过 &#x27;sweep&#x27; 设置位置，或启用物理模拟) 而调用</span></span><br><span class="line"><span class="comment">	 * 对于对象发生重叠时的事件(如: 行走到一个触发器上) ，请参见 &#x27;Overlap&#x27; 事件</span></span><br><span class="line"><span class="comment">	 * 注意: 启用物理模拟期间发生碰撞才能触发碰撞事件，且必须启用 &#x27;Simulation Generates Hit Events&#x27;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	FActorHitSignature OnActorHit;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 将此 actor 压入 通过 PlayerController 处理输入的堆栈中</span></span><br><span class="line"><span class="comment">	 * @param PlayerController 我们想接收其输入事件的 PlayerController </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EnableInput</span><span class="params">(class APlayerController* PlayerController)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 从堆栈中移除此 actor</span></span><br><span class="line"><span class="comment">	 * @param PlayerController 我们不想再接收其输入事件的 PlayerController。如果为空，此 actor 将停止接收来自所有 PlayerController 的输入</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DisableInput</span><span class="params">(class APlayerController* PlayerController)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果此 actor 启用了输入，获取输入轴的值 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(BlueprintInternalUseOnly=<span class="string">&quot;true&quot;</span>, HideSelfPin=<span class="string">&quot;true&quot;</span>, HidePin=<span class="string">&quot;InputAxisName&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetInputAxisValue</span><span class="params">(<span class="keyword">const</span> FName InputAxisName)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果此 actor 启用了输入，获取输入轴键的值 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(BlueprintInternalUseOnly=<span class="string">&quot;true&quot;</span>, HideSelfPin=<span class="string">&quot;true&quot;</span>, HidePin=<span class="string">&quot;InputAxisKey&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetInputAxisKeyValue</span><span class="params">(<span class="keyword">const</span> FKey InputAxisKey)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果此 actor 启用了输入，获取输入轴键的值 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(BlueprintInternalUseOnly=<span class="string">&quot;true&quot;</span>, HideSelfPin=<span class="string">&quot;true&quot;</span>, HidePin=<span class="string">&quot;InputAxisKey&quot;</span>))</span><br><span class="line">	<span class="function">FVector <span class="title">GetInputVectorAxisValue</span><span class="params">(<span class="keyword">const</span> FKey InputAxisKey)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回此 actor 的 instigator，如果为空则返回 nullptr */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(BlueprintProtected = <span class="string">&quot;true&quot;</span>), Category=<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">	<span class="function">APawn* <span class="title">GetInstigator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取 instigator，并转化成特定类型，不存在或转换失败都将返回 nullptr */</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">	<span class="function">T* <span class="title">GetInstigator</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cast&lt;T&gt;(<span class="built_in">GetInstigator</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 的 instigator 的控制器，为空则返回 nullptr */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(BlueprintProtected = <span class="string">&quot;true&quot;</span>), Category=<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">	<span class="function">AController* <span class="title">GetInstigatorController</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回 instigator 的 controller，不存在或转换失败都将返回 nullptr */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">	T* <span class="title">GetInstigatorController</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cast&lt;T&gt;(<span class="built_in">GetInstigatorController</span>());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// General functions.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取 actor 的世界变换(世界坐标，世界旋转，世界缩放) */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;GetActorTransform&quot;</span>, ScriptName = <span class="string">&quot;GetActorTransform&quot;</span>), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FTransform&amp; <span class="title">GetTransform</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ActorToWorld</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** 获取根组件本地到世界的变换，和 GetTransform() 相同 */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">const</span> FTransform&amp; <span class="title">ActorToWorld</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (RootComponent ? RootComponent-&gt;<span class="built_in">GetComponentTransform</span>() : FTransform::Identity);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 和 GetTransform() 一样，但只返回此 actor 的世界坐标 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;GetActorLocation&quot;</span>, ScriptName = <span class="string">&quot;GetActorLocation&quot;</span>, Keywords=<span class="string">&quot;position&quot;</span>), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function">FVector <span class="title">K2_GetActorLocation</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 立即将此 Actor 移动到特定的位置</span></span><br><span class="line"><span class="comment">	 * @param NewLocation 需要移动到的新位置</span></span><br><span class="line"><span class="comment">	 * @param bSweep 我们是否从原位置扫描到目标位置，触发沿途的重叠，如果被什么东西阻挡，则在目标附近停止。</span></span><br><span class="line"><span class="comment">	 * 只有根组件用于扫描并检查事件，子组件只移动不扫描。如果未启用碰撞，这将没有效果</span></span><br><span class="line"><span class="comment">	 * @param bTeleport	 是否传送物理状态 (如果此对象的物理碰撞已开启)</span></span><br><span class="line"><span class="comment">	 * 如果为真，此对象的物理速度将不会被改变 (所以布娃娃零件不会因位置的改变而受到影响)</span></span><br><span class="line"><span class="comment">	 * 如果为假，物理速度会基于改变的位置而更新 (影响布娃娃零件)</span></span><br><span class="line"><span class="comment">	 * 如果CCD开启且未开启物理状态传送，这将影响整个扫描体积内的所有对象</span></span><br><span class="line"><span class="comment">	 * @param SweepHitResult 如果扫描，返回本次移动的阻挡事件</span></span><br><span class="line"><span class="comment">	 * @return	位置是否成功被设置 (如果没开扫描)，或是否发生移动 (开启扫描)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;SetActorLocation&quot;</span>, ScriptName = <span class="string">&quot;SetActorLocation&quot;</span>, Keywords=<span class="string">&quot;position&quot;</span>), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">K2_SetActorLocation</span><span class="params">(FVector NewLocation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回此 Actor 根组件的选择值 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;GetActorRotation&quot;</span>, ScriptName = <span class="string">&quot;GetActorRotation&quot;</span>), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function">FRotator <span class="title">K2_GetActorRotation</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取此 actor 相对于世界空间的，正前方(X方向)的单位向量 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function">FVector <span class="title">GetActorForwardVector</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取此 actor 相对于世界空间的，正上方(Z方向)的单位向量 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function">FVector <span class="title">GetActorUpVector</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 获取此 actor 相对于世界空间的，正右方(Y方向)的单位向量 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function">FVector <span class="title">GetActorRightVector</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回组成此 actor 的所有组件(不包括 ChildActorComponents )的绑定盒</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param	bOnlyCollidingComponents	是否只返回开启了碰撞的组件</span></span><br><span class="line"><span class="comment">	 * @param	Origin						设置 actor 在世界空间中的中心点</span></span><br><span class="line"><span class="comment">	 * @param	BoxExtent					在 3d 空间中设置 actor 大小的一半</span></span><br><span class="line"><span class="comment">	 * @param	bIncludeFromChildActors		是否递归处理 ChildActorComponent</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Collision&quot;</span>, meta=(DisplayName = <span class="string">&quot;GetActorBounds&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetActorBounds</span><span class="params">(<span class="keyword">bool</span> bOnlyCollidingComponents, FVector&amp; Origin, FVector&amp; BoxExtent, <span class="keyword">bool</span> bIncludeFromChildActors = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回此 Actor 的根组件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintGetter)</span><br><span class="line">	<span class="function">USceneComponent* <span class="title">K2_GetRootComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回根组件的速度(in cm/s(Unreal Units/second))，如果其开启了物理或有一个关联的移动组件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FVector <span class="title">GetVelocity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_SetActorLocation 一致，K2_SetActorLocation 用于蓝图 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetActorLocation</span><span class="params">(<span class="keyword">const</span> FVector&amp; NewLocation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 立即设置此 actor 的旋转值</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param	NewRotation	此 actor 的新旋转值</span></span><br><span class="line"><span class="comment">	 * @param	bTeleportPhysics 是否传送物理状态(如果此对象的物理碰撞已开启)</span></span><br><span class="line"><span class="comment">	 * 如果为真，此对象的物理速度将不会改变 (所以布娃娃部件不因为位置的变换而受到影响)</span></span><br><span class="line"><span class="comment">	 * 如果为假，物理速度会基于改变的位置而改变 (影响布娃娃部件)</span></span><br><span class="line"><span class="comment">	 * @return	旋转值是否成功被设置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;SetActorRotation&quot;</span>, ScriptName = <span class="string">&quot;SetActorRotation&quot;</span>), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">K2_SetActorRotation</span><span class="params">(FRotator NewRotation, <span class="keyword">bool</span> bTeleportPhysics)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 与 K2_SetActorRotation 一致，K2_SetActorRotation 用于蓝图 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetActorRotation</span><span class="params">(FRotator NewRotation, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetActorRotation</span><span class="params">(<span class="keyword">const</span> FQuat&amp; NewRotation, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** K2_SetActorLocation 和 K2_SetActorRotation 的结合版，返回旋转值是否成功被设置 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;SetActorLocationAndRotation&quot;</span>, ScriptName=<span class="string">&quot;SetActorLocationAndRotation&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">K2_SetActorLocationAndRotation</span><span class="params">(FVector NewLocation, FRotator NewRotation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 与 K2_SetActorLocationAndRotation 一致，K2_SetActorLocationAndRotation 用于蓝图 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetActorLocationAndRotation</span><span class="params">(FVector NewLocation, FRotator NewRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetActorLocationAndRotation</span><span class="params">(FVector NewLocation, <span class="keyword">const</span> FQuat&amp; NewRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 设置 actor 的世界空间缩放 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorScale3D</span><span class="params">(FVector NewScale3D)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回 actor 的世界空间缩放 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Orientation&quot;</span>)</span><br><span class="line">	<span class="function">FVector <span class="title">GetActorScale3D</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 到传入 actor 的距离 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetDistanceTo</span><span class="params">(<span class="keyword">const</span> AActor* OtherActor)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 到传入 actor 的距离的平方 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetSquaredDistanceTo</span><span class="params">(<span class="keyword">const</span> AActor* OtherActor)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 到传入 actor 的距离，忽略 Z 轴 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetHorizontalDistanceTo</span><span class="params">(<span class="keyword">const</span> AActor* OtherActor)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 到传入 actor 的距离，忽略 XY 轴 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetVerticalDistanceTo</span><span class="params">(<span class="keyword">const</span> AActor* OtherActor)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 Actor 到传入 actor 的点积，失败返回 -2，重合返回0. */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetDotProductTo</span><span class="params">(<span class="keyword">const</span> AActor* OtherActor)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 Actor 到传入 actor 的点积，忽略 Z 轴，失败返回 -2，重合返回0. */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetHorizontalDotProductTo</span><span class="params">(<span class="keyword">const</span> AActor* OtherActor)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 为此 actor 的位置添加一个世界空间中的增量</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param DeltaLocation 位置的改变量</span></span><br><span class="line"><span class="comment">	 * @param bSweep 我们是否从原位置扫描到目标位置，触发沿途的重叠，如果被什么东西阻挡，则在目标附近停止。</span></span><br><span class="line"><span class="comment">	 * 只有根组件用于扫描并检查事件，子组件只移动不扫描。如果未启用碰撞，这将没有效果</span></span><br><span class="line"><span class="comment">	 * @param bTeleport	 是否传送物理状态 (如果此对象的物理碰撞已开启)</span></span><br><span class="line"><span class="comment">	 * 如果为真，此对象的物理速度将不会被改变 (所以布娃娃零件不会因位置的改变而受到影响)</span></span><br><span class="line"><span class="comment">	 * 如果为假，物理速度会基于改变的位置而更新 (影响布娃娃零件)</span></span><br><span class="line"><span class="comment">	 * 如果CCD开启且未开启物理状态传送，这将影响整个扫描体积内的所有对象</span></span><br><span class="line"><span class="comment">	 * @param SweepHitResult 如果扫描，返回本次移动的阻挡事件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;AddActorWorldOffset&quot;</span>, ScriptName=<span class="string">&quot;AddActorWorldOffset&quot;</span>, Keywords=<span class="string">&quot;location position&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AddActorWorldOffset</span><span class="params">(FVector DeltaLocation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorWorldOffset</span><span class="params">(FVector DeltaLocation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_AddActorWorldOffset 类似，但添加的是旋转值的增量 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;AddActorWorldRotation&quot;</span>, ScriptName=<span class="string">&quot;AddActorWorldRotation&quot;</span>, AdvancedDisplay=<span class="string">&quot;bSweep,SweepHitResult,bTeleport&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AddActorWorldRotation</span><span class="params">(FRotator DeltaRotation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorWorldRotation</span><span class="params">(FRotator DeltaRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorWorldRotation</span><span class="params">(<span class="keyword">const</span> FQuat&amp; DeltaRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 为此 actor 的变化添加一个世界空间的增量 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;AddActorWorldTransform&quot;</span>, ScriptName=<span class="string">&quot;AddActorWorldTransform&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AddActorWorldTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; DeltaTransform, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorWorldTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; DeltaTransform, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 为此 actor 的变化添加一个世界空间的增量，不改变缩放 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities|Transformation&quot;</span>, meta = (DisplayName = <span class="string">&quot;AddActorWorldTransformKeepScale&quot;</span>, ScriptName = <span class="string">&quot;AddActorWorldTransformKeepScale&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AddActorWorldTransformKeepScale</span><span class="params">(<span class="keyword">const</span> FTransform&amp; DeltaTransform, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorWorldTransformKeepScale</span><span class="params">(<span class="keyword">const</span> FTransform&amp; DeltaTransform, <span class="keyword">bool</span> bSweep = <span class="literal">false</span>, FHitResult* OutSweepHitResult = <span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将此 actor 的变换设置为一个特定的值，参数解析跟 SetActorLocation 一致 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;SetActorTransform&quot;</span>, ScriptName=<span class="string">&quot;SetActorTransform&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">K2_SetActorTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; NewTransform, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetActorTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; NewTransform, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 为此 actor 的根组件添加一个相对位置增量</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param DelatLocation		本地空间的位置变换(相对位置的变化量)</span></span><br><span class="line"><span class="comment">	 * @param bSweep 我们是否从原位置扫描到目标位置，触发沿途的重叠，如果被什么东西阻挡，则在目标附近停止。</span></span><br><span class="line"><span class="comment">	 * 只有根组件用于扫描并检查事件，子组件只移动不扫描。如果未启用碰撞，这将没有效果</span></span><br><span class="line"><span class="comment">	 * @param bTeleport	 是否传送物理状态 (如果此对象的物理碰撞已开启)</span></span><br><span class="line"><span class="comment">	 * 如果为真，此对象的物理速度将不会被改变 (所以布娃娃零件不会因位置的改变而受到影响)</span></span><br><span class="line"><span class="comment">	 * 如果为假，物理速度会基于改变的位置而更新 (影响布娃娃零件)</span></span><br><span class="line"><span class="comment">	 * 如果CCD开启且未开启物理状态传送，这将影响整个扫描体积内的所有对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;AddActorLocalOffset&quot;</span>, ScriptName=<span class="string">&quot;AddActorLocalOffset&quot;</span>, Keywords=<span class="string">&quot;location position&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AddActorLocalOffset</span><span class="params">(FVector DeltaLocation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorLocalOffset</span><span class="params">(FVector DeltaLocation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_AddActorLocalOffset 类似，但添加的是相对旋转增量*/</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;AddActorLocalRotation&quot;</span>, ScriptName=<span class="string">&quot;AddActorLocalRotation&quot;</span>, AdvancedDisplay=<span class="string">&quot;bSweep,SweepHitResult,bTeleport&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AddActorLocalRotation</span><span class="params">(FRotator DeltaRotation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorLocalRotation</span><span class="params">(FRotator DeltaRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorLocalRotation</span><span class="params">(<span class="keyword">const</span> FQuat&amp; DeltaRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_AddActorLocalOffset 类似，但添加的是相对变换增量 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;AddActorLocalTransform&quot;</span>, ScriptName=<span class="string">&quot;AddActorLocalTransform&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AddActorLocalTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; NewTransform, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddActorLocalTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; NewTransform, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将此 actor 的根组件设置为特定的相对位置</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param NewRelativeLocation	此 actor 新的相对位置</span></span><br><span class="line"><span class="comment">	 * @param bSweep 我们是否从原位置扫描到目标位置，触发沿途的重叠，如果被什么东西阻挡，则在目标附近停止。</span></span><br><span class="line"><span class="comment">	 * 只有根组件用于扫描并检查事件，子组件只移动不扫描。如果未启用碰撞，这将没有效果</span></span><br><span class="line"><span class="comment">	 * @param bTeleport	 是否传送物理状态 (如果此对象的物理碰撞已开启)</span></span><br><span class="line"><span class="comment">	 * 如果为真，此对象的物理速度将不会被改变 (所以布娃娃零件不会因位置的改变而受到影响)</span></span><br><span class="line"><span class="comment">	 * 如果为假，物理速度会基于改变的位置而更新 (影响布娃娃零件)</span></span><br><span class="line"><span class="comment">	 * 如果CCD开启且未开启物理状态传送，这将影响整个扫描体积内的所有对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;SetActorRelativeLocation&quot;</span>, ScriptName=<span class="string">&quot;SetActorRelativeLocation&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_SetActorRelativeLocation</span><span class="params">(FVector NewRelativeLocation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorRelativeLocation</span><span class="params">(FVector NewRelativeLocation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_SetActorRelativeLocation 类似，但设置的是相对旋转 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;SetActorRelativeRotation&quot;</span>, ScriptName=<span class="string">&quot;SetActorRelativeRotation&quot;</span>, AdvancedDisplay=<span class="string">&quot;bSweep,SweepHitResult,bTeleport&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_SetActorRelativeRotation</span><span class="params">(FRotator NewRelativeRotation, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorRelativeRotation</span><span class="params">(FRotator NewRelativeRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorRelativeRotation</span><span class="params">(<span class="keyword">const</span> FQuat&amp; NewRelativeRotation, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_SetActorRelativeLocation 类似，但设置的是相对变换 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>, meta=(DisplayName=<span class="string">&quot;SetActorRelativeTransform&quot;</span>, ScriptName=<span class="string">&quot;SetActorRelativeTransform&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_SetActorRelativeTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; NewRelativeTransform, <span class="keyword">bool</span> bSweep, FHitResult&amp; SweepHitResult, <span class="keyword">bool</span> bTeleport)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorRelativeTransform</span><span class="params">(<span class="keyword">const</span> FTransform&amp; NewRelativeTransform, <span class="keyword">bool</span> bSweep=<span class="literal">false</span>, FHitResult* OutSweepHitResult=<span class="literal">nullptr</span>, ETeleportType Teleport = ETeleportType::None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置此 actor 的跟组件为特定的相对3d缩放  */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorRelativeScale3D</span><span class="params">(FVector NewRelativeScale)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 的相对3d缩放 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Orientation&quot;</span>)</span><br><span class="line">	<span class="function">FVector <span class="title">GetActorRelativeScale3D</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置 actor(及其所有组件) 在游戏中隐藏 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Rendering&quot;</span>, meta=( DisplayName = <span class="string">&quot;Set Actor Hidden In Game&quot;</span>, Keywords = <span class="string">&quot;Visible Hidden Show Hide&quot;</span> ))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetActorHiddenInGame</span><span class="params">(<span class="keyword">bool</span> bNewHidden)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 允许 开启/关闭 整个actor的碰撞 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorEnableCollision</span><span class="params">(<span class="keyword">bool</span> bNewActorEnableCollision)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取整个 actor 的当前碰撞状态 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintPure, Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">GetActorEnableCollision</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 销毁此 actor */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;Delete&quot;</span>, DisplayName = <span class="string">&quot;DestroyActor&quot;</span>, ScriptName = <span class="string">&quot;DestroyActor&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">K2_DestroyActor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 是否拥有网络权威(服务端) */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Networking&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">HasAuthority</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 创建一个新组件，并将所有权分配给调用该组件的 actor。</span></span><br><span class="line"><span class="comment">	 * 自动附着会使创建的第一个组件成为根，并将所有后续组件附着到该根下。</span></span><br><span class="line"><span class="comment">	 * 设置 bManualAttachment 时，将跳过自动附加，由用户自己附加生成的组件(或将其设置为根组件)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @see UK2Node_AddComponent 不要手动调用，仅限蓝图内部使用(用于添加组件节点)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param TemplateName 使用的组件模板的名称</span></span><br><span class="line"><span class="comment">	 * @param bManualAttachment	是否手动附着此组件</span></span><br><span class="line"><span class="comment">	 * @param RelativeTransform	新组件与其附着的父对象的相对变换(仅限自动附着)</span></span><br><span class="line"><span class="comment">	 * @param ComponentTemplateContext 可选的 UBlueprintGeneratedClass 引用，用于查找模板。如果为 null (或不是BPGC)，则在该 actor 的类中查找组件</span></span><br><span class="line"><span class="comment">	 * @param bDeferredFinish 是否立即完成此组件的创建和注册过程。如如果设置了 expose on spawn 属性，则将为false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(ScriptNoExport, BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>, DefaultToSelf=<span class="string">&quot;ComponentTemplateContext&quot;</span>, InternalUseParam=<span class="string">&quot;ComponentTemplateContext,bDeferredFinish&quot;</span>))</span><br><span class="line">	<span class="function">UActorComponent* <span class="title">AddComponent</span><span class="params">(FName TemplateName, <span class="keyword">bool</span> bManualAttachment, <span class="keyword">const</span> FTransform&amp; RelativeTransform, <span class="keyword">const</span> UObject* ComponentTemplateContext, <span class="keyword">bool</span> bDeferredFinish = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 与 AddComponent 一致，但此函数通过类来添加组件</span></span><br><span class="line"><span class="comment">	 * @see UK2Node_AddComponentByClass 不要手动调用，仅限蓝图内部使用(用于添加组件节点)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(ScriptNoExport, BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>, InternalUseParam=<span class="string">&quot;bDeferredFinish&quot;</span>))</span><br><span class="line">	<span class="function">UActorComponent* <span class="title">AddComponentByClass</span><span class="params">(TSubclassOf&lt;UActorComponent&gt; Class, <span class="keyword">bool</span> bManualAttachment, <span class="keyword">const</span> FTransform&amp; RelativeTransform, <span class="keyword">bool</span> bDeferredFinish)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 完成一个 actor 组件的创建，在蓝图中调用(expose on spawn属性被设置后)，或直接被 AddComponent 调用</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @see UK2Node_AddComponent 不要手动调用，仅限蓝图内部使用(用于添加组件节点)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param Component 在 AddComponent 中创建的，需要结束创建的组件</span></span><br><span class="line"><span class="comment">	 * @param bManualAttachment 是否手动附着此组件</span></span><br><span class="line"><span class="comment">	 * @param RelativeTransform 新组件与其父对象的相对变换(仅限自动附着)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(BlueprintInternalUseOnly=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FinishAddComponent</span><span class="params">(UActorComponent* Component, <span class="keyword">bool</span> bManualAttachment, <span class="keyword">const</span> FTransform&amp; RelativeTransform)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** DEPRECATED - 使用 DestroyComponent() 代替 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.17</span>, <span class="string">&quot;Use UActorComponent::DestroyComponent() instead&quot;</span>)</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DeprecatedFunction, DeprecationMessage = <span class="string">&quot;Use Component.DestroyComponent instead&quot;</span>, BlueprintProtected = <span class="string">&quot;true&quot;</span>, DisplayName = <span class="string">&quot;DestroyComponent&quot;</span>, ScriptName = <span class="string">&quot;DestroyComponent&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_DestroyComponent</span><span class="params">(UActorComponent* Component)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** DEPRECATED - 使用 AttachToComponent() 代替 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.17</span>, <span class="string">&quot;Use AttachToComponent() instead.&quot;</span>)</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (DisplayName = <span class="string">&quot;AttachRootComponentTo (Deprecated)&quot;</span>, ScriptNoExport, AttachLocationType = <span class="string">&quot;KeepRelativeOffset&quot;</span>), Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AttachRootComponentTo</span><span class="params">(USceneComponent* InParent, FName InSocketName = NAME_None, EAttachLocation::Type AttachLocationType = EAttachLocation::KeepRelativeOffset, <span class="keyword">bool</span> bWeldSimulatedBodies = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将此 Actor 的根组件附加到提供的组件(可选的命名套接字处)。对未注册的组件调用此命令无效。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param Parent					附着的父对象(非根组件)</span></span><br><span class="line"><span class="comment">	 * @param SocketName				用于附着到父对象中的可选套接字</span></span><br><span class="line"><span class="comment">	 * @param LocationRule				附着时如何处理位置</span></span><br><span class="line"><span class="comment">	 * @param RotationRule				附着时如何处理旋转</span></span><br><span class="line"><span class="comment">	 * @param ScaleRule					附着时如何处理缩放</span></span><br><span class="line"><span class="comment">	 * @param bWeldSimulatedBodies		是否将模拟物理体焊接在一起(构造函数中直接调用SetupAttachment)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (DisplayName = <span class="string">&quot;AttachActorToComponent&quot;</span>, ScriptName = <span class="string">&quot;AttachToComponent&quot;</span>, bWeldSimulatedBodies = <span class="literal">true</span>), Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AttachToComponent</span><span class="params">(USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, <span class="keyword">bool</span> bWeldSimulatedBodies)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_AttachToComponent 一致，FAttachmentTransformRules 只是包含了各种 Rule 参数的结构体 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AttachToComponent</span><span class="params">(USceneComponent* Parent, <span class="keyword">const</span> FAttachmentTransformRules&amp; AttachmentRules, FName SocketName = NAME_None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** DEPRECATED - 使用 AttachToActor() 代替 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.17</span>, <span class="string">&quot;Use AttachToActor() instead.&quot;</span>)</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (DisplayName = <span class="string">&quot;AttachRootComponentToActor (Deprecated)&quot;</span>, ScriptNoExport, AttachLocationType = <span class="string">&quot;KeepRelativeOffset&quot;</span>), Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AttachRootComponentToActor</span><span class="params">(AActor* InParentActor, FName InSocketName = NAME_None, EAttachLocation::Type AttachLocationType = EAttachLocation::KeepRelativeOffset, <span class="keyword">bool</span> bWeldSimulatedBodies = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将此 Actor的RootComponent 附加到提供的 Actor的RootComponent ，可以选择在命名套接字处</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param ParentActor 附着此 Actor 的根组件的 Actor</span></span><br><span class="line"><span class="comment">	 * @param AttachmentRules 如何附着时的变换和更改</span></span><br><span class="line"><span class="comment">	 * @param SocketName 附着到的套接字名称(可选)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AttachToActor</span><span class="params">(AActor* ParentActor, <span class="keyword">const</span> FAttachmentTransformRules&amp; AttachmentRules, FName SocketName = NAME_None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 AttachToActor 一致，只是将 AttachmentRules 拆开*/</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta = (DisplayName = <span class="string">&quot;AttachActorToActor&quot;</span>, ScriptName = <span class="string">&quot;AttachToActor&quot;</span>, bWeldSimulatedBodies=<span class="literal">true</span>), Category = <span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_AttachToActor</span><span class="params">(AActor* ParentActor, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, <span class="keyword">bool</span> bWeldSimulatedBodies)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用 AttachToComponent() 代替 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.17</span>, <span class="string">&quot;Use AttachToComponent() with EAttachLocation::SnapToTarget option instead&quot;</span>)</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DeprecatedFunction, DeprecationMessage = <span class="string">&quot;Use AttachRootComponentTo with EAttachLocation::SnapToTarget option instead&quot;</span>, DisplayName = <span class="string">&quot;SnapActorTo&quot;</span>, ScriptNoExport), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SnapRootComponentTo</span><span class="params">(AActor* InParentActor, FName InSocketName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** DEPRECATED - 使用 DetachFromActor() 代替 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.17</span>, <span class="string">&quot;Use DetachFromActor() instead&quot;</span>)</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;DetachActorFromActor (Deprecated)&quot;</span>, ScriptNoExport), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DetachRootComponentFromParent</span><span class="params">(<span class="keyword">bool</span> bMaintainWorldPosition = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 将此 actor 的根组件与其当前附加到的任何 SceneComponent 分离。</span></span><br><span class="line"><span class="comment">	 * @param LocationRule				附着时如何处理位置</span></span><br><span class="line"><span class="comment">	 * @param RotationRule				附着时如何处理旋转</span></span><br><span class="line"><span class="comment">	 * @param ScaleRule					附着时如何处理缩放</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DisplayName = <span class="string">&quot;DetachFromActor&quot;</span>, ScriptName = <span class="string">&quot;DetachFromActor&quot;</span>), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_DetachFromActor</span><span class="params">(EDetachmentRule LocationRule = EDetachmentRule::KeepRelative, EDetachmentRule RotationRule = EDetachmentRule::KeepRelative, EDetachmentRule ScaleRule = EDetachmentRule::KeepRelative)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 K2_DetachFromActor 一致，DetachmentRules 只是包含了三个 Rule 的结构体 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DetachFromActor</span><span class="params">(<span class="keyword">const</span> FDetachmentTransformRules&amp; DetachmentRules)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将此 actor 与其所有以给定 SceneComponent 为父组件的 SceneComponent 分离</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param InParentComponent 需要从此 actor 的组件中分离出来的 SceneComponent</span></span><br><span class="line"><span class="comment">	 * @param DetachmentRules 分离组件时应用的规则</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DetachAllSceneComponents</span><span class="params">(class USceneComponent* InParentComponent, <span class="keyword">const</span> FDetachmentTransformRules&amp; DetachmentRules)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 的标志数组中是否包含给定标志 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ActorHasTag</span><span class="params">(FName Tag)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~==============================================================================</span></span><br><span class="line">	<span class="comment">// Misc Blueprint support</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 获取 ActorTimeDilation - 这可用于 slomo 的输入控制或速度控制</span></span><br><span class="line"><span class="comment">	 * 我们不想缩放全局输入，因为输入可以用于UI，这是不需要考虑 TimeDilation 的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|Time&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetActorTimeDilation</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 更高效地，用于获取此 actor 在给定世界的 ActorTimeDilation 的函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetActorTimeDilation</span><span class="params">(<span class="keyword">const</span> UWorld&amp; ActorWorld)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 让此 actor 在 PrerequisiteActor 后 tick。这只应用于此 actor 的 tick 函数。如果需要，所属组件的依赖项必须单独设置 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddTickPrerequisiteActor</span><span class="params">(AActor* PrerequisiteActor)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 让此 actor 在 PrerequisiteComponent 后 tick。这只应用于此 actor 的 tick 函数。如果需要，所属组件的依赖项必须单独设置 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddTickPrerequisiteComponent</span><span class="params">(UActorComponent* PrerequisiteComponent)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 从 PrerequisiteActor 中移除 tick 依赖 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RemoveTickPrerequisiteActor</span><span class="params">(AActor* PrerequisiteActor)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 从 PrerequisiteComponent 中移除 tick 依赖 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RemoveTickPrerequisiteComponent</span><span class="params">(UActorComponent* PrerequisiteComponent)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 获取 此 actor 是否可以在游戏暂停时 tick */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">GetTickableWhenPaused</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置 此 actor 是否可以在游戏暂停时 tick */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetTickableWhenPaused</span><span class="params">(<span class="keyword">bool</span> bTickableWhenPaused)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 动态创建并设置材质实例，4.17版本后请调用 UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic() 代替 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.17</span>, <span class="string">&quot;Use UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic() instead.&quot;</span>)</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=(DeprecatedFunction, DeprecationMessage=<span class="string">&quot;Use PrimitiveComponent.CreateAndSetMaterialInstanceDynamic instead.&quot;</span>, BlueprintProtected = <span class="string">&quot;true&quot;</span>), Category=<span class="string">&quot;Rendering|Material&quot;</span>)</span><br><span class="line">	<span class="function">class UMaterialInstanceDynamic* <span class="title">MakeMIDForMaterial</span><span class="params">(class UMaterialInterface* Parent)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 自创建此 actor 以来的秒数 (以游戏时间为单位)，相对于获取游戏时间(以秒为单位) */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintPure, Category=Actor)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetGameTimeSinceCreation</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 游戏开始时，此 actor 执行的事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName = <span class="string">&quot;BeginPlay&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveBeginPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 游戏开始时，此 actor 执行的 可重载的本地事件 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 通知蓝图此 actor 正在被销毁，并从关卡中移除的事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(Keywords = <span class="string">&quot;delete&quot;</span>, DisplayName = <span class="string">&quot;End Play&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveEndPlay</span><span class="params">(EEndPlayReason::Type EndPlayReason)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 可重载的本地函数，当此 actor 被从关卡中移除时调用*/</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndPlay</span><span class="params">(<span class="keyword">const</span> EEndPlayReason::Type EndPlayReason)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 对该演员发起开始游戏调用，将按正确顺序处理调用。 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DispatchBeginPlay</span><span class="params">(<span class="keyword">bool</span> bFromLevelStreaming = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回此 actor 是否已初始化，以进行游戏 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsActorInitialized</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bActorInitialized; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回此 actor 是否正在调用 BeginPlay 函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsActorBeginningPlay</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ActorHasBegunPlay == EActorBeginPlayState::BeginningPlay; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回此 actor 是否已经调用过 BeginPlay 函数 (且没有调用 EndPlay 函数) */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">HasActorBegunPlay</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ActorHasBegunPlay == EActorBeginPlayState::HasBegunPlay; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 是否正在关卡流(包括关卡读取调用)时的 DispatchBeginPlay() 中调用 BeginPlay 函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsActorBeginningPlayFromLevelStreaming</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bActorBeginningPlayFromLevelStreaming; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 是否正在被销毁，一些游戏事件可能会不安全 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsActorBeingDestroyed</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bActorIsBeingDestroyed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**  此 actor 受到任何形式的伤害时触发的事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, BlueprintAuthorityOnly, meta=(DisplayName = <span class="string">&quot;AnyDamage&quot;</span>), Category=<span class="string">&quot;Game|Damage&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveAnyDamage</span><span class="params">(<span class="keyword">float</span> Damage, <span class="keyword">const</span> class UDamageType* DamageType, class AController* InstigatedBy, AActor* DamageCauser)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 此 actor 受到辐射型伤害时触发的事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, BlueprintAuthorityOnly, meta=(DisplayName = <span class="string">&quot;RadialDamage&quot;</span>), Category=<span class="string">&quot;Game|Damage&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveRadialDamage</span><span class="params">(<span class="keyword">float</span> DamageReceived, <span class="keyword">const</span> class UDamageType* DamageType, FVector Origin, <span class="keyword">const</span> struct FHitResult&amp; HitInfo, class AController* InstigatedBy, AActor* DamageCauser)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 受到点伤害时触发的事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, BlueprintAuthorityOnly, meta=(DisplayName = <span class="string">&quot;PointDamage&quot;</span>), Category=<span class="string">&quot;Game|Damage&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceivePointDamage</span><span class="params">(<span class="keyword">float</span> Damage, <span class="keyword">const</span> class UDamageType* DamageType, FVector HitLocation, FVector HitNormal, class UPrimitiveComponent* HitComponent, FName BoneName, FVector ShotFromDirection, class AController* InstigatedBy, AActor* DamageCauser, <span class="keyword">const</span> FHitResult&amp; HitInfo)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果启用 ticking，每帧触发该事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName = <span class="string">&quot;Tick&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveTick</span><span class="params">(<span class="keyword">float</span> DeltaSeconds)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 当此 actor 与另一个 actor 开始重叠时触发此事件，如: 玩家走进触发器</span></span><br><span class="line"><span class="comment">	 * 对于对象发生阻挡碰撞时的事件，如: 玩家被墙阻挡，请查看 &#x27;Hit&#x27; 事件</span></span><br><span class="line"><span class="comment">	 * @note 此 actor 和其他 actor，都必须将 bGenerateOverlapEvents 设为 true，才能触发重叠事件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NotifyActorBeginOverlap</span><span class="params">(AActor* OtherActor)</span></span>;</span><br><span class="line">	<span class="comment">/** 与 NotifyActorBeginOverlap 一致，此函数用于蓝图重载 &quot;重叠开始事件&quot; */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName = <span class="string">&quot;ActorBeginOverlap&quot;</span>), Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveActorBeginOverlap</span><span class="params">(AActor* OtherActor)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 当此 actor 不再与另一个 actor 重叠时调用此事件，他们已相互分离。</span></span><br><span class="line"><span class="comment">	 * @note 此 actor 和 其他 actor 都必须将 bGenerateOverlapEvents 设为 true 才能触发重叠事件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NotifyActorEndOverlap</span><span class="params">(AActor* OtherActor)</span></span>;</span><br><span class="line">	<span class="comment">/** 与 NotifyActorEndOverlap 一致，此函数用于蓝图重载 &quot;重叠结束事件&quot; */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName = <span class="string">&quot;ActorEndOverlap&quot;</span>), Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveActorEndOverlap</span><span class="params">(AActor* OtherActor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ........ 省略 光标略过，鼠标点击，点击释放，InputTouch 的本地事件与蓝图重载事件的函数声明 (1553行)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 返回正在与此 actor 重叠的 actors 列表(任何组件和组件的重叠)。不返回自己</span></span><br><span class="line"><span class="comment">     * @param OverlappingActors [输出] 返回重叠的 actors</span></span><br><span class="line"><span class="comment">     * @param ClassFilter [可选] 如果设置，只返回此类或其子类的 actor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Collision&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetOverlappingActors</span><span class="params">(TArray&lt;AActor*&gt;&amp; OverlappingActors, TSubclassOf&lt;AActor&gt; ClassFilter=<span class="literal">nullptr</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与上面的函数一样，但返回的 actors 是存在 TSet 里面的，蓝图不能调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetOverlappingActors</span><span class="params">(TSet&lt;AActor*&gt;&amp; OverlappingActors, TSubclassOf&lt;AActor&gt; ClassFilter=<span class="literal">nullptr</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回与此 actor 重叠的组件列表 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Collision&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetOverlappingComponents</span><span class="params">(TArray&lt;UPrimitiveComponent*&gt;&amp; OverlappingComponents)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 与上面的函数一样，但返回的组件是存在 TSet 里面的，蓝图不能调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetOverlappingComponents</span><span class="params">(TSet&lt;UPrimitiveComponent*&gt;&amp; OverlappingComponents)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 当 actor 碰撞到某个阻挡对象(或被某个阻挡事件碰撞)时触发的事件</span></span><br><span class="line"><span class="comment">	 * 这可能会因角色移动而触发，如果开启了使用扫描设置位置或物理模拟。</span></span><br><span class="line"><span class="comment">	 * 对于对象重叠的事件(如: 走进触发器)，请参考 &#x27;Overlap&#x27; 事件</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @note 要在物理模拟期间碰撞生成阻挡事件，必须启用 &#x27;Simulation Generates Hit Events&#x27; 项</span></span><br><span class="line"><span class="comment">	 * @note 从另一个对象的移动中接收到的阻挡事件时，将调整 &quot;Hit.Normal&quot; 和 &quot;Hit.ImpactNormal&quot; 的方向，以指示其他对象对该对象施加的力。</span></span><br><span class="line"><span class="comment">	 * @note 如果是与物理模拟体的碰撞，NormalImpluse 将被填充。如果是与扫描组件的碰撞，将为0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NotifyHit</span><span class="params">(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, <span class="keyword">bool</span> bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, <span class="keyword">const</span> FHitResult&amp; Hit)</span></span>;</span><br><span class="line">	<span class="comment">/** 与 NotifyHit 一致，用于蓝图重载碰撞事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName = <span class="string">&quot;Hit&quot;</span>), Category=<span class="string">&quot;Collision&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveHit</span><span class="params">(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, <span class="keyword">bool</span> bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, <span class="keyword">const</span> FHitResult&amp; Hit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 设置此 actor 的 lifespan。过期时，此对象将被销毁。如果将 lifespan 设置为0，则移除计时器，此 actor 不会被销毁 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;delete destroy&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLifeSpan</span><span class="params">( <span class="keyword">float</span> InLifespan )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取此 actor 剩余的 lifespan。如果返回0，此 actor 永存 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;delete destroy&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetLifeSpan</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 构造函数脚本，生成组件的地方，并做其他设置 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(BlueprintInternalUseOnly = <span class="string">&quot;true&quot;</span>, DisplayName = <span class="string">&quot;Construction Script&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UserConstructionScript</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 销毁此 actor。如果此 actor 已被销毁，或被标记为 destruction (以调用析构函数)，返回 true。不可析构返回 false</span></span><br><span class="line"><span class="comment">	 * 析构是潜在的，在 tick 末尾执行</span></span><br><span class="line"><span class="comment">	 * @param	bNetForce				[可选] 是否忽略非游戏期间的调用，默认为false</span></span><br><span class="line"><span class="comment">	 * @param	bShouldModifyLevel		[可选] 如果为真，在移除 actor 前会调用关卡的 Modify()。默认为 true</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Destroy</span><span class="params">(<span class="keyword">bool</span> bNetForce = <span class="literal">false</span>, <span class="keyword">bool</span> bShouldModifyLevel = <span class="literal">true</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当此 actor 被显示销毁时调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta = (Keywords = <span class="string">&quot;delete&quot;</span>, DisplayName = <span class="string">&quot;Destroyed&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveDestroyed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此 actor 被显示销毁时触发事件 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">	FActorDestroyedSignature OnDestroyed;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此 actor 从关卡中被删除或移除时触发该事件 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category=<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">	FActorEndPlaySignature OnEndPlay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~ Begin UObject Interface</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CheckDefaultSubobjectsInternal</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostInitProperties</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ProcessEvent</span><span class="params">( UFunction* Function, <span class="keyword">void</span>* Parameters )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> int32 <span class="title">GetFunctionCallspace</span><span class="params">( UFunction* Function, FFrame* Stack )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CallRemoteFunction</span><span class="params">( UFunction* Function, <span class="keyword">void</span>* Parameters, FOutParmRec* OutParms, FFrame* Stack )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(FArchive&amp; Ar)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostLoad</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostLoadSubobjects</span><span class="params">( FObjectInstancingGraph* OuterInstanceGraph )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginDestroy</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsReadyForFinishDestroy</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Rename</span><span class="params">( <span class="keyword">const</span> TCHAR* NewName=<span class="literal">nullptr</span>, UObject* NewOuter=<span class="literal">nullptr</span>, ERenameFlags Flags=REN_None )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostRename</span><span class="params">( UObject* OldOuter, <span class="keyword">const</span> FName OldName )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanBeInCluster</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddReferencedObjects</span><span class="params">(UObject* InThis, FReferenceCollector&amp; Collector)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsEditorOnly</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsAsset</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">PreSaveRoot</span><span class="params">(<span class="keyword">const</span> TCHAR* InFilename)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostSaveRoot</span><span class="params">(<span class="keyword">bool</span> bCleanupIsRequired)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// ....... 省略部分编辑器模式下的函数 (1702行)</span></span><br><span class="line">	<span class="comment">//~ End UObject Interface</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Property Replication</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 填充 ReplicatedMovement 属性 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GatherCurrentMovement</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 是否被传入的 actor 拥有 */</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsOwnedBy</span><span class="params">( <span class="keyword">const</span> AActor* TestOwner )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">const</span> AActor* Arg=<span class="keyword">this</span>; Arg; Arg=Arg-&gt;Owner )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( Arg == TestOwner )</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 的根组件 */</span></span><br><span class="line">	<span class="function">FORCEINLINE USceneComponent* <span class="title">GetRootComponent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> RootComponent; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 的默认附着组件，用于附着子组件 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> USceneComponent* <span class="title">GetDefaultAttachComponent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetRootComponent</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将特定组件设置为根组件，传入的组件的所有者(owner)，必须是此actor。设置成功返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetRootComponent</span><span class="params">(USceneComponent* NewRootComponent)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 Actor 根组件的变换 */</span> </span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">const</span> FTransform&amp; <span class="title">GetActorTransform</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">TemplateGetActorTransform</span>(RootComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 根组件的位置 */</span> </span><br><span class="line">	<span class="function">FORCEINLINE FVector <span class="title">GetActorLocation</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">TemplateGetActorLocation</span>(RootComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 根组件的旋转*/</span> </span><br><span class="line">	<span class="function">FORCEINLINE FRotator <span class="title">GetActorRotation</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">TemplateGetActorRotation</span>(RootComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 根组件的缩放 */</span> </span><br><span class="line">	<span class="function">FORCEINLINE FVector <span class="title">GetActorScale</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">TemplateGetActorScale</span>(RootComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 根组件的四元数*/</span></span><br><span class="line">	<span class="function">FORCEINLINE FQuat <span class="title">GetActorQuat</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">TemplateGetActorQuat</span>(RootComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Relations</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 由拥有此 actor 的关卡调用，以特定的增量移动此 actor 的位置和相关的数据结构</span></span><br><span class="line"><span class="comment">	 *  </span></span><br><span class="line"><span class="comment">	 * @param InOffset		用于移动 actor 位置的偏移向量</span></span><br><span class="line"><span class="comment">	 * @param bWorldShift	此调用是否为整个世界移动的一部分</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ApplyWorldOffset</span><span class="params">(<span class="keyword">const</span> FVector&amp; InOffset, <span class="keyword">bool</span> bWorldShift)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 指示此 actor 是否应参与关卡边界计算 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsLevelBoundsRelevant</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bRelevantForLevelBounds; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 为所有组件设置 LOD 父组件，通常与一个 ALODActor 关联</span></span><br><span class="line"><span class="comment">	 * @param InLODParent 此组件用于 (启用分级LOD时) 计算可见性</span></span><br><span class="line"><span class="comment">	 * @param InParentDrawDistance 更新 LOD 父组件的最小绘制距离</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetLODParent</span><span class="params">(class UPrimitiveComponent* InLODParent, <span class="keyword">float</span> InParentDrawDistance)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用于决定网络复制优先级的函数</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param ViewPos		观察者的位置(如: 根据与玩家的位置决定是否复制此 actor)</span></span><br><span class="line"><span class="comment">	 * @param ViewDir		观察者面朝方向的向量</span></span><br><span class="line"><span class="comment">	 * @param Viewer		设置了网络优先级的，客户端拥有的网络对象(通常为 PlayerController 类型)</span></span><br><span class="line"><span class="comment">	 * @param ViewTarget	当前被Viewer观察/控制的actor，通常是一个 Pawn</span></span><br><span class="line"><span class="comment">	 * @param InChannel		此 actor 被复制的通道 (通过PlayerController建立)</span></span><br><span class="line"><span class="comment">	 * @param Time			距离上次复制此 actor 经过的时间</span></span><br><span class="line"><span class="comment">	 * @param bLowBandwidth 观察者是否带宽较低</span></span><br><span class="line"><span class="comment">	 * @return				此 actor 网络复制的优先级，越大越重要，优先级也越高</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetNetPriority</span><span class="params">(<span class="keyword">const</span> FVector&amp; ViewPos, <span class="keyword">const</span> FVector&amp; ViewDir, class AActor* Viewer, AActor* ViewTarget, UActorChannel* InChannel, <span class="keyword">float</span> Time, <span class="keyword">bool</span> bLowBandwidth)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 模拟 GetNetPriority，但只用于录制重播时对 actor 进行优先级排序 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetReplayPriority</span><span class="params">(<span class="keyword">const</span> FVector&amp; ViewPos, <span class="keyword">const</span> FVector&amp; ViewDir, class AActor* Viewer, AActor* ViewTarget, UActorChannel* <span class="keyword">const</span> InChannel, <span class="keyword">float</span> Time)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 是否应该在特定的网络连接中休眠。只检查 DORM_DormantPartial */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">GetNetDormancy</span><span class="params">(<span class="keyword">const</span> FVector&amp; ViewPos, <span class="keyword">const</span> FVector&amp; ViewDir, class AActor* Viewer, AActor* ViewTarget, UActorChannel* InChannel, <span class="keyword">float</span> Time, <span class="keyword">bool</span> bLowBandwidth)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 当 actor 通道打开时(客户端)，允许 actor 做出特定响应</span></span><br><span class="line"><span class="comment">	 * @param InBunch 通道打开时接收到的束(可以理解为较小的网络包)</span></span><br><span class="line"><span class="comment">	 * @param Connection 与此 actor 关联的 connection (连接，只有PlayerController可以发起)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnActorChannelOpen</span><span class="params">(class FInBunch&amp; InBunch, class UNetConnection* Connection)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 由网络连接使用，用于确定网络拥有的 此actor 是否应切换到使用缩短的超时值</span></span><br><span class="line"><span class="comment">	 * @return 如果在网络驱动中，从 InitialConnectTimeout 切换到 ConnectionTimeout 值，则返回真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">UseShortConnectTimeout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * SerializeNewActor 只在网络复制前，由自身调用(服务器端)</span></span><br><span class="line"><span class="comment">	 * @param OutBunch 在复制之前包含 actor 的序列化内容的束</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSerializeNewActor</span><span class="params">(class FOutBunch&amp; OutBunch)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 在连接被杀死时，清除相关的Actor</span></span><br><span class="line"><span class="comment">	 * @param Connection 与此 actor 关联的 connection</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNetCleanup</span><span class="params">(class UNetConnection* Connection)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 交换 Role 和 RemoteRole，如果是客户端 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ExchangeNetRoles</span><span class="params">(<span class="keyword">bool</span> bRemoteOwner)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 调用此函数交换 Role 和 RemoteRole。请慎重使用！ */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SwapRoles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调用后，将调用虚函数调用链以注册所有的 tick 函数，包括此 actor 和可选的所有组件</span></span><br><span class="line"><span class="comment">	 * 不要重载此函数，或将其改为虚函数</span></span><br><span class="line"><span class="comment">	 * @param bRegister - true 用于注册，false 用于注销</span></span><br><span class="line"><span class="comment">	 * @param bDoComponents - 是否将此变化应用到所有组件中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegisterAllActorTickFunctions</span><span class="params">(<span class="keyword">bool</span> bRegister, <span class="keyword">bool</span> bDoComponents)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 启用/禁用 此 actor 的 tick 函数。只有在函数被注册后才有效</span></span><br><span class="line"><span class="comment">	 * 这只改变此 actor 自身的 tick 函数</span></span><br><span class="line"><span class="comment">	 * @param	bEnabled	是否启用 tick 函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorTickEnabled</span><span class="params">(<span class="keyword">bool</span> bEnabled)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**  此 actor 是否启用 tick 函数 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsActorTickEnabled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 设置此 actor 的主要 tick 函数的时间间隔，不会启用已禁用的 tick 函数。将在下一帧生效</span></span><br><span class="line"><span class="comment">	 * @param TickInterval	此 actor 的 tick 速率</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorTickInterval</span><span class="params">(<span class="keyword">float</span> TickInterval)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 返回此 actor 的主要 tick 函数的 tick 时间间隔 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetActorTickInterval</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 为此 actor 分配每帧执行一次的 tick 函数</span></span><br><span class="line"><span class="comment">	 * @param	DeltaTime			此 tick 的时间片</span></span><br><span class="line"><span class="comment">	 * @param	TickType			正在发生的 tick 的类型</span></span><br><span class="line"><span class="comment">	 * @param	ThisTickFunction	正在允许的 tick 函数，用于获取已完成的句柄</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TickActor</span><span class="params">( <span class="keyword">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当一个 actor 被生成到世界中时(从 UWorld::SpawnActor 中)调用，编辑器或者进行游戏时都会调用</span></span><br><span class="line"><span class="comment">	 * 对于有根组件的 actors，其位置和旋转值都会被设置</span></span><br><span class="line"><span class="comment">	 * 此函数会在构造脚本前，本地组件被创建后调用。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostActorCreated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当 actor 的 lifespan 到期时调用 (如果有) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LifeSpanExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 接收到远端的属性前，总是立即调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PreNetReceive</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 接收到远端的属性后，总是立即调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostNetReceive</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 接收到远端的新 Role 时，总是立即调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostNetReceiveRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** IsNameStableForNetworking 意味着对象可以通过网络使用其路径名(相对于outer的)来对其进行引用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsNameStableForNetworking</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** IsSupportedForNetworking 意味着对象可以通过网络来引用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsSupportedForNetworking</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回用于网络的，有 stable name 的子对象列表 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetSubobjectsWithStableNamesForNetworking</span><span class="params">(TArray&lt;UObject*&gt; &amp;ObjList)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在生成和读取复制的属性后，总是立即调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostNetInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** ReplicatedMovement 结构体复制事件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRep_ReplicatedMovement</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 从 ReplicatedMovement 中更新位置和旋转。模拟物理不调用！ */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostNetReceiveLocationAndRotation</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 更新速度，通常来自 ReplicatedMovenent，模拟物理不调用！ */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostNetReceiveVelocity</span><span class="params">(<span class="keyword">const</span> FVector&amp; NewVelocity)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 更新并平滑处理模拟物理状态，替代 PostNetReceiveLocation 和 PostNetReceiveVelocity 函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostNetReceivePhysicState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 将 IsSimulatingPhysics() 和 ReplicatedMovement.bRepPhysics 同步 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SyncReplicatedPhysicsSimulation</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 设置此 actor 的 owner，主要用于网络复制 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=Actor)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetOwner</span><span class="params">( AActor* NewOwner )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取此 actor 的 owner，主要用于网络复制 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=Actor)</span><br><span class="line">	<span class="function">AActor* <span class="title">GetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 模板版本的 GetOwner()，转换失败返回 nullptr */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt; class T &gt;</span></span><br><span class="line"><span class="function">	T* <span class="title">GetOwner</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cast&lt;T&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 检查此 actor 是否仍存在此世界中，这将检查并处理 KillZ，外部世界边界等情况 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CheckStillInWorld</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Actor overlap tracking</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调用此 actor 的所有 PrimitiveComponents 的所有 EndOverlap 事件</span></span><br><span class="line"><span class="comment">	 * 通常在 将 Actor 从世界中移除时 调用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ClearComponentOverlaps</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 查询世界，并更新此 actor 的重叠检测状态</span></span><br><span class="line"><span class="comment">	 * @param bDoNotifies		是否调用 正在进行/结束 重叠的通知，如果这些事件发生</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateOverlaps</span><span class="params">(<span class="keyword">bool</span> bDoNotifies=<span class="literal">true</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 检查此 actor 是否有任何组件正在于另一个 actor 的任何组件发生重叠</span></span><br><span class="line"><span class="comment">	 * @param Other 另一个要测试的 actor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Collision&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsOverlappingActor</span><span class="params">(<span class="keyword">const</span> AActor* Other)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回当前是否有一个 MatineeActor 控制此 Actor */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsMatineeControlled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根组件的 ModifyFrequency 是否为 MF_Static */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsRootComponentStatic</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 根组件的 Mobility 是否为 EComponentMobility::Stationary */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsRootComponentStationary</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 根组件的 Mobility 是否为 EComponentMobility::Movable */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsRootComponentMovable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Actor ticking</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** bCanEverTick 值的访问器 */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">CanEverTick</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> PrimaryActorTick.bCanEverTick; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 *	每帧调用的函数，重载此函数以实现每帧执行的自定义逻辑</span></span><br><span class="line"><span class="comment">	 *	注意，tick 是默认不开启的，你需要将 PrimaryActorTick.bCanEverTickNote 设置为真，才能启用 tick</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	@param	DeltaSeconds 在时间膨胀修改的最后一帧中经过的游戏时间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span><span class="params">( <span class="keyword">float</span> DeltaSeconds )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** If true, actor is ticked even if TickType==LEVELTICK_ViewportsOnly	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldTickIfViewportsOnly</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Actor relevancy determination</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 决定此 actor 的位置和给定 SrcLocation 是否仍在网络复制的可接受范围内(称之为: 网络相关距离(net relevancy distance))，距离之外将不再复制。</span></span><br><span class="line"><span class="comment">	 * @param SrcLocation	要测试的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsWithinNetRelevancyDistance</span><span class="params">(<span class="keyword">const</span> FVector&amp; SrcLocation)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 检查此 actor 是否与特定的网络连接相关(不相关则不复制)</span></span><br><span class="line"><span class="comment">	 * @param RealViewer - 控制网络对象，与(会检查网络相关性的)客户端关联 (通常是 PlayerController)</span></span><br><span class="line"><span class="comment">	 * @param ViewTarget - 正真用于观察的 actor，通常是 pawn 对象</span></span><br><span class="line"><span class="comment">	 * @param SrcLocation - 观察位置</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return bool - 如果此 actor 与客户端的真实观察者相关(未超出网络相关距离)，则返回true</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsNetRelevantFor</span><span class="params">(<span class="keyword">const</span> AActor* RealViewer, <span class="keyword">const</span> AActor* ViewTarget, <span class="keyword">const</span> FVector&amp; SrcLocation)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 &quot;IsNetRelevantFor&quot;，此函数仅用于录制网络重播 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsReplayRelevantFor</span><span class="params">(<span class="keyword">const</span> AActor* RealViewer, <span class="keyword">const</span> AActor* ViewTarget, <span class="keyword">const</span> FVector&amp; SrcLocation, <span class="keyword">const</span> <span class="keyword">float</span> CullDistanceSquared)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查此 actor 是否为 owner，标记为 bOnlyRelevantToOwner 的 actors 进行网络相关性检查时使用</span></span><br><span class="line"><span class="comment">	 * @param ReplicatedActor - 正在进行网络相关性测试的 actor </span></span><br><span class="line"><span class="comment">	 * @param ActorOwner - ReplicatedActor 的 owner</span></span><br><span class="line"><span class="comment">	 * @param ConnectionActor - 正在进行相关性测试的连接的 controller</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return 如果此 actor 为 ReplicatedActor 的 owner，则返回真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsRelevancyOwnerFor</span><span class="params">(<span class="keyword">const</span> AActor* ReplicatedActor, <span class="keyword">const</span> AActor* ActorOwner, <span class="keyword">const</span> AActor* ConnectionActor)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在 actor 被生成到世界后调用，负责设置好用于游戏的 actor */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostSpawnInitialize</span><span class="params">(FTransform <span class="keyword">const</span>&amp; SpawnTransform, AActor* InOwner, APawn* InInstigator, <span class="keyword">bool</span> bRemoteOwned, <span class="keyword">bool</span> bNoFail, <span class="keyword">bool</span> bDeferConstruction)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 调用以完成生成程序，通常用于延迟生成的情况 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FinishSpawning</span><span class="params">(<span class="keyword">const</span> FTransform&amp; Transform, <span class="keyword">bool</span> bIsDefaultTransform = <span class="literal">false</span>, <span class="keyword">const</span> FComponentInstanceDataCache* InstanceDataCache = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在 actor 调用其构造函数后调用，负责结束 actor 的生成程序 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostActorConstruction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 在组件被初始化前调用，只在游戏期间调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PreInitializeComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 允许 actors 在C++端初始化其自身，在其所有组件都被初始化后执行。只在游戏期间调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostInitializeComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加一个控制 matinee actor，用于 natinee 回滚</span></span><br><span class="line"><span class="comment">	 * @param InMatineeActor	控制此 actor 的 matinee actor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddControllingMatineeActor</span><span class="params">( AMatineeActor&amp; InMatineeActor )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 移除一个控制 matinee actor</span></span><br><span class="line"><span class="comment">	 * @param InMatineeActor	当前控制此 actor 的 matinee actor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveControllingMatineeActor</span><span class="params">( AMatineeActor&amp; InMatineeActor )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 执行 ReceiveHit 虚函数和 OnComponentHit 代理 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DispatchPhysicsCollisionHit</span><span class="params">(<span class="keyword">const</span> struct FRigidBodyCollisionInfo&amp; MyInfo, <span class="keyword">const</span> struct FRigidBodyCollisionInfo&amp; OtherInfo, <span class="keyword">const</span> FCollisionImpactData&amp; RigidCollisionData)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 返回负责复制的 actor，如果有。通常是 Player Controller 类型 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> AActor* <span class="title">GetNetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 所属的 UPlayer(如果有)。这将是一个本地玩家，一个网络连接，或者空指针 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> class UPlayer* <span class="title">GetNetOwningPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 获取所属的连接，用于客户端和服务端的通信</span></span><br><span class="line"><span class="comment">	 * @return 此 actor 客户端或服务端的网络连接</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> class UNetConnection* <span class="title">GetNetConnection</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 由 DestroyActor() 调用，提供一个外部定义部分析构函数的机会。</span></span><br><span class="line"><span class="comment">	 * 用于网络代码，以便优先处理网络连接超时/清理</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return 如果DestroyActor() 不应继续执行 actor 析构，则为true，否则为false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">DestroyNetworkActorHandled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取此 actor 的网络模式(独立服务器，客户端，独立窗口等)</span></span><br><span class="line"><span class="comment">	 * @see IsNetMode()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ENetMode <span class="title">GetNetMode</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试此 actor 的网络模式是否为给定模式</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 在优化的非编辑器构建中，这可能比 GetNetMode() 更有效</span></span><br><span class="line"><span class="comment">	 * 因为它可以在不考虑 PIE 的情况下检查静态构建标志</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsNetMode</span><span class="params">(ENetMode Mode)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 绑定的网络驱动，可能为空 */</span></span><br><span class="line">	<span class="function">class UNetDriver* <span class="title">GetNetDriver</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将此 actor 放入休眠网络状态 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintAuthorityOnly, BlueprintCallable, Category = <span class="string">&quot;Networking&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetNetDormancy</span><span class="params">(ENetDormancy NewDormancy)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 强制休眠 actor 进行复制，但不改变休眠状态 (即: 如果处于休眠状态，他们将继续休眠) */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintAuthorityOnly, BlueprintCallable, Category=<span class="string">&quot;Networking&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FlushNetDormancy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 强制此 actor 的属性为一帧做一次比较(而不是共享阴影状态) */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ForcePropertyCompare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 是否由一个 ChildActorComponent 生成 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Actor&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsChildActor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 返回所有由我们的 ChildActorComponents 生成的 actors 的列表(包括孩子的孩子)</span></span><br><span class="line"><span class="comment">	 * 这不会返回 Children 数组中的内容</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Actor&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetAllChildActors</span><span class="params">(TArray&lt;AActor*&gt;&amp; ChildActors, <span class="keyword">bool</span> bIncludeDescendants = <span class="literal">true</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果此 Actor 被一个 ChildActorComponent 所创建，返回那个 ChildActorComponent */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Actor&quot;</span>)</span><br><span class="line">	<span class="function">UChildActorComponent* <span class="title">GetParentComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果此 Actor 被一个 ChildActorComponent 所创建，返回拥有那个 ChildActorComponent 的 Actor */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Actor&quot;</span>)</span><br><span class="line">	<span class="function">AActor* <span class="title">GetParentActor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 确保所有 Components 数组里面的组件都已被注册 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RegisterAllComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在 Components 数组中的所有组件被注册前调用，编辑器和游戏期间都会调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PreRegisterAllComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在 Components 数组中的所有组件被注册后调用，编辑器和游戏期间都会调用*/</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostRegisterAllComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果 Actor 在生成时，延迟调用 RegisterAllComponents()，则返回真 (如: 挂起蓝图SCS执行以设置场景根组件) */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">HasDeferredComponentRegistration</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bHasDeferredComponentRegistration; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果此 actor 有一个已注册的根组件则返回 true */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">HasValidRootComponent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 注销所有当前注册的组件</span></span><br><span class="line"><span class="comment">	 * @param bForReregister 如果为真，RegisterAllComponents 在此函数调用后立即调用，以避免一些缓慢的操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UnregisterAllComponents</span><span class="params">(<span class="keyword">bool</span> bForReregister = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在所有当前已注册的组件被清除后调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostUnregisterAllComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 将重新注册此 actor 上的所有组件。</span></span><br><span class="line"><span class="comment">	 * 做了很多工作-应该只在编辑器中使用，通常使用UpdateComponentTransforms或MarkComponentResendentStateDirty </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ReregisterAllComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 立即注册与此 actor 关联的组件，在关卡流期间使用</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param NumComponentsToRegister  此次执行应该注册的组件的数量，0表示全部</span></span><br><span class="line"><span class="comment">	 * @return 当此 actor 的所有组件都被注册时，返回真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IncrementalRegisterComponents</span><span class="params">(int32 NumComponentsToRegister, FRegisterComponentContext* Context = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将所有组件的渲染状态标志为脏 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MarkComponentsRenderStateDirty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 更新所有组件的变化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateComponentTransforms</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 完全迭代 components 数组，并调用 InitializeComponent (每个 actor 只会执行一次) */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InitializeComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 完全迭代 components 数组，并调用 UnInitializeComponent，此 actor 结束游戏时调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UninitializeComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 调试渲染，以可视化此 actor 的组件树 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DrawDebugComponents</span><span class="params">(FColor <span class="keyword">const</span>&amp; BaseColor=FColor::White)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此 actor 将被销毁时，调用此函数以将所有组件标记为 pendingkill */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MarkComponentsAsPendingKill</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果此 actor 开始析构则返回真</span></span><br><span class="line"><span class="comment">	 * 这将在 UWorld::DestroyActor 函数中被设为真，在网络连接关闭后，但所有其他关闭被执行前</span></span><br><span class="line"><span class="comment">	 * @return 如果此 actor 已开始析构，或此 actor 已经被销毁时，返回真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsPendingKillPending</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bActorIsBeingDestroyed || <span class="built_in">IsPendingKill</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使默认选择的光照缓存失效 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InvalidateLightingCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (GIsEditor &amp;&amp; !GIsDemoMode)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InvalidateLightingCacheDetailed</span>(<span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 使上次构建照明时生成的所有东西全部失效 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InvalidateLightingCacheDetailed</span><span class="params">(<span class="keyword">bool</span> bTranslationOnly)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用于将 actors 添加到关卡中，或将他们传送到新的位置</span></span><br><span class="line"><span class="comment">	 * 此函数的结果依赖于此 actor 的当前位置和旋转</span></span><br><span class="line"><span class="comment">	 * 如果此 actor 不完全适合指定的位置，则尝试将其稍微移出墙壁 (如果 bNoCheck 为 false)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param DestLocation 目标终点</span></span><br><span class="line"><span class="comment">	 * @param DestRotation 在终点的目标旋转值</span></span><br><span class="line"><span class="comment">	 * @param bIsATest 如果这是一个测试移动(不触发任何通知，用于AI寻路等)，则为真</span></span><br><span class="line"><span class="comment">	 * @param bNoCheck 如果不检查世界或其他 actor 是否受到侵犯(不合适的位置，如: 被重叠等)，则为真</span></span><br><span class="line"><span class="comment">	 * @return 如果此 actor 被成功移动则返回真，无法适配则返回假</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">TeleportTo</span><span class="params">( <span class="keyword">const</span> FVector&amp; DestLocation, <span class="keyword">const</span> FRotator&amp; DestRotation, <span class="keyword">bool</span> bIsATest=<span class="literal">false</span>, <span class="keyword">bool</span> bNoCheck=<span class="literal">false</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与 TeleportTo 一致，此函数用于蓝图调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, meta=( DisplayName=<span class="string">&quot;Teleport&quot;</span>, ScriptName=<span class="string">&quot;Teleport&quot;</span>, Keywords = <span class="string">&quot;Move Position&quot;</span> ), Category=<span class="string">&quot;Utilities|Transformation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">K2_TeleportTo</span><span class="params">( FVector DestLocation, FRotator DestRotation )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在 TeleportTo 中调用，如果传送成功 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TeleportSucceeded</span><span class="params">(<span class="keyword">bool</span> bIsATest)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在该角色的组件上追踪一条光线，并返回第一次阻挡命中</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param  OutHit          找到的第一次阻挡命中</span></span><br><span class="line"><span class="comment">	 * @param  Start           此光线的开始位置</span></span><br><span class="line"><span class="comment">	 * @param  End             此光线的结束位置</span></span><br><span class="line"><span class="comment">	 * @param  TraceChannel    此光线所在通道，用于决定哪些组件会被命中</span></span><br><span class="line"><span class="comment">	 * @param  Params          此追踪的额外参数</span></span><br><span class="line"><span class="comment">	 * @return 如果阻挡命中被找到，返回真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ActorLineTraceSingle</span><span class="params">(struct FHitResult&amp; OutHit, <span class="keyword">const</span> FVector&amp; Start, <span class="keyword">const</span> FVector&amp; End, ECollisionChannel TraceChannel, <span class="keyword">const</span> struct FCollisionQueryParams&amp; Params)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 获取与最近的身体实例表面的距离</span></span><br><span class="line"><span class="comment">	 * 检查此 actor 的所有组件是否具有有效的碰撞和阻挡 TraceChannel(追踪通道)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param Point						世界 3D 向量</span></span><br><span class="line"><span class="comment">	 * @param TraceChannel				决定哪些组件将被考虑的通道</span></span><br><span class="line"><span class="comment">	 * @param ClosestPointOnCollision	碰撞体的表面中，离 Point 最近的点</span></span><br><span class="line"><span class="comment">	 * @param OutPrimitiveComponent		碰撞体的 PrimitiveComponent</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @return 如果返回值大于0为成功。等于0表示点就在其内部，小于0表示此 actor 没有任何碰撞组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">ActorGetDistanceToCollision</span><span class="params">(<span class="keyword">const</span> FVector&amp; Point, ECollisionChannel TraceChannel, FVector&amp; ClosestPointOnCollision, UPrimitiveComponent** OutPrimitiveComponent = <span class="literal">nullptr</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果此 actor 在 TestLevel 中，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsInLevel</span><span class="params">(<span class="keyword">const</span> class ULevel *TestLevel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 Actor 所在的 ULevel */</span></span><br><span class="line">	<span class="function">ULevel* <span class="title">GetLevel</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**	做 清除跨关卡引用 所需要做的任何事情，被 ULevel::PreSave 调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ClearCrossLevelReferences</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 非虚函数，用于评估每个 actor 应执行其 EndPlay 中的哪一部分 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RouteEndPlay</span><span class="params">(<span class="keyword">const</span> EEndPlayReason::Type EndPlayReason)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 向上迭代移动基链以查看此 actor 是否基于给定的 actor，默认为检查附件(附加的组件和Actor) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsBasedOnActor</span><span class="params">(<span class="keyword">const</span> AActor* Other)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 向上迭代附着基链以查看此 actor 是否附着于给定 actor */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsAttachedTo</span><span class="params">( <span class="keyword">const</span> AActor* Other )</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取在编辑器中放置此角色时使用的空间大小，用于 &quot;回退&quot; 命中 */</span></span><br><span class="line">	<span class="function">FVector <span class="title">GetPlacementExtent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Blueprint</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将私有属性重置为默认值，并将此 Actor 中的所有 FRandomStream 结构重置为默认值 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ResetPropertiesForConstruction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 重新运行构造脚本，销毁所有自动生成的组件；将尝试保留根组件位置*/</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RerunConstructionScripts</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 调试辅助函数，用于显示此 actor 的组件层次结构</span></span><br><span class="line"><span class="comment">	 * @param Info			显示在信息顶部的可选字符串</span></span><br><span class="line"><span class="comment">	 * @param bShowPosition	如果为真，将显示组件在世界空间的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DebugShowComponentHierarchy</span><span class="params">( <span class="keyword">const</span> TCHAR* Info, <span class="keyword">bool</span> bShowPosition  = <span class="literal">true</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 调试辅助函数，用于显示一个组件的组件层级结构 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DebugShowOneComponentHierarchy</span><span class="params">( USceneComponent* SceneComp, int32&amp; NestLevel, <span class="keyword">bool</span> bShowPosition )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行此 actor 的所有构造脚本，将调用 OnConstruction</span></span><br><span class="line"><span class="comment">	 * @param	Transform			将 actor 构造在什么变换(位置，旋转，缩放)中</span></span><br><span class="line"><span class="comment">	 * @param   TransformRotationCache 可选的旋转值缓存，应用变换时使用</span></span><br><span class="line"><span class="comment">	 * @param	InstanceDataCache	可选的状态缓存，应用于新创建的组件(如: 预计算光照)</span></span><br><span class="line"><span class="comment">	 * @param	bIsDefaultTransform	在可被模板默认值重写的情况下，给定的变换是否为默认变换</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return 如果层次结构有错误，我们将把 actor 设置为灾难恢复模式，并返回 false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ExecuteConstruction</span><span class="params">(<span class="keyword">const</span> FTransform&amp; Transform, <span class="keyword">const</span> struct FRotationConversionCache* TransformRotationCache, <span class="keyword">const</span> class FComponentInstanceDataCache* InstanceDataCache, <span class="keyword">bool</span> bIsDefaultTransform = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此类的一个实例被放置(编辑器中)，或生成时调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnConstruction</span><span class="params">(<span class="keyword">const</span> FTransform&amp; Transform)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 辅助函数，用于注册特定的组件，并将其添加到特定的组件数组中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">FinishAndRegisterComponent</span><span class="params">(UActorComponent* Component)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 基于模板创建组件 */</span></span><br><span class="line">	<span class="function">UActorComponent* <span class="title">CreateComponentFromTemplate</span><span class="params">(UActorComponent* Template, <span class="keyword">const</span> FName InName = NAME_None )</span></span>;</span><br><span class="line">	<span class="function">UActorComponent* <span class="title">CreateComponentFromTemplateData</span><span class="params">(<span class="keyword">const</span> struct FBlueprintCookedComponentInstancingData* TemplateData, <span class="keyword">const</span> FName InName = NAME_None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 销毁已构造的组件 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DestroyConstructedComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 虚函数调用链，用于为此 actor 类的继承结构注册所有tick函数</span></span><br><span class="line"><span class="comment">	 * @param bRegister - 如果是注册则为 true，注销则为 false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RegisterActorTickFunctions</span><span class="params">(<span class="keyword">bool</span> bRegister)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 执行 UserConstructionScript(用户构造函数脚本)，延迟组件注册直至其完成 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ProcessUserConstructionScript</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 检查在 AActor 中实现的组件的有效性 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">CheckActorComponents</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 从模板或已烘培的数据中实例化一个新蓝图组件后调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostCreateBlueprintComponent</span><span class="params">(UActorComponent* NewActorComp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 在实例化新蓝图组件前，检查并解决任何名称冲突 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CheckComponentInstanceName</span><span class="params">(<span class="keyword">const</span> FName InName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 从根组件开始沿着附着链走，直至我们我们遇到一个不同的 actor，返回它</span></span><br><span class="line"><span class="comment">	 * 如果我们被附着到另一个 actor 的组件中，则返回 nullptr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintPure, Category = <span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function">AActor* <span class="title">GetAttachParentActor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 从根组件开始沿着附着链走，直至我们我们遇到一个不同的 actor，返回附着此 actor 的组件的插槽名</span></span><br><span class="line"><span class="comment">     * 如果我们被附着到另一个 actor 的组件中，则返回 NAME_None</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintPure, Category = <span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function">FName <span class="title">GetAttachParentSocketName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 为附着在此 actor 的组件上的所有 actors 调用一个函子。函子应返回 true 以继续，返回 false 以中止 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ForEachAttachedActors</span><span class="params">(TFunctionRef&lt;<span class="keyword">bool</span>(class AActor*)&gt; Functor)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 获取所有直接附着到此 actor 的组件上的 actors */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintPure, Category = <span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetAttachedActors</span><span class="params">(TArray&lt;AActor*&gt;&amp; OutActors, <span class="keyword">bool</span> bResetArray = <span class="literal">true</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 为此 actor 设置 ticking 组 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetTickGroup</span><span class="params">(ETickingGroup NewTickGroup)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当此 actor 在游戏时或编辑器中被现实销毁时调用，在关卡流或游戏结束时不调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Destroyed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 调用 ReceiveHit 以及 actor 和组件中的代理 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DispatchBlockingHit</span><span class="params">(UPrimitiveComponent* MyComp, UPrimitiveComponent* OtherComp, <span class="keyword">bool</span> bSelfMoved, FHitResult <span class="keyword">const</span>&amp; Hit)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此 actor 安全脱离世界时调用 (below KillZ and such) */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">FellOutOfWorld</span><span class="params">(<span class="keyword">const</span> class UDamageType&amp; dmgType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当 actor 超出世界范围的硬限制时调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OutsideWorldBounds</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 返回此 actor 所有组件的世界空间绑定盒</span></span><br><span class="line"><span class="comment">	 * @param bNonColliding 绑定盒是否包含非碰撞组件</span></span><br><span class="line"><span class="comment">	 * @param bIncludeFromChildActors 为真则递归处理 ChildActor 组件，并在那些 actors 中寻找适当类型的组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FBox <span class="title">GetComponentsBoundingBox</span><span class="params">(<span class="keyword">bool</span> bNonColliding = <span class="literal">false</span>, <span class="keyword">bool</span> bIncludeFromChildActors = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 计算此 actor 的所有组件的空间绑定盒。此函数执行比 GetComponentsBoundingBox() 慢，因为没有组件的本地绑定没有被缓存。此函数调用时，他们每次都重新计算。</span></span><br><span class="line"><span class="comment">	 * @param bNonColliding 绑定盒是否包含非碰撞组件</span></span><br><span class="line"><span class="comment">	 * @param bIncludeFromChildActors 为真则递归处理 ChildActor 组件，并在那些 actors 中寻找适当类型的组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FBox <span class="title">CalculateComponentsBoundingBoxInLocalSpace</span><span class="params">(<span class="keyword">bool</span> bNonColliding = <span class="literal">false</span>, <span class="keyword">bool</span> bIncludeFromChildActors = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * Get half-height/radius of a big axis-aligned cylinder around this actors registered colliding components, or all registered components if bNonColliding is false. </span></span><br><span class="line"><span class="comment">	 * 获取围绕此区域的大轴对齐圆柱体的半高/半径</span></span><br><span class="line"><span class="comment">	 * 如果 bNonColling 为 false，则获取已注册的碰撞组件或所有已注册的组件</span></span><br><span class="line"><span class="comment">	 * @param bNonColliding 绑定盒是否包含非碰撞组件</span></span><br><span class="line"><span class="comment">	 * @param bIncludeFromChildActors 为真则递归处理 ChildActor 组件，并在那些 actors 中寻找适当类型的组件</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetComponentsBoundingCylinder</span><span class="params">(<span class="keyword">float</span>&amp; CollisionRadius, <span class="keyword">float</span>&amp; CollisionHalfHeight, <span class="keyword">bool</span> bNonColliding = <span class="literal">false</span>, <span class="keyword">bool</span> bIncludeFromChildActors = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取围绕此 actor 的轴对齐圆柱体，用于简单的碰撞检测(如: Pawns 到达某个目的地)</span></span><br><span class="line"><span class="comment">	 * 如果 IsRootComponentCollisionRegistered() 返回真，则直接返回他绑定的圆柱体，否则回去调用 GetComponentsBoundingCylinder</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetSimpleCollisionCylinder</span><span class="params">(<span class="keyword">float</span>&amp; CollisionRadius, <span class="keyword">float</span>&amp; CollisionHalfHeight)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回从 GetSimpleCollisionCylinder() 中获得的用于碰撞的圆柱体的半径 */</span></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetSimpleCollisionRadius</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回从 GetSimpleCollisionCylinder() 中获得的用于碰撞的圆柱体的半高 */</span></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetSimpleCollisionHalfHeight</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**基于 GetSimpleCollisionCylinder()，返回此 actor 的碰撞体范围向量 */</span></span><br><span class="line">	<span class="function">FVector <span class="title">GetSimpleCollisionCylinderExtent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果根组件已被注册，且启用碰撞，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsRootComponentCollisionRegistered</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 网络相关，当 actor 被拆除(bTearOff == true)时，在客户端调用。这意味着此 actor 不再复制给客户端</span></span><br><span class="line"><span class="comment">	 * @see bTearOff</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TornOff</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Collision/Physics functions.</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 获取所有组件对传入通道的碰撞响应</span></span><br><span class="line"><span class="comment">	 * 返回状态的最大值，例如: 如果组件A重叠，但组件B阻挡，则返回阻挡响应。</span></span><br><span class="line"><span class="comment">	 * 如果组件A忽略，但组件B重叠，则返回重叠响应</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> ECollisionResponse <span class="title">GetComponentsCollisionResponseToChannel</span><span class="params">(ECollisionChannel Channel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 停止此 actor 所有组件的所有模拟 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DisableComponentsSimulatePhysics</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回此 actor 所在世界的 WorldSettings(存着默认游戏模式，全局重力等)</span></span><br><span class="line"><span class="comment">	 * 如果你想知道此 actor 所属的世界，请使用 GetTypedOuter&lt;UWorld&gt;()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">class AWorldSettings* <span class="title">GetWorldSettings</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果给定的 Pawn 可以基于此 actor，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CanBeBaseForCharacter</span><span class="params">(class APawn* Pawn)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对此 actor 应用伤害</span></span><br><span class="line"><span class="comment">	 * @see https://www.unrealengine.com/blog/damage-in-ue4</span></span><br><span class="line"><span class="comment">	 * @param DamageAmount		应用多少伤害</span></span><br><span class="line"><span class="comment">	 * @param DamageEvent		完整描述受到的伤害的数据包</span></span><br><span class="line"><span class="comment">	 * @param EventInstigator	实施此伤害的 Controller</span></span><br><span class="line"><span class="comment">	 * @param DamageCauser		直接造成此伤害的 actor (如: 爆炸的弹丸，落在你身上的岩石)</span></span><br><span class="line"><span class="comment">	 * @return					真实应用的伤害量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">TakeDamage</span><span class="params">(<span class="keyword">float</span> DamageAmount, struct FDamageEvent <span class="keyword">const</span>&amp; DamageEvent, class AController* EventInstigator, AActor* DamageCauser)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">InternalTakeRadialDamage</span><span class="params">(<span class="keyword">float</span> Damage, struct FRadialDamageEvent <span class="keyword">const</span>&amp; RadialDamageEvent, class AController* EventInstigator, AActor* DamageCauser)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">InternalTakePointDamage</span><span class="params">(<span class="keyword">float</span> Damage, struct FPointDamageEvent <span class="keyword">const</span>&amp; PointDamageEvent, class AController* EventInstigator, AActor* DamageCauser)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 当此 actor 成为给定 PlayerController 的 ViewTarget (观察目标，通常是PlayerController/CameraActor/Pawn)时调用，触发蓝图事件 K2_OnBecomeViewTarget */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BecomeViewTarget</span><span class="params">( class APlayerController* PC )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 不再是给定 PlayerController 的 ViewTarget 时调用。同时会触发蓝图事件 K2_OnEndViewTarget. */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndViewTarget</span><span class="params">( class APlayerController* PC )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此 actor 成为给定 PlayerController 的 ViewTarget 时调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName=<span class="string">&quot;OnBecomeViewTarget&quot;</span>, ScriptName=<span class="string">&quot;OnBecomeViewTarget&quot;</span>, Keywords=<span class="string">&quot;Activate Camera&quot;</span>), Category=Actor)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_OnBecomeViewTarget</span><span class="params">( class APlayerController* PC )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当此 actor 不再是给定 PlayerController 的 ViewTarget 时调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName=<span class="string">&quot;OnEndViewTarget&quot;</span>, ScriptName=<span class="string">&quot;OnEndViewTarget&quot;</span>, Keywords=<span class="string">&quot;Deactivate Camera&quot;</span>), Category=Actor)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_OnEndViewTarget</span><span class="params">( class APlayerController* PC )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 观察此 actor 时，计算相机的观察点</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param	DeltaTime	距离上次更新的增量时间</span></span><br><span class="line"><span class="comment">	 * @param	OutResult	相机配置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CalcCamera</span><span class="params">(<span class="keyword">float</span> DeltaTime, struct FMinimalViewInfo&amp; OutResult)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此 actor 是否包含一个活跃的相机组件 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HasActiveCameraComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 是否包含一个活跃的锁定于 HMD 相机组件 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HasActivePawnControlCameraComponent</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回对象的可读字符串表示形式 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FString <span class="title">GetHumanReadableName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 重置此 actor 到初始状态 - 用于重新开始关卡，但不重新加载 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当 actor 被重置为初始状态时调用的事件 - 用于重新开始关卡，但不重新加载 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category=Actor, meta=(DisplayName=<span class="string">&quot;OnReset&quot;</span>, ScriptName=<span class="string">&quot;OnReset&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_OnReset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果此 actor 的渲染状态为 &quot;recently&quot;(最近)，则返回true，并以秒为单位定义 &quot;recently&quot; 的含义。</span></span><br><span class="line"><span class="comment">	 * 例如: 如果间隔被设置为 0.1，且当前距离此 actor 上次渲染未到 0.1 秒，则返回真</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param Tolerance  用于定义渲染状态是否为 &quot;recently&quot; 的时间间隔</span></span><br><span class="line"><span class="comment">	 * @return 此 actor 是否为最近渲染的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(Category=<span class="string">&quot;Rendering&quot;</span>, BlueprintCallable, meta=(DisplayName=<span class="string">&quot;WasActorRecentlyRendered&quot;</span>, Keywords=<span class="string">&quot;scene visible&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">WasRecentlyRendered</span><span class="params">(<span class="keyword">float</span> Tolerance = <span class="number">0.2</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 的组件最后一次渲染的时间 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetLastRenderTime</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果默认情况下此 actor 尚未与网络相关，则强制其网络相关 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ForceNetRelevant</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 更新 NetUpdateTime 为新的值，用于将来的网络相关性检查。4.26 版本后不再使用*/</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.26</span>, <span class="string">&quot;No longer used.&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetNetUpdateTime</span><span class="params">(<span class="keyword">float</span> NewUpdateTime)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 寻找与此 actor 关联的 FNetworkObjectInfo 结构体 (用于主网络驱动)</span></span><br><span class="line"><span class="comment">	 * 如果未找到，将创建并添加到主网络驱动 </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @return 与此 actor 关联的 FNetworkObjectInfo 结构体，如果无法创建则返回 nullptr</span></span><br><span class="line"><span class="comment">	 * 4.26版本后，请使用网络驱动中的 FindOrAddNetworkObjectInfo 代替</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.26</span>, <span class="string">&quot;Please use FindOrAddNetworkObjectInfo on the net driver instead.&quot;</span>)</span><br><span class="line">	<span class="function">FNetworkObjectInfo* <span class="title">FindOrAddNetworkObjectInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 寻找与此 actor 关联的 FNetworkObjectInfo 结构体 (用于主网络驱动)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @return 与此 actor 关联的 FNetworkObjectInfo 结构体，如果找不到则返回 nullptr</span></span><br><span class="line"><span class="comment">	 * 4.26版本后，请使用网络驱动中的 FindNetworkObjectInfo 代替</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.26</span>, <span class="string">&quot;Please use FindNetworkObjectInfo on the net driver instead.&quot;</span>)</span><br><span class="line">	<span class="function">FNetworkObjectInfo* <span class="title">FindNetworkObjectInfo</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.26</span>, <span class="string">&quot;Please use FindNetworkObjectInfo on the net driver instead..&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">const</span> FNetworkObjectInfo* <span class="title">FindNetworkObjectInfo</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;AActor*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">FindNetworkObjectInfo</span>();</span><br><span class="line">		PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 强制 actor 更新到 客户端/演示 网络驱动中 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>( BlueprintCallable, Category=<span class="string">&quot;Networking&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ForceNetUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 为此 actor 的所有 meshcomponents 调用 PrestreamTextures()</span></span><br><span class="line"><span class="comment">	 * @param Seconds - 强制所有mip关卡驻留的秒数</span></span><br><span class="line"><span class="comment">	 * @param bEnableStreaming	- 开始(true) 还是 结束(false) 流</span></span><br><span class="line"><span class="comment">	 * @param CinematicTextureGroups - 指示使用超高分辨率 mips 的纹理组的位字段</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Rendering&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrestreamTextures</span><span class="params">( <span class="keyword">float</span> Seconds, <span class="keyword">bool</span> bEnableStreaming, int32 CinematicTextureGroups = <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回此 actor 的观察点</span></span><br><span class="line"><span class="comment">	 * 注意这不意味着就是摄像机，但确是此 actor 的 &quot;眼睛&quot;、</span></span><br><span class="line"><span class="comment">	 * 例如，对于一个 Pawn 来说，这可以定义为眼睛的高度位置和眼睛的旋转值(不同于 pawn 的旋转值，pitch轴永远为0)</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 相机第一人称视角通常使用这种观察点，大多数追踪（武器，人工智能）都是通过这个观察点完成的</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param	OutLocation - 观察点的位置</span></span><br><span class="line"><span class="comment">	 * @param	OutRotation - actor 的观察旋转值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = Actor)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetActorEyesViewPoint</span><span class="params">( FVector&amp; OutLocation, FRotator&amp; OutRotation )</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the optimal location to fire weapons at this actor</span></span><br><span class="line"><span class="comment">	 * @param RequestedBy - the Actor requesting the target location</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FVector <span class="title">GetTargetLocation</span><span class="params">(AActor* RequestedBy = <span class="literal">nullptr</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 挂钩，允许演员自己渲染 HUD 覆盖层。从 AHUD::DrawActorOverlays() 中调用。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param PC 观察已渲染的此覆盖层的PlayerController</span></span><br><span class="line"><span class="comment">	 * @param Canvas 绘制覆盖层的画布</span></span><br><span class="line"><span class="comment">	 * @param CameraPosition 摄像机的位置</span></span><br><span class="line"><span class="comment">	 * @param CameraDir 摄像机对着的方向</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostRenderFor</span><span class="params">(class APlayerController* PC, class UCanvas* Canvas, FVector CameraPosition, FVector CameraDir)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此 actor 是否在主关卡中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsInPersistentLevel</span><span class="params">(<span class="keyword">bool</span> bIncludeLevelStreamingPersistent = <span class="literal">false</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取此 actor 所在的世界指针，如果此 actor 未确切地生成在某个关卡中，则返回空 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UWorld* <span class="title">GetWorld</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 从 actors 世界中获取计时器实例 */</span></span><br><span class="line">	<span class="function">class FTimerManager&amp; <span class="title">GetWorldTimerManager</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取最终包含此 actor 的游戏实例 */</span></span><br><span class="line">	<span class="function">class UGameInstance* <span class="title">GetGameInstance</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 获取最终包含此 actor 的游戏实例，并转换为特定的模板类型(转换失败返回空) */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt; class T &gt;</span></span><br><span class="line"><span class="function">	T* <span class="title">GetGameInstance</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">return</span> Cast&lt;T&gt;(<span class="built_in">GetGameInstance</span>()); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果这是一个可复制的 actor，且已被放置在地图中，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsNetStartupActor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 寻找组件数组，并返回指定类的第一个遇到的组件。GetComponentByClass 的本地版本 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UActorComponent* <span class="title">FindComponentByClass</span><span class="params">(<span class="keyword">const</span> TSubclassOf&lt;UActorComponent&gt; ComponentClass)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 寻找组件数组，并返回指定类的第一个遇到的组件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Actor&quot;</span>, meta = (ComponentClass = <span class="string">&quot;ActorComponent&quot;</span>), meta = (DeterminesOutputType = <span class="string">&quot;ComponentClass&quot;</span>))</span><br><span class="line">	<span class="function">UActorComponent* <span class="title">GetComponentByClass</span><span class="params">(TSubclassOf&lt;UActorComponent&gt; ComponentClass)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取继承于给定类的所有组件</span></span><br><span class="line"><span class="comment">	 * 当前返回一个 UActorComponent 的数组，组件必须可以转换为正确的类型</span></span><br><span class="line"><span class="comment">	 * 仅用于蓝图。C++ 请使用 GetComponents()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Actor&quot;</span>, meta = (ComponentClass = <span class="string">&quot;ActorComponent&quot;</span>, DisplayName = <span class="string">&quot;GetComponentsByClass&quot;</span>, ScriptName = <span class="string">&quot;GetComponentsByClass&quot;</span>, DeterminesOutputType = <span class="string">&quot;ComponentClass&quot;</span>))</span><br><span class="line">	<span class="function">TArray&lt;UActorComponent*&gt; <span class="title">K2_GetComponentsByClass</span><span class="params">(TSubclassOf&lt;UActorComponent&gt; ComponentClass)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取继承于给定类 且拥有一个给定标记的所有组件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Actor&quot;</span>, meta = (ComponentClass = <span class="string">&quot;ActorComponent&quot;</span>), meta = (DeterminesOutputType = <span class="string">&quot;ComponentClass&quot;</span>))</span><br><span class="line">	<span class="function">TArray&lt;UActorComponent*&gt; <span class="title">GetComponentsByTag</span><span class="params">(TSubclassOf&lt;UActorComponent&gt; ComponentClass, FName Tag)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取继承于给定接口的所有组件 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Actor&quot;</span>)</span><br><span class="line">	<span class="function">TArray&lt;UActorComponent*&gt; <span class="title">GetComponentsByInterface</span><span class="params">(TSubclassOf&lt;UInterface&gt; Interface)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 模板版本的 FindComponentByClass，处理动态转换 */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">	T* <span class="title">FindComponentByClass</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">static_assert</span></span>(TPointerIsConvertibleFromTo&lt;T, <span class="keyword">const</span> UActorComponent&gt;::Value, <span class="string">&quot;&#x27;T&#x27; template parameter to FindComponentByClass must be derived from UActorComponent&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (T*)<span class="built_in">FindComponentByClass</span>(T::<span class="built_in">StaticClass</span>());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 内部辅助函数，用于在编译期为指定类型的所有组件调用一个 lambda 函数</span></span><br><span class="line"><span class="comment">	 * 使用模板参数 bClassIsActorComponent 以避免在 ComponentClass 明确是 UActorComponent 时做没必要的 IsA 检查</span></span><br><span class="line"><span class="comment">	 * 使用模板参数 bIncludeFromChildActors 以递归处理 ChildActor 组件，并在那些 actors 中的寻找适当类型的组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class ComponentType, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">ForEachComponent_Internal</span><span class="params">(TSubclassOf&lt;UActorComponent&gt; ComponentClass, <span class="keyword">bool</span> bIncludeFromChildActors, Func InFunc)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对特定类型的每个组件，调用编译期 lambda 函数</span></span><br><span class="line"><span class="comment">	 * @param ComponentType 组件类，用于寻找继承于其的组件</span></span><br><span class="line"><span class="comment">	 * @param bIncludeFromChildActors 是否递归处理 ChildActor 组件，并寻找那些 actors 中合适类型的组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class ComponentType, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">ForEachComponent</span><span class="params">(<span class="keyword">bool</span> bIncludeFromChildActors, Func InFunc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;		</span><br><span class="line">		ForEachComponent_Internal&lt;ComponentType&gt;(ComponentType::<span class="built_in">StaticClass</span>(), bIncludeFromChildActors, InFunc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对每个有效的组件，调用编译期 lambda 函数</span></span><br><span class="line"><span class="comment">	 * @param bIncludeFromChildActors 是否递归处理 ChildActor 组件，并寻找那些 actors 中合适类型的组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">ForEachComponent</span><span class="params">(<span class="keyword">bool</span> bIncludeFromChildActors, Func InFunc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ForEachComponent_Internal&lt;UActorComponent&gt;(UActorComponent::<span class="built_in">StaticClass</span>(), bIncludeFromChildActors, InFunc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 4.24版本后，请根据需要使用某个 GetComponents 实现 */</span></span><br><span class="line">	<span class="built_in">UE_DEPRECATED</span>(<span class="number">4.24</span>, <span class="string">&quot;Use one of the GetComponents implementations as appropriate&quot;</span>)</span><br><span class="line">	<span class="function">TArray&lt;UActorComponent*&gt; <span class="title">GetComponentsByClass</span><span class="params">(TSubclassOf&lt;UActorComponent&gt; ComponentClass)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">K2_GetComponentsByClass</span>(ComponentClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取继承于指定组件类的所有组件，并作为结果填充到 OutComponents 数组中</span></span><br><span class="line"><span class="comment">	 * 建议将 Tarrays 与 TInlineAllocator 一起使用，以潜在地避免内存分配成本。</span></span><br><span class="line"><span class="comment">	 * TInlineComponentArray 的定义可以使其更加简单，例如:</span></span><br><span class="line"><span class="comment">	 * &#123;</span></span><br><span class="line"><span class="comment">	 * 	   TInlineComponentArray&lt;UPrimitiveComponent*&gt; PrimComponents(Actor);</span></span><br><span class="line"><span class="comment">	 * &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param ComponentClass 组件类，用于寻找所有组件是否继承于此组件类</span></span><br><span class="line"><span class="comment">	 * @param bIncludeFromChildActors 是否遍历处理 ChildActor 组件中的 actors 的合适类型的组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class AllocatorType&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">GetComponents</span><span class="params">(TSubclassOf&lt;UActorComponent&gt; ComponentClass, TArray&lt;UActorComponent*, AllocatorType&gt;&amp; OutComponents, <span class="keyword">bool</span> bIncludeFromChildActors = <span class="literal">false</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_GetComponentsTime);</span><br><span class="line"></span><br><span class="line">		OutComponents.<span class="built_in">Reset</span>();</span><br><span class="line">		ForEachComponent_Internal&lt;UActorComponent&gt;(ComponentClass, bIncludeFromChildActors, [&amp;](UActorComponent* InComp)</span><br><span class="line">		&#123;</span><br><span class="line">			OutComponents.<span class="built_in">Add</span>(InComp);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 与上面的函数相同，T为指定的组件类型，更方便使用*/</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class T, class AllocatorType&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">GetComponents</span><span class="params">(TArray&lt;T*, AllocatorType&gt;&amp; OutComponents, <span class="keyword">bool</span> bIncludeFromChildActors = <span class="literal">false</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_GetComponentsTime);</span><br><span class="line"></span><br><span class="line">		OutComponents.<span class="built_in">Reset</span>();</span><br><span class="line">		ForEachComponent_Internal&lt;T&gt;(T::<span class="built_in">StaticClass</span>(), bIncludeFromChildActors, [&amp;](T* InComp)</span><br><span class="line">		&#123;</span><br><span class="line">			OutComponents.<span class="built_in">Add</span>(InComp);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 指定类型为 UActorComponent，避免不必要的类型转换 */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class AllocatorType&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">GetComponents</span><span class="params">(TArray&lt;UActorComponent*, AllocatorType&gt;&amp; OutComponents, <span class="keyword">bool</span> bIncludeFromChildActors = <span class="literal">false</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_GetComponentsTime);</span><br><span class="line"></span><br><span class="line">		OutComponents.<span class="built_in">Reset</span>();</span><br><span class="line">		ForEachComponent_Internal&lt;UActorComponent&gt;(UActorComponent::<span class="built_in">StaticClass</span>(), bIncludeFromChildActors, [&amp;](UActorComponent* InComp)</span><br><span class="line">		&#123;</span><br><span class="line">			OutComponents.<span class="built_in">Add</span>(InComp);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取组件集的直接引用，而不是被删除的空指针的副本</span></span><br><span class="line"><span class="comment">	 * 警告: 任何导致组件改变所有权的操作都会使此数组无效化，所以迭代此集合时请务必小心使用！</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> TSet&lt;UActorComponent*&gt;&amp; <span class="title">GetComponents</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> OwnedComponents;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将一个组件放入此 actor 的 OwnedComponents 数组中</span></span><br><span class="line"><span class="comment">	 * 此组件必须被此 actor 拥有，否则将触发断言</span></span><br><span class="line"><span class="comment">	 * 通常情况下，除了 UActorComponent 的函数，此函数不应该被直接调用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddOwnedComponent</span><span class="params">(UActorComponent* Component)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从该 actor 的 OwnedComponents 数组中移除一个组件</span></span><br><span class="line"><span class="comment">	 * 通常情况下，除了 UActorComponent 的函数，此函数不应该被直接调用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveOwnedComponent</span><span class="params">(UActorComponent* Component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DO_CHECK</span></span><br><span class="line">	<span class="comment">/** 实用函数，用于验证一个组件是否在它的拥有者的 OwnedComponents 数组中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">OwnsComponent</span><span class="params">(UActorComponent* Component)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 强制此 actor 清除并重建他的 OwnedComponents 数组，通过递归计算所有孩子，并定位组件</span></span><br><span class="line"><span class="comment">	 * 一般来说，此函数不需要直接调用，但有时作为撤消/重做代码路径的一部分可能是必需的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ResetOwnedComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当一个组件的复制状态被改变时调用，以更新此 actor 缓存的 ReplicatedComponents 数组 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateReplicatedComponent</span><span class="params">(UActorComponent* Component)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 完全同步已复制组件数组，使其正好包含当前拥有的已复制组件的数量 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateAllReplicatedComponents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回是否启用复制 */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">GetIsReplicated</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bReplicates;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回对已复制组件集的常量引用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">const</span> TArray&lt;UActorComponent*&gt;&amp; <span class="title">GetReplicatedComponents</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">return</span> ReplicatedComponents; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 已复制的组件集，存成一个数组以便节省空间，因为这通常不会非常大 */</span></span><br><span class="line">	TArray&lt;UActorComponent*&gt; ReplicatedComponents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 此 actor 拥有的所有 ActorComponents。存成集合是因为 actors 可能拥有大量的组件</span></span><br><span class="line"><span class="comment">	 * @see GetComponents()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	TSet&lt;UActorComponent*&gt; OwnedComponents;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用户按每个实例添加的 ActorComponents 数组 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Instanced)</span><br><span class="line">	TArray&lt;UActorComponent*&gt; InstanceComponents;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 蓝图创建的，按每个实例序列化的 ActorComponents 数组 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(TextExportTransient, NonTransactional)</span><br><span class="line">	TArray&lt;UActorComponent*&gt; BlueprintCreatedComponents;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 添加一个组件到实例组件数组(InstanceComponents)中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddInstanceComponent</span><span class="params">(UActorComponent* Component)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ........ 省略 实例组件数组的移除，清除，获取操函数(3207行)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Navigation/AI related functions</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Trigger a noise caused by a given Pawn, at a given location.</span></span><br><span class="line"><span class="comment">	 * Note that the NoiseInstigator Pawn MUST have a PawnNoiseEmitterComponent for the noise to be detected by a PawnSensingComponent.</span></span><br><span class="line"><span class="comment">	 * Senders of MakeNoise should have an Instigator if they are not pawns, or pass a NoiseInstigator.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param Loudness The relative loudness of this noise. Usual range is 0 (no noise) to 1 (full volume). If MaxRange is used, this scales the max range, otherwise it affects the hearing range specified by the sensor.</span></span><br><span class="line"><span class="comment">	 * @param NoiseInstigator Pawn responsible for this noise.  Uses the actor&#x27;s Instigator if NoiseInstigator is null</span></span><br><span class="line"><span class="comment">	 * @param NoiseLocation Position of noise source.  If zero vector, use the actor&#x27;s location.</span></span><br><span class="line"><span class="comment">	 * @param MaxRange Max range at which the sound may be heard. A value of 0 indicates no max range (though perception may have its own range). Loudness scales the range. (Note: not supported for legacy PawnSensingComponent, only for AIPerception)</span></span><br><span class="line"><span class="comment">	 * @param Tag Identifier for the noise.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, BlueprintAuthorityOnly, Category=<span class="string">&quot;AI&quot;</span>, meta=(BlueprintProtected = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MakeNoise</span><span class="params">(<span class="keyword">float</span> Loudness=<span class="number">1.f</span>, APawn* NoiseInstigator=<span class="literal">nullptr</span>, FVector NoiseLocation=FVector::ZeroVector, <span class="keyword">float</span> MaxRange = <span class="number">0.f</span>, FName Tag = NAME_None)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Default Implementation of MakeNoise */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeNoiseImpl</span><span class="params">(AActor* NoiseMaker, <span class="keyword">float</span> Loudness, APawn* NoiseInstigator, <span class="keyword">const</span> FVector&amp; NoiseLocation, <span class="keyword">float</span> MaxRange, FName Tag)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Modifies the global delegate used for handling MakeNoise */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetMakeNoiseDelegate</span><span class="params">(<span class="keyword">const</span> FMakeNoiseDelegate&amp; NewDelegate)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check if owned component should be relevant for navigation</span></span><br><span class="line"><span class="comment">	 * Allows implementing master switch to disable e.g. collision export in projectiles</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsComponentRelevantForNavigation</span><span class="params">(UActorComponent* Component)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> FMakeNoiseDelegate MakeNoiseDelegate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//~=============================================================================</span></span><br><span class="line">	<span class="comment">// Debugging functions</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在画布中绘制重要 Actor 变量。当 ShowDebug 执行时，HUD 将在当前 ViewTarget 中调用 DisplayDebug()</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param Canvas			用于绘画的画布</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param DebugDisplay		包含用于显示的调试信息</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param YL				[输入] 先前绘制的线的高度	</span></span><br><span class="line"><span class="comment">	 *							[输出] 此函数绘制的最后一条线的高度	</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param YPos				[输入] 先前绘制的线在画布中的Y轴的位置。YPos += YL，为绘制下一条调试线提供位置信息</span></span><br><span class="line"><span class="comment">	 *							[输出] 此函数绘制的最后一条线在画布中的Y的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DisplayDebug</span><span class="params">(class UCanvas* Canvas, <span class="keyword">const</span> class FDebugDisplayInfo&amp; DebugDisplay, <span class="keyword">float</span>&amp; YL, <span class="keyword">float</span>&amp; YPos)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 检索 actor 的名称，用于日志输出。如果 actor 为空，则输出 &quot;NULL&quot; 字符串 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> FString <span class="title">GetDebugName</span><span class="params">(<span class="keyword">const</span> AActor* Actor)</span> </span>&#123; <span class="keyword">return</span> Actor ? Actor-&gt;<span class="built_in">GetName</span>() : <span class="built_in">TEXT</span>(<span class="string">&quot;NULL&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在渲染线程中将基本体从场景中分离时追踪的栅格 */</span></span><br><span class="line">	FRenderCommandFence DetachFence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 设置友好 actor 标记和名称 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActorLabelInternal</span><span class="params">(<span class="keyword">const</span> FString&amp; NewActorLabelDirty, <span class="keyword">bool</span> bMakeGloballyUniqueFName, <span class="keyword">bool</span> bMarkDirty)</span></span>;</span><br><span class="line">已经假定命中信息是反向的，并且尽可能避免创建临时FhirtResult的帮助器。</span><br><span class="line">	<span class="comment">/** 辅助函数，假定 Hit 信息是反向的，并尽可能避免创建临时FHitResult */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InternalDispatchBlockingHit</span><span class="params">(UPrimitiveComponent* MyComp, UPrimitiveComponent* OtherComp, <span class="keyword">bool</span> bSelfMoved, FHitResult <span class="keyword">const</span>&amp; Hit)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 非内联，不检查独立服务器构建标记(调用时总是已构建好)的私有版本 */</span></span><br><span class="line">	<span class="function">ENetMode <span class="title">InternalGetNetMode</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 从 PostEditUndo 的两个实现中调用的统一实现函数，用于需要执行撤销操作的AActor特定元素 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">InternalPostEditUndo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FMarkActorIsBeingDestroyed</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FActorParentComponentSetter</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FSetActorWantsDestroyDuringBeginPlay</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态辅助函数，用于访问 SceneComponent 的函数</span></span><br><span class="line">	<span class="comment">// 这些模板只是为了在定义 USceneComponent 之前延迟编译</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取 Actor 的变换的模板函数 */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">static</span> FORCEINLINE <span class="keyword">const</span> FTransform&amp; <span class="title">TemplateGetActorTransform</span><span class="params">(<span class="keyword">const</span> T* RootComponent)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (RootComponent != <span class="literal">nullptr</span>) ? RootComponent-&gt;<span class="built_in">GetComponentTransform</span>() : FTransform::Identity;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ........ 省略 获取 Location, Rotation, Scale, Quat, ForwardVector, UpVector, RightVector 的模板函数 (3313行)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//~ Begin Methods for Replicated Members.(用于已复制的成员的方法)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取隐藏的属性名称</span></span><br><span class="line"><span class="comment">	 * 此函数是为了让子类不需要直接访问隐藏属性而存在的，以便我们后面将其私有化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FName <span class="title">GetHiddenPropertyName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GET_MEMBER_NAME_CHECKED</span>(AActor, bHidden);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取 bHidden 的字面值</span></span><br><span class="line"><span class="comment">	 * 此函数是为了让子类不需要直接访问隐藏属性而存在的，以便我们后面将其私有化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsHidden</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bHidden;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置 bHidden 的值，不影响此实例的其他地方</span></span><br><span class="line"><span class="comment">	 * SetActorHiddenInGame 在大多数清空下是首选的，因为其遵循虚函数的行为</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetHidden</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> bInHidden)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取 bReplicateMovement 的属性名</span></span><br><span class="line"><span class="comment">	 * 此函数是为了让子类不需要直接访问 bReplicateMovement 属性而存在的，以便我们后面将其私有化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FName <span class="title">GetReplicateMovementPropertyName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GET_MEMBER_NAME_CHECKED</span>(AActor, bReplicateMovement);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...... 跟 bHidden 一样，省略对 bReplicateMovement, bCanBeDamaged, Role, ReplicatedMovement, Instigator 属性的处理</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>Actor 的总结在代码分析前已经讲过了，总的来说就是在处理 Actor 和 Component 之间的各种逻辑 (移动，碰撞等)，以及 Actor 的网络复制。</p><h3 id="actorcomponent"><a class="anchor" href="#actorcomponent">#</a> ActorComponent</h3><p>&quot;ActorComponent&quot; 是所有组件的基类，用于将 Actor 某一类可重用的行为集成起来，放置于不同类型的 Actor 中 (例如：人会行走，将行走的行为集成到 MovementComponent 中，然后添加到动物身上，这样我们就不需要写两次行走的代码)</p><p>对于有 transform (变换，包括：Location，Rotation，Scale) 的组件，其继承于 SceneComponent。对于可以被渲染的组件，其继承于 PrimitiveComponent (可渲染则必定有变换信息，所以其继承于 SceneComponent)</p><p>我们只分析 &quot;ActorComponent&quot; 的源码，&quot;SceneComponent&quot; 和 &quot;PromitiveComponent&quot; 的源码留给感兴趣的读者自行阅读</p><p></p><figure class="highlight c++"><figcaption><span>UActorComponent</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActorComponent.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(DefaultToInstanced, BlueprintType, abstract, meta=(ShortTooltip=<span class="string">&quot;An ActorComponent is a reusable component that can be added to any actor.&quot;</span>), config=Engine)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ENGINE_API</span> <span class="title">UActorComponent</span> :</span> <span class="keyword">public</span> UObject, <span class="keyword">public</span> IInterface_AssetUserData</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 创建组件物理状态全局代理 */</span></span><br><span class="line">	<span class="keyword">static</span> FActorComponentGlobalCreatePhysicsSignature GlobalCreatePhysicsDelegate;</span><br><span class="line">	<span class="comment">/** 销毁组件物理状态全局代理*/</span></span><br><span class="line">	<span class="keyword">static</span> FActorComponentGlobalDestroyPhysicsSignature GlobalDestroyPhysicsDelegate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 默认 UObject 构造函数，传入一个可选的 ObjectInitializer */</span></span><br><span class="line">	<span class="built_in">UActorComponent</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件的主 tick 函数 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category=<span class="string">&quot;ComponentTick&quot;</span>)</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FActorComponentTickFunction</span> <span class="title">PrimaryComponentTick</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于分组和分类的标记数组，可以从脚本中访问 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Bluep访问ntReadWrite, Category=Tags)</span><br><span class="line">	TArray&lt;FName&gt; ComponentTags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 与组件一起存储的用户数据数组 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, AdvancedDisplay, Instanced, Category = AssetUserData)</span><br><span class="line">	TArray&lt;UAssetUserData*&gt; AssetUserData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 用于快速删除帧结束更新 */</span></span><br><span class="line">	int32 MarkedForEndOfFrameUpdateArrayIndex;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在创建组件时填充，并根据每个原型/每个 actor 跟踪常用的创建顺序 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	int32 UCSSerializationIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ........ 省略部分私有布尔变量 (171行)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 描述一个组件实例如何实例化 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	EComponentCreationMethod CreationMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 返回 UCS 序列化索引。在编辑器中，如果你正在处理的组件在此信息存在之前被保存，那将是一个昂贵的操作，此信息需要被计算 */</span></span><br><span class="line">	<span class="function">int32 <span class="title">GetUCSSerializationIndex</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 为一个组件计算 UCS 序列化索引，该组件在我们开始保存此数据之前被保存 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DetermineUCSSerializationIndexForLegacyComponent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 追踪此组件是否被添加到某个世界的帧末更新列表 */</span></span><br><span class="line">	<span class="function">uint32 <span class="title">GetMarkedForEndOfFrameUpdateState</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> MarkedForEndOfFrameUpdateState; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 追踪此组件是否被添加到某个世界的帧末更新列表 */</span></span><br><span class="line">	<span class="function">uint32 <span class="title">GetMarkedForPreEndOfFrameSync</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bMarkedForPreEndOfFrameSync; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 初始化被 UserConstructionScript 修改的属性列表 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DetermineUCSModifiedProperties</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回被 UserConstructionScript 修改的属性列表 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetUCSModifiedProperties</span><span class="params">(TSet&lt;<span class="keyword">const</span> FProperty*&gt;&amp; ModifiedProperties)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 从 UCS-modified 属性列表中移除特定的属性 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveUCSModifiedProperties</span><span class="params">(<span class="keyword">const</span> TArray&lt;FProperty*&gt;&amp; Properties)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此组件被从父 actor 类中继承时，是否可以被修改 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsEditableWhenInherited</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 表明 OnCreatedComponent 已被调用，但 OnDestroyedComponent 没有 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">HasBeenCreated</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bHasBeenCreated; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 表明 InitializeComponent 已被调用，但UninitializeComponent 没有 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">HasBeenInitialized</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bHasBeenInitialized; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 表明 BeginPlay 已被调用，但 EndPlay 没有 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">HasBegunPlay</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bHasBegunPlay; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回该组件正在被销毁的程序中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components&quot;</span>, meta=(DisplayName=<span class="string">&quot;Is Component Being Destroyed&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsBeingDestroyed</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bIsBeingDestroyed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件的实例是否被用户或普通构造脚本创建 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsCreatedByConstructionScript</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 处理活跃状态的网络复制，以默认方式处理 ticking，此函数应被按需重载 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRep_IsActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function">AActor* <span class="title">GetActorOwnerNoninline</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** 跟随所属链以获取拥有此组件的 AActor */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components&quot;</span>, meta=(Keywords = <span class="string">&quot;Actor Owning Parent&quot;</span>))</span><br><span class="line">	<span class="function">AActor* <span class="title">GetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 模板版本的 GetOwner()，如果转换失败将返回 nullptr */</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt; class T &gt;</span></span><br><span class="line"><span class="function">	T* <span class="title">GetOwner</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cast&lt;T&gt;(<span class="built_in">GetOwner</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取已缓存的世界指针，如果此组件没有真实被生成到某个关卡中，则返回空 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UWorld* <span class="title">GetWorld</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> (WorldPrivate ? WorldPrivate : <span class="built_in">GetWorld_Uncached</span>()); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 查看此组件是否包含给定标志 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ComponentHasTag</span><span class="params">(FName Tag)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Activation System (激活系统)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此组件被激活时调用，参数指示它是否来自重置 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">&quot;Components|Activation&quot;</span>)</span><br><span class="line">	FActorComponentActivatedSignature OnComponentActivated;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当组件被停用时调用 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(BlueprintAssignable, Category = <span class="string">&quot;Components|Activation&quot;</span>)</span><br><span class="line">	FActorComponentDeactivateSignature OnComponentDeactivated;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TArray&lt;FSimpleMemberReference&gt; UCSModifiedProperties;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 激活 SceneComponent，应被本地子类重载</span></span><br><span class="line"><span class="comment">	 * @param bReset - 尽管 ShouldActive 返回false，此激活是否应该发生</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components|Activation&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Activate</span><span class="params">(<span class="keyword">bool</span> bReset=<span class="literal">false</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 停用 SceneComponent */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components|Activation&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Deactivate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置此组件是否激活</span></span><br><span class="line"><span class="comment">	 * @param bNewActive - 此组件的新激活状态</span></span><br><span class="line"><span class="comment">	 * @param bReset - 尽管 ShouldActive 返回false，此激活是否应该发生</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components|Activation&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetActive</span><span class="params">(<span class="keyword">bool</span> bNewActive, <span class="keyword">bool</span> bReset=<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 切换此组件的激活状态 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components|Activation&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ToggleActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此组件是否被激活 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components|Activation&quot;</span>, meta=(UnsafeDuringActorConstruction=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsActive</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bIsActive; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置此组件是否应为自动激活，仅在构造脚本中安全 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components|Activation&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetAutoActivate</span><span class="params">(<span class="keyword">bool</span> bNewAutoActivate)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置此组件在暂停游戏时是否可以 tick */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetTickableWhenPaused</span><span class="params">(<span class="keyword">bool</span> bTickableWhenPaused)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 创建此组件的任何物理引擎信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreatePhysicsState</span><span class="params">(<span class="keyword">bool</span> bAllowDeferral = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 关闭此组件的任何物理引擎结构体 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DestroyPhysicsState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Networking</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 这表示可以通过网络通过名称对组件进行标识。构建蓝图组件时，只需要引擎代码调用它 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetNetAddressable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 启用或禁用网络复制。这相当于 actors 中的 RemoteRole (组件只需要布尔) */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetIsReplicated</span><span class="params">(<span class="keyword">bool</span> ShouldReplicate)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回网络复制是否启用 */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">GetIsReplicated</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bReplicates;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 是否允许一个组件复制 actor 中的其他子对象 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ReplicateSubobjects</span><span class="params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在组件发生复制前调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PreReplication</span><span class="params">(IRepChangedPropertyTracker &amp; ChangedPropertyTracker)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果此类型的组件可以复制则返回真，覆盖以禁用默认行为 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">GetComponentClassCanReplicate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** 如果我们正在复制，且此客户端非权威(不是独立游戏)，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsNetSimulating</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 获取 Owner 的网络模式，如果没有 Owner 则返回 ROLE_None */</span></span><br><span class="line">	<span class="function">ENetRole <span class="title">GetOwnerRole</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取此组件的网络模式 (独立服务器，客户端，独立窗口等)</span></span><br><span class="line"><span class="comment">	 * @see IsNetMode()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ENetMode <span class="title">GetNetMode</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 测试网络模式是否为给定的模式</span></span><br><span class="line"><span class="comment">	* 在优化的非编辑器构建中，这比 GetNetMode() 的效率更高，</span></span><br><span class="line"><span class="comment">	* 因为它可以不考虑PIE，直接检查静态构建标志</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsNetMode</span><span class="params">(ENetMode Mode)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果此组件在关卡读取中被一个网络创建 actor 所有，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsNetStartupComponent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bIsNetStartupComponent; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此函数只应被引擎在 ULevel::InitializeNetworkActors 中调用，以初始化 bIsNetStartupComponent */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetIsNetStartupComponent</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> bInIsNetStartupComponent)</span> </span>&#123; bIsNetStartupComponent = bInIsNetStartupComponent; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 允许组件处理一个在 tick 中发生的 EOF 更新。可以用于阻止正在进行的异步任务等</span></span><br><span class="line"><span class="comment">	 * 这应确保组件的 tick 已经完成，以便其渲染更新正确 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEndOfFrameUpdateDuringTick</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 允许组件在发送 EOF 更新数据之前等待未完成的任务。在游戏线程上执行，可以等待任务。 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPreEndOfFrameSync</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 缓存所属 actor 的指针 */</span></span><br><span class="line">	<span class="keyword">mutable</span> AActor* OwnerPrivate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 指向世界的指针，此组件当前被注册在此世界中</span></span><br><span class="line"><span class="comment">	 * 只有在组件被注册后，此属性非空</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	UWorld* WorldPrivate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果 WorldPrivate 没有被设置，这将从 outers 中决定世界 */</span></span><br><span class="line">	<span class="function">UWorld* <span class="title">GetWorld_Uncached</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 非内联，不检查独立服务器构建标志(调用时总是正确的)的私有版本 */</span></span><br><span class="line">	<span class="function">ENetMode <span class="title">InternalGetNetMode</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 如果此组件可以被正常激活则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldActivate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** 调用 OnUnregister, DestroyRenderState_Concurrent 和 OnDestroyPhysicsState. */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ExecuteUnregisterEvents</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 调用 OnRegister, CreateRenderState_Concurrent 和 OnCreatePhysicsState. */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ExecuteRegisterEvents</span><span class="params">(FRegisterComponentContext* Context = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 实用程序函数，用于每个 PostEditChange 变体调用相同行为 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ConsolidatedPostEditChange</span><span class="params">(<span class="keyword">const</span> FPropertyChangedEvent&amp; PropertyChangedEvent)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在组件被注册时调用，在 Scene 被设置后，但在 CreateRenderState_Concurrent 或 OnCreatePhysicsState 被调用前 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRegister</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在组件被注销时调用，在 DestroyRenderState_Concurrent 和 OnDestroyPhysicsState 被调用后调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnUnregister</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果 CreateRenderState() 应被调用则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldCreateRenderState</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 用于创建此组件的任何渲染线程信息</span></span><br><span class="line"><span class="comment">	 * @warning 这是在多个线程上并发调用的 (但决不能并发调用同一个组件)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateRenderState_Concurrent</span><span class="params">(FRegisterComponentContext* Context)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 调用以向渲染线程发送此组件的一个变化更新</span></span><br><span class="line"><span class="comment">	 * @warning 这是在多个线程上并发调用的 (但决不能并发调用同一个组件)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendRenderTransform_Concurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 调用以向渲染线程发送此组件的动态数据 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendRenderDynamicData_Concurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 用于关闭此组件的任何渲染线程结构体</span></span><br><span class="line"><span class="comment">	 * @warning 这是在多个线程上并发调用的 (但决不能并发调用同一个组件)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DestroyRenderState_Concurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于创建此组件的任何物理引擎信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCreatePhysicsState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于关闭此组件的任何物理引擎信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroyPhysicsState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 如果 CreatePhysicsState() 应被调用则返回真</span></span><br><span class="line"><span class="comment">	 * 理想情况下，如果返回 true ，则 CreatePhysicsState() 应始终成功，但目前情况并非如此</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ShouldCreatePhysicsState</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于确认 DestroyPhysicsState() 是否正确运行 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">HasValidPhysicsState</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 虚函数调用链以注册所有的 tick 函数</span></span><br><span class="line"><span class="comment">	 * @param bRegister - 注册传入 true，注销传入 false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RegisterComponentTickFunctions</span><span class="params">(<span class="keyword">bool</span> bRegister)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 初始化此组件，在关卡构建和 actor 生成时执行，这在 BeginPlay(Actor 或 Component) 之前</span></span><br><span class="line"><span class="comment">	 * 所有关卡中的组件将在读取时被初始化，在所有 actor/Component 调用 BeginPlay 之前</span></span><br><span class="line"><span class="comment">	 * 需要组件已被注册，且 bWantsInitializeComponent 为真</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitializeComponent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Begins Play for the component. </span></span><br><span class="line"><span class="comment">	 * 此组件的 Begins Play</span></span><br><span class="line"><span class="comment">	 * 在所属 Actor begins play 时调用。如果所属 Actor begun play 了，则在组件被创建时调用</span></span><br><span class="line"><span class="comment">	 * Actor BeginPlay 通常发生在 PostInitializeComponents 之后，但可以因为网络或子 actors 的而被延迟</span></span><br><span class="line"><span class="comment">	 * 需要组件已被注册且已初始化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于蓝图添加 BeginPlay 时执行的逻辑，在组件的 BeginPlay 中调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName = <span class="string">&quot;Begin Play&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveBeginPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 结束此组件的 gameplay</span></span><br><span class="line"><span class="comment">	 * 只有在 bHasBegunPlay 设为 true 时，从 AActor::EndPlay 中调用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndPlay</span><span class="params">(<span class="keyword">const</span> EEndPlayReason::Type EndPlayReason)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理此组件被反初始化</span></span><br><span class="line"><span class="comment">	 * 只有在 bHasBeenInitialized 设为 true 时，从AActor::EndPlay 中调用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UninitializeComponent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于蓝图添加 EndPlay 时执行的逻辑，在组件的 EndPlay 中调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(Keywords = <span class="string">&quot;delete&quot;</span>, DisplayName = <span class="string">&quot;End Play&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveEndPlay</span><span class="params">(EEndPlayReason::Type EndPlayReason)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调用时，将调用虚函数调用链来注册所有的 tick 函数</span></span><br><span class="line"><span class="comment">	 * 切勿重载此函数，或将其改为虚函数</span></span><br><span class="line"><span class="comment">	 * @param bRegister - 注册传入 true，注销传入 false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegisterAllComponentTickFunctions</span><span class="params">(<span class="keyword">bool</span> bRegister)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 函数在此组件中每帧调用，重载此函数以实现每帧执行的自定义逻辑</span></span><br><span class="line"><span class="comment">	 * 只有在此组件已注册后执行，并且 PrimaryComponentTick.bCanEverTick 应被设为真</span></span><br><span class="line"><span class="comment">	 *	</span></span><br><span class="line"><span class="comment">	 * @param DeltaTime - 距离上次 tick 过去的时间</span></span><br><span class="line"><span class="comment">	 * @param TickType - tick 类型，例如: 我们是暂停还是在编辑器中模拟</span></span><br><span class="line"><span class="comment">	 * @param ThisTickFunction - 内部 tick 函数结构体，导致此 tick 函数运行的结构体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TickComponent</span><span class="params">(<span class="keyword">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 以标准方式，为一个组件设置一个 tick 函数</span></span><br><span class="line"><span class="comment">	 * 在 actor 后 tick。如果 actor 是静态的，或 actor 只是一个模板，或这是一个 &quot;NeverTick&quot; 的组件，则不要 tick</span></span><br><span class="line"><span class="comment">	 * 如果所属 actor 在游戏暂停时 tick，则此组件也会进行 tick</span></span><br><span class="line"><span class="comment">	 * @param	TickFunction - 持有特定 tick 函数的结构体</span></span><br><span class="line"><span class="comment">	 * @return  如果此组件满足实际 tick 的条件，则为true</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">SetupActorComponentTickFunction</span><span class="params">(struct FTickFunction* TickFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置启用或禁用此组件的 tick 函数。只有在此函数被已注册时生效 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetComponentTickEnabled</span><span class="params">(<span class="keyword">bool</span> bEnabled)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 生成一个调用 SetComponentTickEnabled 的游戏线程任务 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetComponentTickEnabledAsync</span><span class="params">(<span class="keyword">bool</span> bEnabled)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** 此组件是否启用 tick */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsComponentTickEnabled</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置此组件的主要 tick 函数的 tick 时间间隔。不启用 tick 间隔(需要自己另外启用)，在下一帧中生效 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetComponentTickInterval</span><span class="params">(<span class="keyword">float</span> TickInterval)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置此组件的主要 tick 函数的 tick 时间间隔。不启用 tick 间隔(需要自己另外启用)，立即生效 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetComponentTickIntervalAndCooldown</span><span class="params">(<span class="keyword">float</span> TickInterval)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此组件的主要 tick 函数的 tick 时间间隔 (以秒为单位的执行频率)*/</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">GetComponentTickInterval</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在特定的世界中注册一个组件，这将创建所有的视觉/物理状态 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegisterComponentWithWorld</span><span class="params">(UWorld* InWorld, FRegisterComponentContext* Context = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 组件的可重载的检查函数，用于指示其所有者是否应该防止执行完成时 actor 的自动销毁 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsReadyForOwnerToAutoDestroy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件的所有者是否在编辑器中被选择 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsOwnerSelected</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件的变换是否应该被发送到渲染线程 */</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsRenderTransformDirty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bRenderTransformDirty; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件是否需要将其整个状态发送到渲染器 */</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsRenderStateDirty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bRenderStateDirty; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 使默认选项的光照缓存无效化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InvalidateLightingCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">InvalidateLightingCacheDetailed</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当此组件已移动时调用，允许其丢弃静态缓存的光照信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InvalidateLightingCacheDetailed</span><span class="params">(<span class="keyword">bool</span> bInvalidateBuildEnqueuedLighting, <span class="keyword">bool</span> bTranslationOnly)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 bRenderStateDirty/bRenderTransformDirty 来执行此组件的所有必要工作</span></span><br><span class="line"><span class="comment">	 * 切勿直接调用此函数，调用 MarkRenderStateDirty, MarkRenderDynamicDataDirty</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @warning 此函数在多线程中并发调用 (但不能并发调用同一个组件)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoDeferredRenderUpdates_Concurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 重新计算此组件在世界空间中的变换 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">UpdateComponentToWorld</span><span class="params">(EUpdateTransformFlags UpdateTransformFlags = EUpdateTransformFlags::None, ETeleportType Teleport = ETeleportType::None)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将渲染状态标记为脏，将在帧末被发送到渲染线程 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MarkRenderStateDirty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 表明此组件的动态数据是否需要在帧末被发送 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MarkRenderDynamicDataDirty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 将变换标记为脏，将在帧末被发送到渲染线程 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MarkRenderTransformDirty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果我们属于某个世界，将此标记为一个延迟更新，否则马上处理(延迟更新位于帧末) */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MarkForNeededEndOfFrameUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 如果我们属于某个世界，将此标记为一个延迟更新，否则马上处理 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MarkForNeededEndOfFrameRecreate</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** 如果我们属于某个世界，清除执行延迟更新的请求 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ClearNeedEndOfFrameUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件是否需要在游戏线程进行帧末更新 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">RequiresGameThreadEndOfFrameUpdates</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件是否需要在游戏线程进行帧末重建 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">RequiresGameThreadEndOfFrameRecreate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件是否需要在帧末更新执行前同步任务 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">RequiresPreEndOfFrameSync</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 立即重建渲染状态。通常，您只需要调用 MarkRenderStateDirty 来代替此函数即可 </span></span><br><span class="line"><span class="comment">	 * @warning 此函数在多线程中并发调用 (但不能并发调用同一个组件)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RecreateRenderState_Concurrent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 立即重建物理状态 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RecreatePhysicsState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 是否为此组件创建渲染状态 (如: 场景代理) */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsRenderStateCreated</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bRenderStateCreated;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 是否为此组件创建物理状态 (如: physx bodies) */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsPhysicsStateCreated</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bPhysicsStateCreated;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回与此自建关联的渲染场景 */</span></span><br><span class="line">	<span class="function">class FSceneInterface* <span class="title">GetScene</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 返回此组件所在的 ULevel */</span></span><br><span class="line">	<span class="function">ULevel* <span class="title">GetComponentLevel</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此 actor 是否被包含在 TestLevel 中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ComponentIsInLevel</span><span class="params">(<span class="keyword">const</span> class ULevel *TestLevel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件是否在主关卡中 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ComponentIsInPersistentLevel</span><span class="params">(<span class="keyword">bool</span> bIncludeLevelStreamingPersistent)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当 Actor 的 bEnableCollisionChanged 标志改变时，在所有的组件中调用 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnActorEnableCollisionChanged</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 返回此组件的一个可读名称，包含资源名称(如果适用)</span></span><br><span class="line"><span class="comment">     * 默认情况下，会附加一个空格加上AdditionalStatObject()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FString <span class="title">GetReadableName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UObject <span class="keyword">const</span>* <span class="title">AdditionalStatObject</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在重新构建脚本期间丢弃组件之前调用，以缓存我们希望在该操作中保留的任何数据 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TStructOnScope&lt;FActorComponentInstanceData&gt; <span class="title">GetComponentInstanceData</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//~ Begin UObject Interface.</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginDestroy</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">NeedsLoadForClient</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">NeedsLoadForServer</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">NeedsLoadForEditorGame</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsNameStableForNetworking</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsSupportedForNetworking</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> int32 <span class="title">GetFunctionCallspace</span><span class="params">( UFunction* Function, FFrame* Stack )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CallRemoteFunction</span><span class="params">( UFunction* Function, <span class="keyword">void</span>* Parameters, FOutParmRec* OutParms, FFrame* Stack )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostInitProperties</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostLoad</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Rename</span><span class="params">( <span class="keyword">const</span> TCHAR* NewName=<span class="literal">NULL</span>, UObject* NewOuter=<span class="literal">NULL</span>, ERenameFlags Flags=REN_None )</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PostRename</span><span class="params">(UObject* OldOuter, <span class="keyword">const</span> FName OldName)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(FArchive&amp; Ar)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//~ End UObject Interface.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//~ Begin IInterface_AssetUserData Interface</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddAssetUserData</span><span class="params">(UAssetUserData* InUserData)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RemoveUserDataOfClass</span><span class="params">(TSubclassOf&lt;UAssetUserData&gt; InUserDataClass)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UAssetUserData* <span class="title">GetAssetUserDataOfClass</span><span class="params">(TSubclassOf&lt;UAssetUserData&gt; InUserDataClass)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="comment">//~ End IInterface_AssetUserData Interface</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 所属 Actor 当前是否正在运行 UCS */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsOwnerRunningUserConstructionScript</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件当前是否已经注册 */</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">IsRegistered</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bRegistered; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 检查此组件的类是否允许在 ReregisterAllComponents 期间重新注册*/</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">AllowReregistration</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bAllowReregistration; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 注册此组件，创建所有 渲染/物理 状态，同时将自己添加到所属 actor 的 Components 数组里 (如果未存在) */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RegisterComponent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 注销此组件，销毁所有 渲染/物理 状态 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UnregisterComponent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 注销此组件，将其从所属 actor 的 Components 数组中移除，并将其标记为 pengding kill */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DestroyComponent</span><span class="params">(<span class="keyword">bool</span> bPromoteChildren = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 组件创建(未读取)时调用，可以在编辑器或游戏中发生 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnComponentCreated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 组件被销毁后调用</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * @param	bDestroyingHierarchy  - 如果正在拆除整个组件层次结构，则为True，这样可以避免昂贵的操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnComponentDestroyed</span><span class="params">(<span class="keyword">bool</span> bDestroyingHierarchy)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 注销并将组件标记为 pending kill。此函数应该在所属的 actor 中调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Components&quot;</span>, meta=(Keywords = <span class="string">&quot;Delete&quot;</span>, HidePin=<span class="string">&quot;Object&quot;</span>, DefaultToSelf=<span class="string">&quot;Object&quot;</span>, DisplayName = <span class="string">&quot;DestroyComponent&quot;</span>, ScriptName = <span class="string">&quot;DestroyComponent&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">K2_DestroyComponent</span><span class="params">(UObject* Object)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 注销并立即重新注册此组件 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReregisterComponent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 改变此组件的 ticking 组 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetTickGroup</span><span class="params">(ETickingGroup NewTickGroup)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 使此组件在 PrerequisiteActor 后进行 tick */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddTickPrerequisiteActor</span><span class="params">(AActor* PrerequisiteActor)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 使此组件在 PrerequisiteComponent 后进行 tick */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddTickPrerequisiteComponent</span><span class="params">(UActorComponent* PrerequisiteComponent)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在 PrerequisiteActor 中移除 tick 依赖 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RemoveTickPrerequisiteActor</span><span class="params">(AActor* PrerequisiteActor)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 在 PrerequisiteComponent 中移除 tick 依赖 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities&quot;</span>, meta=(Keywords = <span class="string">&quot;dependency&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RemoveTickPrerequisiteComponent</span><span class="params">(UActorComponent* PrerequisiteComponent)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 提供给蓝图添加 tick 函数执行逻辑的方法，在 Tick 中调用 */</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(DisplayName = <span class="string">&quot;Tick&quot;</span>))</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ReceiveTick</span><span class="params">(<span class="keyword">float</span> DeltaSeconds)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 在所属 actor 发生位置移动时调用</span></span><br><span class="line"><span class="comment">	 * 组件应该更新所有相关数据结构以反应新的 actor 位置</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * @param InWorldOffset	 表示此 actor 已移动的偏移的向量</span></span><br><span class="line"><span class="comment">	 * @param bWorldShift	 此调用是否为整个世界移动的一部分</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ApplyWorldOffset</span><span class="params">(<span class="keyword">const</span> FVector&amp; InOffset, <span class="keyword">bool</span> bWorldShift)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此组件是否可能导航 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">CanEverAffectNavigation</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置 bCanEverAffectNavigation 标记的值，并更新导航八叉树(如果需要) */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetCanEverAffectNavigation</span><span class="params">(<span class="keyword">bool</span> bRelevant)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 重载以验证此组件是否与导航系统相关 */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsNavigationRelevant</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于标识模板组件实例的前缀 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> FString ComponentTemplateNameSuffix;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DECLARE_MULTICAST_DELEGATE_OneParam</span>(FOnMarkRenderStateDirty, UActorComponent&amp;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当渲染状态被标记为脏数据时触发 */</span></span><br><span class="line">	<span class="keyword">static</span> FOnMarkRenderStateDirty MarkRenderStateDirtyEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** 确保导航系统拥有关于组件导航相关性的最新信息，以及是否影响导航</span></span><br><span class="line"><span class="comment">	 *	@param bForceUpdate 默认情况下，仅当组件已注册时，才会更新导航系统。将 bForceUpdate 设置为 true 将覆盖检查</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">HandleCanEverAffectNavigationChange</span><span class="params">(<span class="keyword">bool</span> bForceUpdate = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearNeedEndOfFrameUpdate_Internal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FMarkComponentEndOfFrameUpdateState</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FSetUCSSerializationIndex</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FActorComponentInstanceData</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FActorComponentDetails</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FComponentReregisterContextBase</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FComponentRecreateRenderStateContext</span>;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">FActorComponentTickFunction</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//~ Begin Methods for Replicated Members (用于已复制的成员的函数)</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置 bReplicates 的值，不影响此实例的其他部分</span></span><br><span class="line"><span class="comment">	 * 此函数只应该在组件构造时调用</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 此方法的存在是为了允许代码直接更改 bReplicates，以维护现有行为</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetIsReplicatedByDefault</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> bNewReplicates)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取 bReplicates 的属性名</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 此函数是为了让子类不需要直接访问 bReplicates 属性而存在的，以便其可以在后面被设置为私有</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FName <span class="title">GetReplicatesPropertyName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GET_MEMBER_NAME_CHECKED</span>(UActorComponent, bReplicates);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置 bIsActive 的值，不影响此实例的其他部分 </span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Activate, Deactivate 和 SetActive 在大多数情况下是首选的，因为它们遵循虚函数的行为</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetActiveFlag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> bNewIsActive)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//~ End Methods for Replicated Members.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 简便方法，用于测试我们的 owner 是否仍然在被构造或初始化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">OwnerNeedsInitialization</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 简便方法，用于测试我们是否仍然在被构造或初始化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">NeedsInitialization</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>&quot;ActorComponent&quot; 可以说是整个框架中的 &quot;叶子节点&quot;。因为他不像 &quot;Level&quot;，可以拥有多个 &quot;Actor&quot;，不像 &quot;World&quot; 可以拥有多个 &quot;Level&quot;。&quot;ActorComponent&quot; 只是纯粹地用于实现并集成某种功能，如：实现物理碰撞，静态网格体渲染等等。所以 &quot;ActorComponent&quot; 的代码也比较集中，主要都是处理自身的一些逻辑，包括：渲染，物理，注册注销，以及 gameplay 的一些逻辑 (BeginPlay，Tick，EndPlay 等)，当然还有一些处理网络，导航，Owner 的逻辑，开发中其实还是比较有用的。</p><hr><p>下一篇：Gameplay —— APawn &amp; AController &amp; APlayerController</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-01-02 15:38:03" itemprop="dateModified" datetime="2022-01-02T15:38:03+08:00">2022-01-02</time> </span><span id="2021/12/06/UE4/UE4CPP/Gameplay —— AActor & UActorComponent/" class="item leancloud_visitors" data-flag-title="Gameplay —— AActor & UActorComponent" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" title="Gameplay —— AActor &amp; UActorComponent">https://kotori_suki.github.io/2021/12/06/UE4/UE4CPP/Gameplay —— AActor & UActorComponent/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeyonbf9j20zk0m8e81.jpg" title="Gameplay —— FWorldContext &amp; UWorld &amp; ULevel"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Gameplay</span><h3>Gameplay —— FWorldContext & UWorld & ULevel</h3></a></div><div class="item right"><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicmnywqgpj20zk0m8dwx.jpg" title="Gameplay —— APawn &amp; AController &amp; APlayerController"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Gameplay</span><h3>Gameplay —— APawn & AController & APlayerController</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#gameplay-aactor-uactorcomponent"><span class="toc-number">1.</span> <span class="toc-text">Gameplay —— AActor &amp; UActorComponent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aactor"><span class="toc-number">1.1.</span> <span class="toc-text">AActor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#actorcomponent"><span class="toc-number">1.2.</span> <span class="toc-text">ActorComponent</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li class="active"><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">56</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="unreal引擎启动流程">unreal引擎启动流程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/Gameplay/" title="分类于 Gameplay">Gameplay</a></div><span><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" title="Gameplay —— AActor &amp; UActorComponent">Gameplay —— AActor & UActorComponent</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" title="Unreal 序列化~~~">Unreal 序列化~~~</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/25/CPPBase/%E7%AE%80%E5%8D%95%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="简单迭代器的实现">简单迭代器的实现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/16/CPPBase/CPP%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="C++内存管理">C++内存管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A6%82%E8%BF%B0/" title="分类于 概述">概述</a></div><span><a href="/2021/08/16/CPPBase/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%20&%20%E6%A6%82%E8%BF%B0/" title="设计模式六大原则 &amp; 概述">设计模式六大原则 & 概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/Strategy/" title="策略模式">策略模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/21/CPPBase/DesignPattern/State/" title="状态模式">状态模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/" title="分类于 插件制作">插件制作</a></div><span><a href="/2021/08/05/UE4/UE4Plugin/UE4_Plugin/" title="UE4 Plugin">UE4 Plugin</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/16/CPPBase/C++%E6%8C%87%E9%92%88/" title="C++指针">C++指针</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/12/06/UE4/UE4CPP/Gameplay —— AActor & UActorComponent/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>