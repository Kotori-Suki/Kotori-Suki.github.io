<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"><title>Unreal 异步与并行编程 - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unreal 异步与并行编程</h1><div class="meta"><span class="item" title="创建时间：2021-12-30 10:12:48"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-12-30T10:12:48+08:00">2021-12-30</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclfb3vzhj20zk0m8wny.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeu1usa7j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="unreal-异步与并行编程"><a class="anchor" href="#unreal-异步与并行编程">#</a> Unreal 异步与并行编程</h1><p>简介：** 异步和并行编程可以在游戏运行遇到较为繁重的任务时 (如：GC)，将其分解或异步处理，从而使游戏保持良好的帧率。**Unreal 的底层语言是 C++，UE4 和 C++ 提供的异步和并行编程的接口也大体相同。但 UE4 提供的功能更多，要求程序员掌握 / 实现的函数也更多一些。** 本篇将以 C++ / UE4 对比的方式，介绍与异步和并行编程相关的类与函数，并分析这些函数在 UE4 中的底层实现机制。** 本篇解析的结构包括：&quot;TPromise&lt;T&gt;&quot; , &quot;TFuture&lt;T&gt;&quot; , &quot;FPlatformAtomics&quot; , &quot;FRunableThread&quot; , &quot;FAsyncTask&quot; , &quot;FTaskGraph&quot; , &quot;ParallelFor&quot;, &quot;FCriticalSection&quot; , &quot;FScopeLock&quot; 等。本篇任务比较繁重 ( 然而写者的脑子做不到并行处理 😦 )，赶紧开始吧～～～</p><p>异步处理和对游戏帧率的影响实测参考：</p><ul><li>[<span class="exturl" data-url="aHR0cDovL2hpc3RvcmlhLmNvLmpwL2FyY2hpdmVzLzYwMTQ=">UE4] 非同期処理を実装する | historia Inc - 株式会社ヒストリア</span></li></ul><h2 id="tpromiset-stdpromiset"><a class="anchor" href="#tpromiset-stdpromiset">#</a> TPromise&lt;T&gt; &amp; std::promise&lt;T&gt;</h2><p><code>std::promise&lt;T&gt;</code> 是 C++11 中的模板类，通常与 <code>std::future&lt;T&gt;</code> 一起使用，以保证并行编程时数据获取的正确性。其使用方法如下：</p><p></p><figure class="highlight c++"><figcaption><span>TPromise</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_promise</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">auto</span> f = p.<span class="built_in">get_future</span>();	<span class="comment">// auto = std::future&lt;int&gt;</span></span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">2333</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Async/Future.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ue4_promise</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TPromise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">auto</span> f = p.<span class="built_in">GetFuture</span>();		<span class="comment">// auto = TFuture&lt;int&gt;</span></span><br><span class="line">    p.<span class="built_in">SetValue</span>(<span class="number">2333</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用方法几乎一致。底层实现代码留到 <code>TFuture&lt;T&gt;</code> 中一起分析</p><h2 id="tfuturet-stdfuturet"><a class="anchor" href="#tfuturet-stdfuturet">#</a> TFuture&lt;T&gt; &amp; std::future&lt;T&gt;</h2><p><code>std::future&lt;T&gt;</code> 表示未来将在其他线程中获取的值。其对象中包含一个布尔变量，记录当前对象是否已获取，使用 <code>future&lt;T&gt;</code> 内的数据时应判断其是否有效。使用方法如下：</p><p></p><figure class="highlight c++"><figcaption><span>TFuture</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_future</span><span class="params">(std::future&lt;<span class="keyword">int</span>&gt; &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不阻塞线程</span></span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">wait_for</span> (std::chrono::<span class="built_in">seconds</span>(<span class="number">0</span>)) == std::future_status::ready)</span><br><span class="line">        <span class="keyword">auto</span> result = f.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Async/Future.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ue4_future</span><span class="params">(TFuture&lt;<span class="keyword">int</span>&gt; &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不阻塞线程</span></span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">IsReady</span>())</span><br><span class="line">        <span class="keyword">auto</span> result = f.<span class="built_in">Get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以上方法都是不阻塞线程的，不能保证运行后 if 程序体必定执行。可以将此函数添加到 &quot;FutureState&quot; 的回调中确保其执行，也可以在此函数外层阻塞线程，亦或是作为 &quot;TaskGraph&quot; 的前置任务等方式实现。接下来看看， <code>TPromise&lt;T&gt;</code> 与 <code>TFuture&lt;T&gt;</code> 在 UE4 中的底层实现机制，类图如下：</p><p><img data-src="TPromise&amp;TFuture%E7%B1%BB%E5%9B%BE.png" alt="FPromise&amp;FFuture类图"></p><p><code>TPromise&lt;T&gt;</code> 和 <code>TFuture&lt;T&gt;</code> 中的 <code>TFutureState* State</code> 实际上指向同一个对象。在 <code>TPromise&lt;T&gt;</code> 调用了 <code>SetValue</code> 后， <code>State</code> 将被赋值，而 <code>State</code> 中的 <code>Complete</code> 原子布尔值也将被设置为 true，此后 <code>State</code> 的值将不再允许被改变， <code>TFuture&lt;T&gt;</code> 也可以获取到 <code>State</code> 中的值，从而实现多线程使用数据的安全。另外， <code>State</code> 可以在 <code>TFuture&lt;T&gt;</code> 中调用 <code>Reset</code> 重置。</p><h2 id="fplatformatomics"><a class="anchor" href="#fplatformatomics">#</a> FPlatformAtomics</h2><p>&quot;FPlatformAtomics&quot; 为平台通用的原子操作函数库，定义了各种对普通变量的原子操作函数。如： <code>InterlockedIncrement</code> , <code>InterlockedExchange</code> 等。其子类分别实现不同平台对应的原子操作函数，以下是 GCC/Clang 对原子操作系统函数的实现。</p><p></p><figure class="highlight c++"><figcaption><span>FClangPlatformAtomics</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GCC/Clang implementation of the Atomics OS functions</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CORE_API</span> <span class="title">FClangPlatformAtomics</span> :</span> <span class="keyword">public</span> FGenericPlatformAtomics</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> FORCEINLINE int32 <span class="title">InterlockedIncrement</span><span class="params">(<span class="keyword">volatile</span> int32* Value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __atomic_fetch_add(Value, <span class="number">1</span>, __ATOMIC_SEQ_CST) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> FORCEINLINE int32 <span class="title">InterlockedExchange</span><span class="params">(<span class="keyword">volatile</span> int32* Value, int32 Exchange)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __atomic_exchange_n(Value, Exchange, __ATOMIC_SEQ_CST);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>熟悉 GCC/Clang 的朋友应该对上面的函数比较了解。 <code>__atomic_fetch_add</code> 实际上就是 GCC/Clang 中加运算符的原子操作函数，而 <code>__ATOMIC_SEQ_CST</code> 表示双向完全屏障的内存模型，与所有线程中的获取加载和释放存储同步。</p><p>对于其他平台语言也会由相关的实现，不再展开。</p><h2 id="frunnablethread-stdthread"><a class="anchor" href="#frunnablethread-stdthread">#</a> FRunnableThread &amp; std::thread</h2><p><code>std::thread</code> 是 C++11 中使用多线程最原始的线程类。Unreal 中对应实现为 <code>FRunnableThread</code> 类。虽说是复刻，但实际上还是有许多不同的地方。咱先看看使用方法上的区别：</p><p></p><figure class="highlight c++"><figcaption><span>FRunableThread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_thread</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt;&amp;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="built_in">thread</span>([=, p = <span class="built_in">move</span>(p)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        p.<span class="built_in">set_value</span>(<span class="number">2333</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HAL/RunnableThread.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Async/Future.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ue4_thread</span><span class="params">(TPromise&lt;<span class="keyword">int</span>&gt;&amp;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_type</span> :</span> <span class="keyword">public</span> FRunnable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">r_type</span>(TPromise&lt;<span class="keyword">int</span>&gt;&amp;&amp; p_) : <span class="built_in">p</span>(<span class="built_in">MoveTemp</span>(p_)) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="function">uint32 <span class="title">Run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; p.<span class="built_in">SetValue</span>(<span class="number">2333</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Exit</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        TPromise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    &#125; <span class="built_in">r</span>(<span class="built_in">MoveTemp</span>(p));</span><br><span class="line">    </span><br><span class="line">    EThreadPriority InThreadPri= TPri_Highest;</span><br><span class="line">    <span class="keyword">auto</span> t = FRunnableThread::<span class="built_in">Create</span>(&amp;r, <span class="built_in">TEXT</span>(<span class="string">&quot;promise-future tester&quot;</span>), <span class="number">0</span>, InThreadPri);</span><br><span class="line">    t.<span class="built_in">WaitForCompletion</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>UE4 中创建原始线程远比 C++ 中的麻烦，但其实使用思路都是一样的。首先创建一个线程类 (包含此线程运行所需的数据和函数)，然后启用一个线程运行该线程类中的函数。UE4 中声明线程之所以繁琐，其原因是 UE4 中的异步任务 &quot;FAsyncTask&quot; 实际上也是基于 &quot;FRunableThread&quot; 的，而这些任务都服从 &quot;Framework&quot; 的管理，因此需要额外实现一些用于管理线程的函数，如: Suspend, Kill 等。</p><p>以下是 &quot;FRunnable&quot; 与 &quot;FRunnableThread&quot; 底层实现机制的分析。</p><h3 id="frunnable-frunablethread"><a class="anchor" href="#frunnable-frunablethread">#</a> FRunnable &amp; FRunableThread</h3><p><code>FRunnable</code> 是 &quot;可执行&quot; 对象的接口。可执行对象指可以在任何线程中执行的对象。调用方法模板有 <code>Init()</code> , <code>Run()</code> , <code>Exit()</code> , <code>Stop()</code> . 可执行对象会按照函数语义在合适的时候调用适当的函数。所有初始化在 <code>Init()</code> 中完成，初始化失败将返回错误代码。成功则调用 <code>Run()</code> 以完成此线程的工作。完成后将调用 <code>Exit()</code> 以允许正确的清理。以下是 &quot;FRunnable&quot; 类的代码实现：</p><p></p><figure class="highlight c++"><figcaption><span>FRunnable</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runnable.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORE_API</span> <span class="title">FRunnable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> uint32 <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> class FSingleThreadRunnable* <span class="title">GetSingleThreadInterface</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">FRunnable</span>() &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><code>FRunnable</code> 将我们线程所需执行的所有函数分类集成起来，提供给 <code>FRunableThread</code> 在管理其生命周期时按需调用。将 <code>FRunnable</code> 独立出来亦可以方便开发时使用。</p><p><code>FRunableThread</code> 是可执行线程的接口，指定用于管理线程生命周期的方法。代码结构如下：</p><p></p><figure class="highlight c++"><figcaption><span>FRunnableThread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunnableThread.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORE_API</span> <span class="title">FRunnableThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> FRunnableThread* <span class="title">Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        class FRunnable* InRunnable,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> TCHAR* ThreadName,</span></span></span><br><span class="line"><span class="params"><span class="function">        uint32 InStackSize = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        EThreadPriority InThreadPri = TPri_Normal,</span></span></span><br><span class="line"><span class="params"><span class="function">        uint64 InThreadAffinityMask = FPlatformAffinity::GetNoAffinityMask(),</span></span></span><br><span class="line"><span class="params"><span class="function">        EThreadCreateFlags InCreateFlags = EThreadCreateFlags::None)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetThreadPriority</span><span class="params">( EThreadPriority NewPriority )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Suspend</span><span class="params">( <span class="keyword">bool</span> bShouldPause = <span class="literal">true</span> )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Kill</span><span class="params">( <span class="keyword">bool</span> bShouldWait = <span class="literal">true</span> )</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WaitForCompletion</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 线程名称 */</span></span><br><span class="line">	FString ThreadName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 此线程上运行的可执行对象 */</span></span><br><span class="line">	FRunnable* Runnable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 线程初始化同步事件，确保 Init() 在允许主线程继续前完成 */</span></span><br><span class="line">	FEvent* ThreadInitSyncEvent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 线程亲缘性 */</span></span><br><span class="line">	uint64 ThreadAffinityMask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** FTlsAutoCleanup 数组，需要在线程结束前删除这些实例 */</span></span><br><span class="line">	TArray&lt;FTlsAutoCleanup*&gt; TlsInstances;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 线程优先级 */</span></span><br><span class="line">	EThreadPriority ThreadPriority;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 创建线程时设定的ID */</span></span><br><span class="line">	uint32 ThreadID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从 Unreal 提供给我们的函数中也许你已经发现了使用 <code>FRunnableThread</code> 的方法。</p><ol><li>调用 <code>FRunnableThread::Create()</code> 创建线程，并保留其返回值的引用。</li><li>调用 <code>WaitForCompletion</code> 等待线程执行结束。</li><li>期间，可以调用 <code>Suspend()</code> 暂停 / 继续此线程的执行，也可以调用 <code>Kill()</code> 杀死线程</li><li>另外，还可以调用 <code>SetThreadPriority()</code> 来设置线程的优先级等。</li></ol><p>其中， <code>Create()</code> 函数将调用平台特定的创建线程方法，并调用 <code>SetupCreatedThread()</code> 设置该线程的相关属性和调用 Runnable 的 <code>Init()</code> 方法将其初始化，最后调用 <code>PostCreate()</code> 注册线程调试信息。其他的方法都基于平台 API 而不同，不做展开。</p><h2 id="fasynctask-stdasync"><a class="anchor" href="#fasynctask-stdasync">#</a> FAsyncTask &amp; std::async</h2><p><code>std::async</code> 是 C++11 创建异步任务的方法，其隐藏了线程创建内部的细节，方便开发者直接获取异步执行的状态和结果。对应于 Unreal 中的 <code>FAsyncTask</code> 类，使用方法如下：</p><p></p><figure class="highlight c++"><figcaption><span>FAsyncTask</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_async</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt;&amp;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">async</span>(std::launch::async, [&amp;]()&#123; p.<span class="built_in">set_value</span>(<span class="number">2333</span>); &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Async/AsyncWork.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Async/Future.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ue4_async</span><span class="params">(TPromise&lt;<span class="keyword">int</span>&gt;&amp;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">at_type</span> :</span> <span class="keyword">public</span> FNonAbandonableTask</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FAutoDeleteAsyncTask</span>&lt;</span>at_type&gt;;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">at_type</span>(<span class="keyword">const</span> TFuture&lt;<span class="keyword">int</span>&gt;&amp;&amp; p_) : <span class="built_in">p</span>(<span class="built_in">MoveTemp</span>(p_)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">()</span> </span>&#123; p.<span class="built_in">SetValue</span>(<span class="number">2333</span>); &#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">FORCEINLINE TStatId <span class="title">GetStatId</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="built_in">RETURN_QUICK_DECLARE_CYCLE_STAT</span>(at_type, STATGROUP_ThreadPoolAsyncTasks);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        TPromise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> FAutoDeleteAsyncTask&lt;at_type&gt;(<span class="built_in">MoveTemp</span>(p))-&gt;<span class="built_in">StartBackgroundTask</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以上程序语义上是完全一样的。如你所见，UE4 的异步任务创建就是如此麻烦。开发者首先需要创建一个任务类，然后调用 <code>FAsyncTask.StartTask()</code> 开始执行。相比 C++ 只需给定异步策略和异步函数即可执行的开发模式，UE4 要做的工作显然更繁琐。不过也得益于此，UE4 中的异步任务的执行也是完全在 Framework 的掌控之下的。有点 &quot;工作量换取灵活性&quot; 的感觉，不过写者更喜欢 UE4 对异步任务封装 的开发模式，因为在异步任务过多或过于复杂时，封装可以使条理更加清晰，可读性更高。</p><p>以下是对 &quot;FAsyncTask&quot; (异步任务) 系统底层实现机制的解析：</p><p><img data-src="AsyncTask.png" alt="AsyncTask"></p><p>从类图中可以发现，异步任务是基于线程池任务和线程池的。而线程池任务实际上也是可执行对象。这其实跟 C++ 实现 <code>std::async</code> 的初衷乃至思路都是一样的。 <code>FAsyncTask</code> (异步任务) 的存在免去了开发者与线程直接打交道的麻烦，开发者只需专注于制定任务即可，提高多线程程序开发效率。</p><p>接下来理清异步任务从创建到销毁的整个过程，都是怎么与线程池交互的，线程池又是怎么有序地执行异步任务的。</p><ol><li>首先我们调用 <code>FAsyncTask.Start()</code> 将异步任务添加到传入的线程池中 (异步任务也是线程池任务)；</li><li>接着线程池会将看看还有没有空闲线程，如果有，直接将空闲线程中调用 <code>DoWork</code> 执行此任务；</li><li>如果没有，则将此任务添加到 <code>QueuedWork</code> 数组中，等待有空闲线程时执行。</li><li><code>DoWork()</code> 中先给 <code>QueuedWork</code> 赋值，调用内存屏障 (更新 <code>QueuedWork</code> 的缓存) 后，激活 <code>DoWorkEvent</code></li><li>激活 <code>DoWorkEvent</code> 并不是指 <code>FEvent</code> 中存着异步任务，实际上是唤醒其关联的线程，让线程执行相关异步任务。</li><li>异步任务完成后或被意外终止时，将调用 <code>KillThread()</code> 关闭 <code>DoWorkEvent</code> 并将其返回事件池中，最后关闭并销毁线程。</li></ol><p>过程大致如此，如果想了解更多细节，请自行翻看源码。</p><h2 id="parallelfor-stdfor_each"><a class="anchor" href="#parallelfor-stdfor_each">#</a> ParallelFor &amp; std::for_each</h2><p><code>std::for_each</code> 是 C++17 中引入的并行处理多任务的函数，对应 UE4 中的 <code>ParallelFor</code> 。其使用方法如下：</p><p></p><figure class="highlight c++"><figcaption><span>ParallelFor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execution&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_for_each</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::for_each(std::execution::par, v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [=](<span class="keyword">const</span> <span class="keyword">int</span> i)&#123;</span><br><span class="line">        std::cout &lt;&lt; i * i &lt;&lt; endl;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Async/ParallelFor.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ue4_ParallelFor</span><span class="params">(<span class="keyword">const</span> TArray&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ParallelFor</span>( v.<span class="built_in">size</span>(), [=](int32 i)&#123;</span><br><span class="line">        std::cout &lt;&lt; v[i] * v[i] &lt;&lt; endl;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;ParallelFor&quot; 函数其实并不只是 C++ 和 UE4 才有，很多其他语言其实也都有对应的实现。 <strong>&quot;ParallelFor&quot; 原译为并行遍历，是不依赖线程池 改用任务图表的 另一种并行编程策略，主要用于处理某些逻辑单一但却极为繁重的任务</strong>，如: GC 时对每一个 UObject 对象进行可达性分析。我们可以将需要分析的对象按当前空闲线程数平均分堆，然后每个线程负责其中一堆对象的处理。这时候你会发现，其实每个线程执行的任务都是一样的，只是分析的对象不同。&quot;ParallelFor&quot; 尤其擅长处理此类事务。</p><p>接下来，让咱看看 UE4 是怎么实现 &quot;ParallelFor&quot; 的 😃</p><p></p><figure class="highlight c++"><figcaption><span>ParallelForInternal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParallelFor.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ParallelForInternal</span><span class="params">(int32 Num, FunctionType Body, EParallelForFlags Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SCOPE_CYCLE_COUNTER</span>(STAT_ParallelFor);</span><br><span class="line">    <span class="built_in">check</span>(Num &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;AnyThreadTasks&quot; 表示可用于执行此任务的线程数</span></span><br><span class="line">    int32 AnyThreadTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> bIsMultithread = FApp::<span class="built_in">ShouldUseThreadingForPerformance</span>() || FForkProcessHelper::<span class="built_in">IsForkedMultithreadInstance</span>();</span><br><span class="line">    <span class="keyword">if</span> (Num &gt; <span class="number">1</span> &amp;&amp; (Flags &amp; EParallelForFlags::ForceSingleThread) == EParallelForFlags::None &amp;&amp; bIsMultithread)</span><br><span class="line">    &#123;</span><br><span class="line">        AnyThreadTasks = FMath::Min&lt;int32&gt;(FTaskGraphInterface::<span class="built_in">Get</span>().<span class="built_in">GetNumWorkerThreads</span>(), Num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!AnyThreadTasks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有线程则直接执行后返回</span></span><br><span class="line">        <span class="keyword">for</span> (int32 Index = <span class="number">0</span>; Index &lt; Num; Index++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Body</span>(Index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> bPumpRenderingThread         = (Flags &amp; EParallelForFlags::PumpRenderingThread) != EParallelForFlags::None;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> bBackgroundPriority          = (Flags &amp; EParallelForFlags::BackgroundPriority) != EParallelForFlags::None;</span><br><span class="line">    <span class="keyword">const</span> ENamedThreads::Type DesiredThread = bBackgroundPriority ? ENamedThreads::AnyBackgroundThreadNormalTask : ENamedThreads::AnyHiPriThreadHiPriTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造并行处理数据</span></span><br><span class="line">    TParallelForData&lt;FunctionType&gt;* DataPtr = <span class="keyword">new</span> TParallelForData&lt;FunctionType&gt;(Num, AnyThreadTasks + <span class="number">1</span>, (Num &gt; AnyThreadTasks + <span class="number">1</span>) &amp;&amp; bPumpRenderingThread, Body, Flags);</span><br><span class="line">    TSharedRef&lt;TParallelForData&lt;FunctionType&gt;, ESPMode::ThreadSafe&gt; Data = <span class="built_in">MakeShareable</span>(DataPtr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建图表任务，并将其添加到对应线程中等待前置任务执行完成(ParallelFor函数没有前置任务)</span></span><br><span class="line">    TGraphTask&lt;TParallelForTask&lt;FunctionType&gt;&gt;::<span class="built_in">CreateTask</span>().<span class="built_in">ConstructAndDispatchWhenReady</span>(Data, DesiredThread, AnyThreadTasks - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让此线程也执行 &quot;TParallelForTask&quot; 中的任务，这对于防止递归死锁很重要</span></span><br><span class="line">    <span class="keyword">if</span> (!Data-&gt;<span class="built_in">Process</span>(<span class="number">0</span>, Data, DesiredThread, <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bPumpRenderingThread &amp;&amp; <span class="built_in">IsInActualRenderingThread</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Data-&gt;Event-&gt;<span class="built_in">Wait</span>(<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                FTaskGraphInterface::<span class="built_in">Get</span>().<span class="built_in">ProcessThreadUntilIdle</span>(ENamedThreads::<span class="built_in">GetRenderThread_Local</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Data-&gt;Event-&gt;<span class="built_in">Wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">check</span>(Data-&gt;bTriggered);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>(!Data-&gt;bTriggered);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">check</span>(Data-&gt;NumCompleted.<span class="built_in">GetValue</span>() == Data-&gt;Num);</span><br><span class="line">    Data-&gt;bExited = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// DoneEvent 在此等待，如果某个线程完成了最后一个任务</span></span><br><span class="line">    <span class="comment">// 数据必须被保留，直至所有任务被清除。可能是在退出此函数很久以后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果你是第一次接触 &quot;ParallelFor&quot; 函数，理解上面代码流程可能相对吃力。但没关系，让我们先看看这张类图：</p><p><img data-src="GraphTask.png" alt="GraphTask"></p><p>类图框架看起来很是复杂，但其实只是一层层的封装。主要的类及其介绍如下：</p><ul><li><code>FTaskGraphImplementation</code> (任务执行器) 是单例类，是包含管理图表任务的相关函数 (添加任务到任务队列，执行任务，等待任务完成，触发回调等) 的控制类。</li><li><code>FWorkerThread</code> (工作线程类)，只是对多个 <code>FRunnable</code> (可执行对象) 和 <code>FRunnableThread</code> (管理可执行对象生命周期的类) 的简单封装。</li><li><code>FTaskThreadBase</code> (任务线程类)，包含此线程需要执行的任务列表及 管理执行此线程中的任务的相关函数</li><li><code>FBaseGraphTask</code> (图表任务类)，封装执行单个任务所需的相关数据和函数</li><li><code>TParallelForTask&lt;FuncType&gt;</code> (并行遍历任务类)，此类作为 <code>TGraghTask&lt;Task&gt;</code> 的模板类，负责保存执行 &quot;ParallelFor&quot; 函数所需的相关数据。</li><li><code>FGenericTask</code> (通常任务类)，原码中对任务模板类的举例。不使用 <code>ParallelFor</code> 但想用任务图表系统时，我们需要自定义的任务类。其中包含 <code>GetDesiredThread</code> ， <code>DoTask</code> 等必须定义的函数接口。(具体可以查看：Engine/Source/Runtime/Core/Public/Async/TaskGraphInterfaces.h 下，第 734 行代码)</li></ul><p>好的，让咱回到 <code>ParallelFor</code> 函数执行过程的分析 (包含了任务图表系统的整个添加执行销毁流程)</p><ol><li>执行 <code>ParallelFor</code> 时，我们需要传入任务总数 (Num)，和任务函数 (函数类型为 &lt; void (int32&gt;)，后续执行任务函数时将从 0 到 Num 依次做为参数运行任务函数 (在不同线程中)。</li><li>判断是否可用多线程，不可用则直接单线程遍历执行后返回。如果可用则构造并行遍历数据 ( <code>TParallelForData&lt;FuncType&gt;</code> )，并用其创建并行图表任务 ( <code>TGraphTask&lt;TParallelForTask&lt;FuncType&gt;&gt;</code> )，并将此任务状态设为 &quot;Ready&quot;<ol><li>创建任务将调用 <code>TGraphTask&lt;...&gt;::CreateTask</code> ，创建并返回任务构造器 ( <code>FConstructor</code> )</li><li>任务构造器的创建，将设置此任务的前置任务及其拥有者等信息。</li><li>最后调用任务构造器的 <code>ConstructAndDispatchWhenReady</code> 函数，构成此任务到对应线程中，并将其状态设为 &quot;Ready&quot;<ol><li>调用 <code>TParallelForTask</code> 的构造函数，并初始化其前置任务，设置此任务的执行线程</li><li>调用 <code>TGraphTask</code> 的 <code>PrerequisitesComplete</code> 函数，将此任务添加到对应线程的任务执行列表中 (调用 <code>TGraphTask::QueueTask</code> )<ol><li>获取任务执行器单例，调用其 <code>QueueTask</code> 函数</li><li>如果此任务可以在任意线程运行，将其添加到 &quot;任务执行器的任意线程任务的对应优先级队列&quot; ( <code>FTaskGraphImplementation::IncomingAnyThreadTasks[Prority]</code> ) 中，开启该任务线程执行此任务 (调用 <code>WakeUp</code> )。否则将其运行线程设置为游戏线程</li><li>最后调用 <code>FTaskThreadBase::EnqueueFromThread</code> 将此任务添加到 &quot;对应线程执行对象的任务列表&quot; 中 ( <code>FNameTaskThread</code> 子类将添加到专用优先级任务列表中)</li></ol></li></ol></li></ol></li><li>线程 <code>WakeUp</code> 后依次执行任务， <code>ParallelFor</code> 中的任务是添加到任意线程队列中的。所以将调用空闲线程的 <code>ProcessTasksUntilQuit</code> 函数，进而调用 <code>ProcessTasks</code> 处理任务直至所有任务完成。</li><li><code>ProcessTasks</code> 函数则直接死循环调用所有任务 ( <code>TGraphTask</code> ) 的 <code>Execute</code> 函数，直至全部完成</li><li><code>Execute</code> 函数将调用 <code>TParallelForTask::DoTask</code> 函数，让此线程开始处理任务函数。与此同时，其他线程也将被 WakeUp，来处理此任务函数。并行处理任务函数，其函数参数将通过原子操作增加，以保证线程安全。当参数大于传入 Num 时，完成此次 <code>ParallelFor</code> 调用</li><li>另外 <code>Execute</code> 函数在调用完 <code>DoTask</code> 后将销毁自身，同时销毁其包含的 Task 任务。</li></ol><p>到此， &quot;ParallelFor&quot; 函数的执行流程 与 &quot;TaskGraph&quot; 并行编程的架构 已经完全分析完了。如果读者没有完全理解，建议依照类图翻翻源码，自己走一遍任务创建执行到销毁的整个流程就懂了 😃</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cDovL3VzYWdpLmhhdGVuYWJsb2cuanAvZW50cnkvMjAxNy8wNi8xMC8xMjI3MjA=">C++ 標準の promise /future/thread に対応する UE4 標準の TPromise / TFuture / FRunnableThread の使い方 - C++ ときどき ごはん、わりとてぃーぶれいく☆</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jcHByZWZqcC5naXRodWIuaW8vcmVmZXJlbmNlL2Z1dHVyZS5odG1s">future - cpprefjp C++ 日本語リファレンス</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jcHByZWZqcC5naXRodWIuaW8vcmVmZXJlbmNlL3RocmVhZC5odG1s">thread - cpprefjp C++ 日本語リファレンス</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLnVucmVhbGVuZ2luZS5jb20vVXNpbmdfQXN5bmNUYXNrcw==">Using AsyncTasks - Epic Wiki</span></li></ul><h2 id="fcriticalsection-stdmutex"><a class="anchor" href="#fcriticalsection-stdmutex">#</a> FCriticalSection &amp; std::mutex</h2><p>并行编程自然少不了临界区的数据访问。相对于 C++11 中的 <code>std::mutex</code> ，虚幻中使用则是 <code>FCriticalSection</code> ，先看看用法上的区别吧～～～</p><p></p><figure class="highlight c++"><figcaption><span>FCriticalSection</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="comment">// 作用域锁，C++17后可以省略模板类型</span></span><br><span class="line">    &#123; <span class="function">std::lock_guard&lt; <span class="title">decltype</span><span class="params">(m)</span> &gt; <span class="title">lock</span><span class="params">(m)</span></span>; &#125;</span><br><span class="line">    <span class="comment">// 手动操作</span></span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line">    m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Misc/ScopeLock.h&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    FCriticalSection m;</span><br><span class="line">    <span class="comment">// 作用域锁</span></span><br><span class="line">    &#123; <span class="function">FScopeLock <span class="title">lock</span><span class="params">(&amp;m)</span></span>; &#125;</span><br><span class="line">    <span class="comment">// 手动操作</span></span><br><span class="line">    m.<span class="built_in">Lock</span>();</span><br><span class="line">    m.<span class="built_in">Unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这就是所谓的 &quot;基因遗传&quot; 吗？(实在是太像了...)。另外，UE4 同时还支持 std 版的 lock_guard , adopt_lock , unique_lock 等。如无特殊情况，在 UE4/C++ 中使用 std 版也是完全没有问题的。</p><h2 id="frwlock-stdshared_mutex"><a class="anchor" href="#frwlock-stdshared_mutex">#</a> FRWLock &amp; std::shared_mutex</h2><p>std::shared_mutex 是 C++17 中支持的读写锁，对应到 UE4 是 FRWLock 类。即 多线程可同时对同一对象上读锁，而写锁则需单独占有此临界区资源。使用方法如下：</p><p></p><figure class="highlight c++"><figcaption><span>FRWLock</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_mutex m;</span><br><span class="line">    &#123; <span class="function">std::shared_lock&lt; <span class="title">decltype</span><span class="params">(m)</span> &gt; <span class="title">read_lock</span><span class="params">(m)</span></span>; &#125;</span><br><span class="line">    &#123; <span class="function">std::lock_guard&lt; <span class="title">decltype</span><span class="params">(m)</span> &gt; <span class="title">write_lock</span><span class="params">(m)</span></span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_timed_mutex m;</span><br><span class="line">    &#123; <span class="function">std::shared_lock&lt; <span class="title">decltype</span><span class="params">(m)</span> &gt; <span class="title">read_lock</span><span class="params">(m)</span></span>; &#125;</span><br><span class="line">    &#123; <span class="function">std::lock_guard&lt; <span class="title">decltype</span><span class="params">(m)</span> &gt; <span class="title">write_lock</span><span class="params">(m)</span></span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Misc/ScopeRWLock.h&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    FRWLock m;</span><br><span class="line">    <span class="comment">// 作用域锁</span></span><br><span class="line">    &#123; <span class="function">FRWScopeLock <span class="title">read_lock</span><span class="params">(m, FRWScopeLockType::SLT_ReadOnly)</span></span>; &#125;</span><br><span class="line">    &#123; <span class="function">FRWScopeLock <span class="title">write_lock</span><span class="params">(m, FRWScopeLockType::SLT_Write)</span></span>; &#125;</span><br><span class="line">    <span class="comment">// 手动操作</span></span><br><span class="line">    m.<span class="built_in">ReadLock</span>();</span><br><span class="line">    m.<span class="built_in">ReadUnLock</span>();</span><br><span class="line">    m.<span class="built_in">WriteLock</span>();</span><br><span class="line">    m.<span class="built_in">WriteUnLock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>锁的行为根据平台不同而不同，不过原理都是差不多的。咱就不做咱开了。</p><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jcHByZWZqcC5naXRodWIuaW8vcmVmZXJlbmNlL3NoYXJlZF9tdXRleC9zaGFyZWRfbXV0ZXguaHRtbA==">shared_mutex - cpprefjp C++ 日本語リファレンス</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jcHByZWZqcC5naXRodWIuaW8vcmVmZXJlbmNlL3NoYXJlZF9tdXRleC9zaGFyZWRfdGltZWRfbXV0ZXguaHRtbA==">shared_timed_mutex - cpprefjp C++ 日本語リファレンス</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jcHByZWZqcC5naXRodWIuaW8vcmVmZXJlbmNlL3NoYXJlZF9tdXRleC9zaGFyZWRfbG9jay5odG1s">shared_lock - cpprefjp C++ 日本語リファレンス</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jcHByZWZqcC5naXRodWIuaW8vcmVmZXJlbmNlL211dGV4L2xvY2tfZ3VhcmQuaHRtbA==">lock_guard - cpprefjp C++ 日本語リファレンス</span></li><li><a target="_blank" rel="noopener" href="https://qiita.com/usagi/items/4f4ee0df34688fa5c503">C<ins>17, C</ins>14, C++11 に併せた std::shared_mutex, std::shared_timed_mutex, std::mutex から mutex_type, read_lock_type, write_lock_type を扱う例 - Qiita</a></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VwaWNHYW1lcy9VbnJlYWxFbmdpbmUvYmxvYi80LjE4L0VuZ2luZS9Tb3VyY2UvUnVudGltZS9Db3JlL1B1YmxpYy9XaW5kb3dzL1dpbmRvd3NDcml0aWNhbFNlY3Rpb24uaCNMMTE0">https://github.com/EpicGames/UnrealEngine/blob/4.18/Engine/Source/Runtime/Core/Public/Windows/WindowsCriticalSection.h#L114</span></li></ul><h2 id="总结与结语"><a class="anchor" href="#总结与结语">#</a> 总结与结语：</h2><p>本篇从 C++ / UE4 关于异步的 API 使用方法入手，介绍了 UE4 与 C++ 对于并行程序编程之间的异同。对于每种创建多线程的方法，我们也都分析了其在 UE4 中的底层实现机制 (如：线程池，任务图表等)。最后还对比了 C++ 与 UE4 中对于锁的支持，及其使用方式的差异。希望对你有所帮助～～～</p><p>虽然并行编程对于客户端开发来说接触得可能不是很多，但个人觉得很有学习的必要。毕竟游戏运行是非常消耗硬件性能的，如果我们可以在适当的地方引入并行处理方法进行优化。将复杂的任务分配给多个线程执行，如此提高程序对于复杂任务的处理能力的同时，还可以让游戏保持一个不错的帧率，保证良好的游戏体验 (掉帧可就太难受了啊...)</p><p>最后预祝读者们元旦快乐 😃</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-01-02 15:46:00" itemprop="dateModified" datetime="2022-01-02T15:46:00+08:00">2022-01-02</time> </span><span id="2021/12/30/UE4/UE4CPP/Unreal 异步与并行编程/" class="item leancloud_visitors" data-flag-title="Unreal 异步与并行编程" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" title="Unreal 异步与并行编程">https://kotori_suki.github.io/2021/12/30/UE4/UE4CPP/Unreal 异步与并行编程/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciszlczyj20zk0m816d.jpg" title="Custom Item Module"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> ModuleDesign</span><h3>Custom Item Module</h3></a></div><div class="item right"><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicm0n457cj20zk0m8e81.jpg" title="Unreal MovementComponent 源码解析"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal MovementComponent 源码解析</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unreal-%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Unreal 异步与并行编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tpromiset-stdpromiset"><span class="toc-number">1.1.</span> <span class="toc-text">TPromise&lt;T&gt; &amp; std::promise&lt;T&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tfuturet-stdfuturet"><span class="toc-number">1.2.</span> <span class="toc-text">TFuture&lt;T&gt; &amp; std::future&lt;T&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fplatformatomics"><span class="toc-number">1.3.</span> <span class="toc-text">FPlatformAtomics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frunnablethread-stdthread"><span class="toc-number">1.4.</span> <span class="toc-text">FRunnableThread &amp; std::thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#frunnable-frunablethread"><span class="toc-number">1.4.1.</span> <span class="toc-text">FRunnable &amp; FRunableThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fasynctask-stdasync"><span class="toc-number">1.5.</span> <span class="toc-text">FAsyncTask &amp; std::async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parallelfor-stdfor_each"><span class="toc-number">1.6.</span> <span class="toc-text">ParallelFor &amp; std::for_each</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fcriticalsection-stdmutex"><span class="toc-number">1.7.</span> <span class="toc-text">FCriticalSection &amp; std::mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frwlock-stdshared_mutex"><span class="toc-number">1.8.</span> <span class="toc-text">FRWLock &amp; std::shared_mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%93%E8%AF%AD"><span class="toc-number">1.9.</span> <span class="toc-text">总结与结语：</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li><li><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" rel="bookmark" title="Unreal Slate">Unreal Slate</a></li><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li><li><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></li><li><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="bookmark" title="Custom Item Module">Custom Item Module</a></li><li class="active"><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></li><li><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">54</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" title="FProperty的分析与总结">FProperty的分析与总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/21/CPPBase/DesignPattern/Decorater/" title="装饰器模式">装饰器模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/16/CPPBase/map%E4%B8%8Eunordered_map%E7%9A%84%E5%8C%BA%E5%88%AB/" title="map与unordered_map">map与unordered_map</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" title="反射系统API  解析和使用">反射系统API 解析和使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/" title="分类于 插件制作">插件制作</a></div><span><a href="/2021/08/05/UE4/UE4Plugin/UE4_Plugin/" title="UE4 Plugin">UE4 Plugin</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/Observe/" title="观察者模式">观察者模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" title="Unreal GC过程">Unreal GC过程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 操作系统">操作系统</a></div><span><a href="/2021/08/17/ComputerBase/OperatingSystem/32%E4%BD%8D64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E3%80%81%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" title="32位64位系统、字节对齐">32位64位系统、字节对齐</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="unreal引擎启动流程">unreal引擎启动流程</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/12/30/UE4/UE4CPP/Unreal 异步与并行编程/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>