<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2021/11/26/UE4/UE4CPP/Unreal%20Slate/"><title>Unreal Slate - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unreal Slate</h1><div class="meta"><span class="item" title="创建时间：2021-11-26 09:39:26"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-11-26T09:39:26+08:00">2021-11-26</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciryrr3rj20zk0m8nhk.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2021/11/26/UE4/UE4CPP/Unreal%20Slate/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="unreal-slate"><a class="anchor" href="#unreal-slate">#</a> Unreal Slate</h1><p>简介：本篇将从编辑器的 &quot;Detail&quot; 面板开始，分析 &quot;SDetailView&quot; 的底层实现，紧接着总结实现简单 Slate 类所需要的步骤，最后做一个给蓝图用的 &quot;高达零件&quot; 😃</p><h2 id="从-widget-reflector-开始"><a class="anchor" href="#从-widget-reflector-开始">#</a> 从 Widget Reflector 开始</h2><p>&quot;Widget Reflector&quot; (Widget 反射器) 是虚幻<strong>提供给开发者查看编辑器中 Widget 的布局</strong>的一个工具，也可以说是一个内嵌的插件 (我们讲插件的时候会具体分析 &quot;Widget Reflector&quot; 的具体实现)。那么我们先看看怎么用这个工具吧 😃</p><p><img data-src="Widget_Reflector.png" alt="Widget_Reflector"></p><p>使用方法：</p><ul><li>Menu Bar -&gt; Window -&gt; Developer Tools -&gt; Widget Reflector</li><li>点击绿色框框的 &quot;Pick Widget&quot;，然后将光标移动到你想查看的 &quot;Widget&quot; 中</li><li>按下 Esc 键，即可定格当前 &quot;Widget&quot; 定位</li></ul><p>可以看到我们上面定位的是 编辑器主界面的 Details 面板，Widget 反射器中给我们的信息有：该 Widget 的布局与从属关系，Widget 的一些属性 (是否可见，当前是否 focus 等)，Widget 的源代码，Widget 的地址。Widget 反射器告诉我们，实现细节面板的源代码是 &quot;SDetailsView&quot;，那咱也是二话不说，直接分析 &quot;SDetailsView&quot; 的源码，开冲（￣︶￣）↗</p><h2 id="details-view-的实现"><a class="anchor" href="#details-view-的实现">#</a> Details View 的实现</h2><p>在分析 &quot;SDetailsView&quot; 的源码之前，我们需要知道虚幻的 Slate 框架有以下几个特点：</p><ul><li>Slate 类都是以 'S' 开头的，如：&quot;SDetialsView&quot;</li><li>Slate 类都继承于 &quot;SWidget&quot;，而不是 &quot;UObject&quot;</li><li>Slate 对象不受 GC 管理，所以通常用共享指针来构造 Slate 对象</li></ul><p>以下是 &quot;SDetailsView&quot; 的源码实现：</p><p></p><figure class="highlight c++"><figcaption><span>SDetailView</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailsView.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDetailsView</span> :</span> <span class="keyword">public</span> SDetailsViewBase</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FPropertyDetailsUtilities</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SLATE_BEGIN_ARGS</span>(SDetailsView)&#123;&#125;</span><br><span class="line">	<span class="built_in">SLATE_END_ARGS</span>()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ...... 省略代码后文分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;SDetailsView&quot; 一开始就给咱整了两个宏，&quot;SLATE_BEGIN_ARGS&quot; , SLATE_END_ARGS&quot;。从宏的名字来看，这俩似乎是一对的，用来定义 Slate 类的变量。事实也确实就是如此，我们直接看看宏定义吧。</p><p></p><figure class="highlight c++"><figcaption><span>SLATE_BEGIN_ARGS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeclarativeSyntaxSupport.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLATE_BEGIN_ARGS( WidgetType ) \</span></span><br><span class="line"><span class="meta">	public: \</span></span><br><span class="line"><span class="meta">	struct FArguments : public TSlateBaseNamedArgs<span class="meta-string">&lt;WidgetType&gt;</span> \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		typedef FArguments WidgetArgsType; \</span></span><br><span class="line"><span class="meta">		FORCENOINLINE FArguments()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLATE_END_ARGS() \</span></span><br><span class="line"><span class="meta">	&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>研究过 Slate 源码的同学应该知道，Slate 定义变量的宏其实还有很多。但其实都只不过是在定义一些 &quot;FArguments&quot; 的属性，实现上也比较简单，我们就不展开分析了。当然还有一些用来添加 Slot 和重载运算符的 (比如：SLATE_SUPPORTS_SLOT) ，对整个 Slate 系统理解比较重要的宏，我们会在下文进行分析</p><p>回到上面的代码分析。不难发现， <code>SLATE_BEGIN_ARGS( WidgetType )</code> 其实就是定义了一个公开的结构体 &quot;FArguments&quot; (从名字来看，这个结构体是用来储存变量的)，和 &quot;FArguments&quot; 的别名 &quot;WidgetArgsType&quot;，以及一个非内联的构造函数。而 <code>SLATE_END_ARGS()</code> 只是为了给 BEGIN 宏定义出来的结构体加上 ' } ' ，作为结构体定义的结束。</p><p>展开后的代码如下：</p><p></p><figure class="highlight c++"><figcaption><span>FArguments</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailView 内宏展开</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDetailsView</span> :</span> <span class="keyword">public</span> SCompoundWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FArguments</span> :</span> <span class="keyword">public</span> TSlateBaseNamedArgs&lt;SDetailView&gt; </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">typedef</span> FArguments WidgetArgsType; </span><br><span class="line">		<span class="function">FORCENOINLINE <span class="title">FArguments</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>如你所见，这两个宏只是在 &quot;SDetailView&quot; 中内嵌了一个 public 的结构体，这个结构体存着 &quot;SDetailView&quot; 所需的所有设置数据，包括 &quot;ToopTip&quot;，&quot;Visibility&quot; (基类 &quot;TSlateBaseNamedArgs&quot; 中的)，以及我们自己用宏传进去的变量和函数（这里没传）。</p><p>在分析函数之前，我们需要知道 &quot;SDetailsView&quot; 里面都有哪些变量要我们设置的 (基类的变量先不需要了解)</p><p></p><figure class="highlight c++"><figcaption><span>SDetailsView</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailsView.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDetailsView</span> :</span> <span class="keyword">public</span> SDetailsViewBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/** Details面板的对象过滤器 */</span></span><br><span class="line">	TSharedPtr&lt;FDetailsViewObjectFilter&gt; ObjectFilter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当前选定的Actor集的信息 */</span></span><br><span class="line">	FSelectedActorInfo SelectedActorInfo;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 调用 &quot;SetObjects&quot; 后得到的 当前选定的对象数组 */</span></span><br><span class="line">	TArray&lt;TWeakObjectPtr&lt;UObject&gt;&gt; UnfilteredSelectedObjects;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 应用对象筛选后得到的选定对象数组 */</span></span><br><span class="line">	TArray&lt;TWeakObjectPtr&lt;UObject&gt;&gt; SelectedObjects;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当前选定的 Actors 数组 */</span></span><br><span class="line">	TArray&lt; TWeakObjectPtr&lt;AActor&gt; &gt; SelectedActors;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 特定UObject的属性树的根属性节点数组 */</span></span><br><span class="line">	TArray&lt;TSharedPtr&lt;FComplexPropertyNode&gt;&gt; RootPropertyNodes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 属性视图更改时要调用的回调 */</span></span><br><span class="line">	FOnObjectArrayChanged OnObjectArrayChanged;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** 此视图中有多个顶级对象时使用的自定义实例*/</span></span><br><span class="line">	TSharedPtr&lt;IDetailRootObjectCustomization&gt; RootObjectCustomization;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 至少有一个当前查看的 Object 是 CDO 时返回真(蓝图编辑) */</span></span><br><span class="line">	<span class="keyword">bool</span> bViewingClassDefaultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>单看注释可能不太好理解，上面的属性主要是在我们选择多个对象时，细节面板要对我们选择的对象进行筛选 (哪些对象显示哪些不显示，怎么显示) 时使用的属性。</p><p>咱继续往下看，&quot;Construct&quot; 的实现如下（代码比较长）：</p><p></p><figure class="highlight c++"><figcaption><span>SDetailsView_2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailsView.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDetailsView::Construct</span><span class="params">(<span class="keyword">const</span> FArguments&amp; InArgs, <span class="keyword">const</span> FDetailsViewArgs&amp; InDetailsViewArgs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 存着 细节面板 Widget 初始化参数 的结构体，包括 HostTabManager，bShowScrollBar 等</span></span><br><span class="line">	DetailsViewArgs = InDetailsViewArgs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 ObjectFilter，用来筛选需要显示的 Object</span></span><br><span class="line">	<span class="built_in">SetObjectFilter</span>(InDetailsViewArgs.ObjectFilter);</span><br><span class="line"></span><br><span class="line">	bViewingClassDefaultObject = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存着该 &quot;SDetailsView&quot; 的引用，用于调用 &quot;SDetailsView&quot; 的一些常用函数</span></span><br><span class="line">	PropertyUtilities = <span class="built_in">MakeShareable</span>( <span class="keyword">new</span> <span class="built_in">FPropertyDetailsUtilities</span>( *<span class="keyword">this</span> ) );</span><br><span class="line">    <span class="comment">// 存着该 &quot;SDetailsView&quot; 的引用，用于调用 &quot;SDetailsView&quot; 生成属性布局的函数</span></span><br><span class="line">	PropertyGenerationUtilities = <span class="built_in">MakeShareable</span>( <span class="keyword">new</span> <span class="built_in">FDetailsViewPropertyGenerationUtilities</span>(*<span class="keyword">this</span>) );</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 右栏的实际宽度，左栏为 1 - ColumnWidth</span></span><br><span class="line">	ColumnWidth = DetailsViewArgs.ColumnWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置左栏和右栏的宽度，以及宽度改变时的回调</span></span><br><span class="line">	ColumnSizeData.LeftColumnWidth = TAttribute&lt;<span class="keyword">float</span>&gt;( <span class="keyword">this</span>, &amp;SDetailsView::OnGetLeftColumnWidth );</span><br><span class="line">	ColumnSizeData.RightColumnWidth = TAttribute&lt;<span class="keyword">float</span>&gt;( <span class="keyword">this</span>, &amp;SDetailsView::OnGetRightColumnWidth );</span><br><span class="line">	ColumnSizeData.OnWidthChanged = SSplitter::FOnSlotResized::<span class="built_in">CreateSP</span>( <span class="keyword">this</span>, &amp;SDetailsView::OnSetColumnWidth );</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里对滑动栏单独做可视性处理，是因为我们想在对象被选择时显示滑动栏，否则不显示</span></span><br><span class="line">    <span class="comment">// 我们不能使用 AlwaysShowScrollbar(总是显示) 和 可视性构造参数(在选择时隐藏)</span></span><br><span class="line">	TSharedRef&lt;SScrollBar&gt; ExternalScrollbar = <span class="built_in">SNew</span>(SScrollBar);</span><br><span class="line">	ExternalScrollbar-&gt;<span class="built_in">SetVisibility</span>( TAttribute&lt;EVisibility&gt;( <span class="keyword">this</span>, &amp;SDetailsView::GetScrollBarVisibility ) );</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 纵向菜单构造器 (细节面板选项，选择显示哪些属性)</span></span><br><span class="line">		<span class="function">FMenuBuilder <span class="title">DetailViewOptions</span><span class="params">( <span class="literal">true</span>, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 构造 &quot;DetailViewOptions&quot; 中的选项</span></span><br><span class="line">		<span class="keyword">if</span> (DetailsViewArgs.bShowModifiedPropertiesOption)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 添加一个菜单入口(复选框选项)</span></span><br><span class="line"><span class="comment">             * param @ InLabel     复选框后面显示的文本</span></span><br><span class="line"><span class="comment">             *       @ InToolTip     提示信息</span></span><br><span class="line"><span class="comment">             *       @ InIcon     应用的 FSlateBrush 信息</span></span><br><span class="line"><span class="comment">             *       @ InAction     UI行为，各种状态的回调</span></span><br><span class="line"><span class="comment">             *       @ InExtensionHook     节钩，用于拓展菜单栏</span></span><br><span class="line"><span class="comment">             *       @ UserInterfaceActionType     交互行为类型</span></span><br><span class="line"><span class="comment">             *       @ InTutorialHighlightName     突出显示名称</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			DetailViewOptions.<span class="built_in">AddMenuEntry</span>( </span><br><span class="line">				<span class="built_in">LOCTEXT</span>(<span class="string">&quot;ShowOnlyModified&quot;</span>, <span class="string">&quot;Show Only Modified Properties&quot;</span>),</span><br><span class="line">				<span class="built_in">LOCTEXT</span>(<span class="string">&quot;ShowOnlyModified_ToolTip&quot;</span>, <span class="string">&quot;Displays only properties which have been changed from their default&quot;</span>),</span><br><span class="line">				<span class="built_in">FSlateIcon</span>(),</span><br><span class="line">				<span class="built_in">FUIAction</span>( </span><br><span class="line">					FExecuteAction::<span class="built_in">CreateSP</span>( <span class="keyword">this</span>, &amp;SDetailsView::OnShowOnlyModifiedClicked ),</span><br><span class="line">					<span class="built_in">FCanExecuteAction</span>(),</span><br><span class="line">					FIsActionChecked::<span class="built_in">CreateSP</span>( <span class="keyword">this</span>, &amp;SDetailsView::IsShowOnlyModifiedChecked )</span><br><span class="line">				),</span><br><span class="line">				NAME_None,</span><br><span class="line">				EUserInterfaceActionType::ToggleButton </span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (DetailsViewArgs.bShowCustomFilterOption)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// ..... 创建菜单复选框</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( DetailsViewArgs.bShowDifferingPropertiesOption )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// ..... 创建菜单复选框</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (DetailsViewArgs.bShowKeyablePropertiesOption)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// ..... 创建菜单复选框</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (DetailsViewArgs.bShowAnimatedPropertiesOption)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// ..... 创建菜单复选框</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// ..... 创建菜单复选框</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建筛选横条，包括 SearchBox , PropertyMatrixButton 和 DetailViewOptions</span></span><br><span class="line">    <span class="comment">// 下面的语法不是通常的 C++ 语法，是虚幻重载了 &#x27;+&#x27; &#x27;.&#x27; &#x27;[]&#x27; 运算符的结果，下文详解</span></span><br><span class="line">	FilterRow = </span><br><span class="line">		<span class="built_in">SNew</span>( SHorizontalBox )	<span class="comment">// 创建一个 &quot;SHorizontalBox&quot; 并初始化 &quot;Visibility&quot; 属性</span></span><br><span class="line">		.<span class="built_in">Visibility</span>( <span class="keyword">this</span>, &amp;SDetailsView::GetFilterBoxVisibility )</span><br><span class="line">		+SHorizontalBox::<span class="built_in">Slot</span>()	<span class="comment">// 往 &quot;SHorizontalBox&quot; 里面添加一个插槽</span></span><br><span class="line">		.<span class="built_in">FillWidth</span>( <span class="number">1</span> )	<span class="comment">// 设置插槽的 &quot;FillWidth&quot; 比例为 1</span></span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">SNew</span>(SOverlay)	<span class="comment">// 往插槽里面创建一个 &quot;SOverlay&quot;</span></span><br><span class="line">			+SOverlay::<span class="built_in">Slot</span>()	<span class="comment">// 继续往 &quot;SOverlay&quot; 里面创建插槽</span></span><br><span class="line">			.<span class="built_in">Padding</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)	<span class="comment">// 设置插槽的 Padding 为 0</span></span><br><span class="line">			[</span><br><span class="line">				<span class="built_in">SNew</span>(SImage)	<span class="comment">// 往插槽中添加一个 &quot;SImage&quot;，并初始化其属性</span></span><br><span class="line">				.<span class="built_in">Image</span>(FEditorStyle::<span class="built_in">GetBrush</span>(<span class="string">&quot;Searching.SearchActiveTab&quot;</span>))</span><br><span class="line">				.<span class="built_in">Visibility_Lambda</span>([<span class="keyword">this</span>]()&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">HasActiveSearch</span>() ? EVisibility::Visible : EVisibility::Collapsed; &#125;)</span><br><span class="line">			]</span><br><span class="line">			+SOverlay::<span class="built_in">Slot</span>()	<span class="comment">// 继续往 &quot;SOverlay&quot; 里面创建插槽</span></span><br><span class="line">			.<span class="built_in">Padding</span>(<span class="number">2.f</span>, <span class="number">2.0f</span>, <span class="number">4.f</span>, <span class="number">2.f</span>)</span><br><span class="line">			.<span class="built_in">VAlign</span>( VAlign_Center )</span><br><span class="line">			[</span><br><span class="line">				<span class="comment">// 创建一个 SSearchBox，并初始化其属性</span></span><br><span class="line">				<span class="built_in">SAssignNew</span>(SearchBox, SSearchBox)</span><br><span class="line">				.<span class="built_in">HintText</span>(<span class="built_in">LOCTEXT</span>(<span class="string">&quot;SearchDetailsHint&quot;</span>, <span class="string">&quot;Search Details&quot;</span>))</span><br><span class="line">				.<span class="built_in">OnTextChanged</span>(<span class="keyword">this</span>, &amp;SDetailsView::OnFilterTextChanged)</span><br><span class="line">				.<span class="built_in">OnTextCommitted</span>(<span class="keyword">this</span>, &amp;SDetailsView::OnFilterTextCommitted)</span><br><span class="line">				.AddMetaData&lt;FTagMetaData&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Details.Search&quot;</span>))</span><br><span class="line">			]</span><br><span class="line">		];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (DetailsViewArgs.bShowPropertyMatrixButton)</span><br><span class="line">	&#123;</span><br><span class="line">		FilterRow-&gt;<span class="built_in">AddSlot</span>()	<span class="comment">// 往 筛选横条 里面添加插槽</span></span><br><span class="line">			.<span class="built_in">Padding</span>(<span class="number">4.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span><br><span class="line">			.<span class="built_in">AutoWidth</span>()</span><br><span class="line">			[</span><br><span class="line">				<span class="comment">// 创建一个 property matrix button</span></span><br><span class="line">				<span class="built_in">SNew</span>(SButton)</span><br><span class="line">				.<span class="built_in">OnClicked</span>(<span class="keyword">this</span>, &amp;SDetailsView::OnOpenRawPropertyEditorClicked)</span><br><span class="line">				.<span class="built_in">IsEnabled</span>(<span class="keyword">this</span>, &amp;SDetailsView::CanOpenRawPropertyEditor)</span><br><span class="line">				.<span class="built_in">ToolTipText</span>(<span class="built_in">LOCTEXT</span>(<span class="string">&quot;RawPropertyEditorButtonLabel&quot;</span>, <span class="string">&quot;Open Selection in Property Matrix&quot;</span>))</span><br><span class="line">				[</span><br><span class="line">					<span class="built_in">SNew</span>(SImage)</span><br><span class="line">					.<span class="built_in">Image</span>(FEditorStyle::<span class="built_in">GetBrush</span>(<span class="string">&quot;DetailsView.EditRawProperties&quot;</span>))</span><br><span class="line">				]</span><br><span class="line">			];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (DetailsViewArgs.bShowOptions)</span><br><span class="line">	&#123;</span><br><span class="line">		FilterRow-&gt;<span class="built_in">AddSlot</span>()	<span class="comment">// 往 筛选横条 里面添加插槽</span></span><br><span class="line">			.<span class="built_in">HAlign</span>(HAlign_Right)</span><br><span class="line">			.<span class="built_in">AutoWidth</span>()</span><br><span class="line">			[</span><br><span class="line">				<span class="built_in">SNew</span>( SComboButton )	<span class="comment">// 创建一个 ComboButton，并用刚刚创建的纵向菜单 &quot;DetailViewOptions&quot; 作为其菜单内容</span></span><br><span class="line">				.<span class="built_in">ContentPadding</span>(<span class="number">0</span>)</span><br><span class="line">				.<span class="built_in">ForegroundColor</span>( FSlateColor::<span class="built_in">UseForeground</span>() )</span><br><span class="line">				.<span class="built_in">ButtonStyle</span>( FEditorStyle::<span class="built_in">Get</span>(), <span class="string">&quot;ToggleButton&quot;</span> )</span><br><span class="line">				.AddMetaData&lt;FTagMetaData&gt;(<span class="built_in">FTagMetaData</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ViewOptions&quot;</span>)))</span><br><span class="line">				.<span class="built_in">MenuContent</span>()</span><br><span class="line">				[</span><br><span class="line">					DetailViewOptions.<span class="built_in">MakeWidget</span>()</span><br><span class="line">				]</span><br><span class="line">				.<span class="built_in">ButtonContent</span>()</span><br><span class="line">				[</span><br><span class="line">					<span class="built_in">SNew</span>(SImage)</span><br><span class="line">					.<span class="built_in">Image</span>( FEditorStyle::<span class="built_in">GetBrush</span>(<span class="string">&quot;GenericViewButton&quot;</span>) )</span><br><span class="line">				]</span><br><span class="line">			];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 name area，即使我们选择查看细节的对象改变了，这个 Slate 也不会改变</span></span><br><span class="line">	<span class="built_in">SAssignNew</span>(NameArea, SDetailNameArea, &amp;SelectedObjects)</span><br><span class="line">        <span class="comment">// 名称区域里面会显示我们选择的 Actor 的名称，以及当前选择了多少个对象</span></span><br><span class="line">		.<span class="built_in">Visibility</span>(<span class="keyword">this</span>, &amp;SDetailsView::GetActorNameAreaVisibility)</span><br><span class="line">		.<span class="built_in">OnLockButtonClicked</span>(<span class="keyword">this</span>, &amp;SDetailsView::OnLockButtonClicked)</span><br><span class="line">		.<span class="built_in">IsLocked</span>(<span class="keyword">this</span>, &amp;SDetailsView::IsLocked)</span><br><span class="line">		.<span class="built_in">ShowLockButton</span>(DetailsViewArgs.bLockable)</span><br><span class="line">		.<span class="built_in">ShowActorLabel</span>(DetailsViewArgs.bShowActorLabel)</span><br><span class="line">        <span class="comment">// 只在我们没有选择对象是显示提示</span></span><br><span class="line">		.<span class="built_in">SelectionTip</span>(!DetailsViewArgs.bHideSelectionTip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个纵向盒是用来把我们刚刚生成的 Slate 集成在一起添加到 ChildSlot 里面的</span></span><br><span class="line">    <span class="comment">// ChildSlot 是 &quot;CompoundWidget&quot; 的属性，往里面添加 Slate 对象，并显示给用户</span></span><br><span class="line">	TSharedRef&lt;SVerticalBox&gt; VerticalBox = <span class="built_in">SNew</span>(SVerticalBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前的细节面板不是 自定义名称区域，则添加我们刚刚创建的名称区域</span></span><br><span class="line">	<span class="keyword">if</span>( !DetailsViewArgs.bCustomNameAreaLocation )</span><br><span class="line">	&#123;</span><br><span class="line">		VerticalBox-&gt;<span class="built_in">AddSlot</span>()</span><br><span class="line">		.<span class="built_in">AutoHeight</span>()</span><br><span class="line">		.<span class="built_in">Padding</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>)</span><br><span class="line">		[</span><br><span class="line">			NameArea.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">		];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果当前的细节面板不是 自定义筛选区域，则添加我们刚刚创建的筛选区域</span></span><br><span class="line">	<span class="keyword">if</span>( !DetailsViewArgs.bCustomFilterAreaLocation )</span><br><span class="line">	&#123;</span><br><span class="line">		VerticalBox-&gt;<span class="built_in">AddSlot</span>()</span><br><span class="line">		.<span class="built_in">AutoHeight</span>()</span><br><span class="line">		[</span><br><span class="line">			FilterRow.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">		];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造细节树并添加到纵向盒里，细节树的构造我们会在下文分析</span></span><br><span class="line">	VerticalBox-&gt;<span class="built_in">AddSlot</span>()</span><br><span class="line">	.<span class="built_in">FillHeight</span>(<span class="number">1</span>)</span><br><span class="line">	.<span class="built_in">Padding</span>(<span class="number">0</span>)</span><br><span class="line">	[</span><br><span class="line">		<span class="built_in">SNew</span>(SOverlay)	<span class="comment">// 添加一个 &quot;SOverlay&quot;</span></span><br><span class="line">		+ SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">		[</span><br><span class="line">            <span class="comment">// 往 &quot;SOverlay&quot; 里面构造细节树 (就是选定对象的一条条可以改变的属性)</span></span><br><span class="line">            <span class="comment">// 该函数我们会在下文进行分析，比较重要</span></span><br><span class="line">			<span class="built_in">ConstructTreeView</span>(ExternalScrollbar)</span><br><span class="line">		]</span><br><span class="line">		+ SOverlay::<span class="built_in">Slot</span>()	<span class="comment">// 往 &quot;SOverlay&quot; 里面添加一个滑动条</span></span><br><span class="line">		.<span class="built_in">HAlign</span>(HAlign_Right)</span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">SNew</span>(SBox)</span><br><span class="line">			.<span class="built_in">WidthOverride</span>(<span class="number">16.0f</span>)</span><br><span class="line">			[</span><br><span class="line">				ExternalScrollbar</span><br><span class="line">			]</span><br><span class="line">		]</span><br><span class="line">		+ SOverlay::<span class="built_in">Slot</span>()	<span class="comment">// 往 &quot;SOverlay&quot; 里面添加一个文本框，提示用户当前筛选条件下没有符合的属性</span></span><br><span class="line">		.<span class="built_in">HAlign</span>(HAlign_Center)</span><br><span class="line">		.<span class="built_in">Padding</span>(<span class="number">2.0f</span>, <span class="number">24.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>)</span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">SNew</span>(STextBlock)</span><br><span class="line">			.<span class="built_in">Text</span>(<span class="built_in">LOCTEXT</span>(<span class="string">&quot;AllItemsFiltered&quot;</span>, <span class="string">&quot;All results have been filtered. Try changing your active filters above.&quot;</span>))</span><br><span class="line">			.<span class="built_in">Visibility_Lambda</span>([<span class="keyword">this</span>]() &#123; <span class="built_in"><span class="keyword">return</span></span> ((<span class="keyword">this</span>-&gt;<span class="built_in">GetFilterBoxVisibility</span>() == EVisibility::Visible) &amp;&amp; !<span class="keyword">this</span>-&gt;CurrentFilter.<span class="built_in">IsEmptyFilter</span>() &amp;&amp; RootTreeNodes.<span class="built_in">Num</span>() == <span class="number">0</span>) ? EVisibility::HitTestInvisible : EVisibility::Collapsed; &#125;)</span><br><span class="line">		]</span><br><span class="line">		+ SOverlay::<span class="built_in">Slot</span>()	<span class="comment">// 往 &quot;SOverlay&quot; 中添加一个图标，在搜索时显示</span></span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">SNew</span>(SImage)</span><br><span class="line">			.<span class="built_in">Image</span>(FEditorStyle::<span class="built_in">GetBrush</span>(<span class="string">&quot;Searching.SearchActiveBorder&quot;</span>))</span><br><span class="line">			.<span class="built_in">Visibility_Lambda</span>([<span class="keyword">this</span>]() &#123; <span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">this</span>-&gt;<span class="built_in">GetFilterBoxVisibility</span>() == EVisibility::Visible) &amp;&amp; <span class="keyword">this</span>-&gt;<span class="built_in">HasActiveSearch</span>() ? EVisibility::HitTestInvisible : EVisibility::Collapsed; &#125;)</span><br><span class="line">		]</span><br><span class="line">	];</span><br><span class="line"></span><br><span class="line">	ChildSlot</span><br><span class="line">	[</span><br><span class="line">		VerticalBox		<span class="comment">// 将刚刚集成好的纵向盒添加到子槽里面</span></span><br><span class="line">	];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;Construct&quot; 函数主要是用来初始化一些属性，以及构建 &quot;ChildSlot&quot; 的。前面什么构建纵向菜单，属性筛选行，其实都是在为构建 &quot;ChildSlot&quot; 做准备而已。小伙伴们应该也注意到了，构建 Slate 的语法跟 C++ 的语法差别还是非常大的。其实是为了开发方便，代码直观，虚幻为我们重载的几个运算符。分别是：&quot;[ ]&quot; &quot;.&quot; &quot;+&quot;，以及 &quot;SNew&quot; 宏。再分析细节树的构造之前，我想先把这几个运算符的重载给讲明白。想直接看细节树构建的同学点<a href="#%E7%BB%86%E8%8A%82%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA">这里</a>跳转</p><h3 id="运算符重载"><a class="anchor" href="#运算符重载">#</a> 运算符重载</h3><h4 id="snew"><a class="anchor" href="#snew">#</a> SNew</h4><p></p><figure class="highlight c++"><figcaption><span>SNew</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;SNew&quot; 的调用链</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNew( WidgetType, ... ) \</span></span><br><span class="line"><span class="meta">	MakeTDecl<span class="meta-string">&lt;WidgetType&gt;</span>( #WidgetType, __FILE__, __LINE__, RequiredArgs::MakeRequiredArgs(__VA_ARGS__) ) &lt;&lt;= TYPENAME_OUTSIDE_TEMPLATE WidgetType::FArguments()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPENAME_OUTSIDE_TEMPLATE typename</span></span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE T0RequiredArgs <span class="title">MakeRequiredArgs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">T0RequiredArgs</span>();	<span class="comment">// 用来转发参数的 payload 结构体，定义在下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeRequiredArgs(__VA_ARGS__) 会根据不同的参数个数，构建不同的 payload 结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> WidgetType, <span class="keyword">typename</span> RequiredArgsPayloadType&gt;</span></span><br><span class="line"><span class="function">TDecl&lt;WidgetType, RequiredArgsPayloadType&gt; <span class="title">MakeTDecl</span><span class="params">( <span class="keyword">const</span> ANSICHAR* InType, <span class="keyword">const</span> ANSICHAR* InFile, int32 OnLine, RequiredArgsPayloadType&amp;&amp; InRequiredArgs )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> TDecl&lt;WidgetType, RequiredArgsPayloadType&gt;(InType, InFile, OnLine, Forward&lt;RequiredArgsPayloadType&gt;(InRequiredArgs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">WidgetType</span>, <span class="title">typename</span> <span class="title">RequiredArgsPayloadType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TDecl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">TDecl</span>( <span class="keyword">const</span> ANSICHAR* InType, <span class="keyword">const</span> ANSICHAR* InFile, int32 OnLine, RequiredArgsPayloadType&amp;&amp; InRequiredArgs )</span><br><span class="line">		: _Widget( TWidgetAllocator&lt;WidgetType, TIsDerivedFrom&lt;WidgetType, SUserWidget&gt;::IsDerived &gt;::<span class="built_in">PrivateAllocateWidget</span>() )</span><br><span class="line">		, _RequiredArgs(InRequiredArgs)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 设置 Debug 信息，不展开</span></span><br><span class="line">		_Widget-&gt;<span class="built_in">SetDebugInfo</span>( InType, InFile, OnLine, <span class="built_in"><span class="keyword">sizeof</span></span>(WidgetType) );</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    TSharedRef&lt;WidgetType&gt; <span class="keyword">operator</span>&lt;&lt;=( <span class="keyword">const</span> <span class="keyword">typename</span> WidgetType::FArguments&amp; InArgs ) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		_Widget-&gt;<span class="built_in">SWidgetConstruct</span>(</span><br><span class="line">			InArgs._ToolTipText,</span><br><span class="line">			InArgs._ToolTip,</span><br><span class="line">			InArgs._Cursor,</span><br><span class="line">			InArgs._IsEnabled,</span><br><span class="line">			InArgs._Visibility,</span><br><span class="line">			InArgs._RenderOpacity,</span><br><span class="line">			InArgs._RenderTransform,</span><br><span class="line">			InArgs._RenderTransformPivot,</span><br><span class="line">			InArgs._Tag,</span><br><span class="line">			InArgs._ForceVolatile,</span><br><span class="line">			InArgs._Clipping,</span><br><span class="line">			InArgs._FlowDirectionPreference,</span><br><span class="line">			InArgs._AccessibleText.<span class="built_in">IsSet</span>() ? <span class="built_in">FAccessibleWidgetData</span>(InArgs._AccessibleText) : InArgs._AccessibleParams,</span><br><span class="line">			InArgs.MetaData );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Widget 的 &quot;Construct&quot; 函数</span></span><br><span class="line">		_RequiredArgs.<span class="built_in">CallConstruct</span>(_Widget, InArgs);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> _Widget;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> TSharedRef&lt;WidgetType&gt; _Widget;</span><br><span class="line">	RequiredArgsPayloadType&amp; _RequiredArgs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T0RequiredArgs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">T0RequiredArgs</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class WidgetType&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">CallConstruct</span><span class="params">(<span class="keyword">const</span> TSharedRef&lt;WidgetType&gt;&amp; OnWidget, <span class="keyword">const</span> <span class="keyword">typename</span> WidgetType::FArguments&amp; WithNamedArgs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 你的 Widget 必须要实现 void Construct(const FArguments&amp; InArgs)</span></span><br><span class="line">        OnWidget-&gt;<span class="built_in">Construct</span>(WithNamedArgs);</span><br><span class="line">        OnWidget-&gt;<span class="built_in">CacheVolatility</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>可以看出，调用 &quot;SNew (WidgetType)&quot; 后，程序会给我们返回一个构造好的 TSharedRef&lt;WidgetType&gt;。具体过程是：</p><ul><li>先调用 WidgetType::FArguments ()，构造一个默认的 &quot;FArguments&quot; 结构体（<strong>后面讲 '[]' 和 '+' 的重载是还要用到</strong>）</li><li>然后调用 &quot;MakeTDecl&quot; 构造并返回一个 &quot;TDecl&quot; 结构体，这时候也会构建对应参数的 payload 结构体，并存在 &quot;TDecl&quot; 中</li><li>最后调用 &quot;TDecl&quot; 结构体的 &quot;&lt;&lt;=&quot; 重载运算符，初始化 &quot;TDecl&quot; 里面的 &quot;_Widget&quot; 的属性，并调用其 &quot;Construct&quot; 函数。</li></ul><p>需要注意的是，<strong>&quot;SNew&quot; 最终调用 &quot;&lt;&lt;=&quot; 运算符的返回值是 &quot;TSharedRef&lt;WidgetType&gt;&quot;</strong>。这点很重要，我们后面还会回来看这个宏。</p><h4 id="operator"><a class="anchor" href="#operator">#</a> operator +</h4><p>用蓝图拼过高达的同学应该知道：不是所有 &quot;Widget&quot; 都是可以有 &quot;Child Widget&quot; 的。在 Slate 里面，&quot;Slot&quot; 其实就是 &quot;Child Widget&quot;，而添加 &quot;Slot&quot; 的方法，也就是 '+' 运算符。那么 让我们来看看这个 '+' 运算符是怎么重载的吧～～</p><p></p><figure class="highlight c++"><figcaption><span>operator+</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeclarativeSyntaxSupport.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use this macro between SLATE_BEGIN_ARGS and SLATE_END_ARGS</span></span><br><span class="line"><span class="comment"> * in order to add support for slots.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLATE_SUPPORTS_SLOT( SlotType ) \</span></span><br><span class="line"><span class="meta">		TArray<span class="meta-string">&lt; SlotType* &gt;</span> Slots; \</span></span><br><span class="line"><span class="meta">		WidgetArgsType&amp; operator + (SlotType&amp; SlotToAdd) \</span></span><br><span class="line"><span class="meta">		&#123; \</span></span><br><span class="line"><span class="meta">			Slots.Add( &amp;SlotToAdd ); \</span></span><br><span class="line"><span class="meta">			return *this; \</span></span><br><span class="line"><span class="meta">		&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>是的，实现代码并不难。就是先声明一个存 &quot;Slot&quot; 对象的一个数组，然后调用 '+' 运算符往数组里面添加一个 &quot;Slot&quot; (这里添加的 &quot;Slot&quot; 其实是已经初始化好的了)，最后返回咱的 &quot;FArguments&quot; 结构体。</p><p>需要注意的是宏定义上面的注释： <code>SLATE_SUPPORTS_SLOT</code> 宏必须定义在 <code>SLATE_BEGIN_ARGS</code> 和 <code>SLATE_END_ARGS</code> 之间。通过上文的宏分析我们知道： <code>SLATE_BEGIN_ARGS</code> 和 <code>SLATE_END_ARGS</code> 之间定义的属性或者函数，都是属于 &quot;FArguments&quot; 的。也就是说，咱宏定义里面的 &quot;Slots&quot; 数组 和 '+' 运算符其实是 &quot;FArguments&quot; 的属性和方法。</p><p>那么问题来了。下面代码是怎么编译通过的？</p><p></p><figure class="highlight c++"><figcaption><span>Q1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节选 SDetailsView.Construct 中的代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SNew</span>(SOverlay)</span><br><span class="line">    + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">    [</span><br><span class="line">    	<span class="built_in">ConstructTreeView</span>(ExternalScrollbar)</span><br><span class="line">	]</span><br></pre></td></tr></table></figure><p></p><p>'[]' 是用来初始化 <code>SOverlay::Slot()</code> 构造出来的 &quot;Slot&quot; 的，我们后面会讲。</p><p>重点是：<strong>为什么 &quot;SNew&quot; 返回的 &quot;SharedRef&lt;WidgetType&gt;&quot; 指针可以直接调用 WidgetType::FArgument 里面的 '+' 运算符</strong>？</p><p>给可爱的读者三秒思考，1，2，3。时间到，公布答案。</p><p>&quot;SNew&quot; 返回的确实是 &quot;SharedRef&lt;WidgetType&gt;&quot; 没错。宏定义是这样的：</p><p></p><figure class="highlight c++"><figcaption><span>SNew_Review</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNew( WidgetType, ... ) \</span></span><br><span class="line"><span class="meta">	MakeTDecl( #WidgetType, __FILE__, __LINE__, RequiredArgs::MakeRequiredArgs(__VA_ARGS__) ) &lt;&lt;= TYPENAME_OUTSIDE_TEMPLATE WidgetType::FArguments()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化一下就是 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNew( WidgetType, ... ) \</span></span><br><span class="line"><span class="meta">	TDecl<span class="meta-string">&lt;WidgetType&gt;</span>() &lt;&lt;= typename WidgetType::FArguments()</span></span><br></pre></td></tr></table></figure><p></p><p>根据函数运算规律 (从右到左处理参数)， <code>WidgetType::FArguments()</code> 作为 '&lt;&lt;=' 运算符的参数，我们会先运行后面的 <code>typename SOverlay::FArguments() + SOverlay::Slot</code> ，这样一来便是我们的 &quot;FArguments&quot; 在调用 '+' 运算符，为不是等整个 <code>SNew(SOverlay)</code> 全部执行完后，再来执行 '+' 运算符。最后 &quot;&lt;&lt;=&quot; 运算符的 &quot;FArgument&quot; 参数也将不再是默认值，而是添加了 &quot;Slot&quot; 的 &quot;FArgument&quot;。</p><p>得出结论：<strong>&quot;SNew ()&quot; 宏的前面 (返回值) 连接 &quot;SharedRed&quot;，后面连接 &quot;FArgument&quot;，可以用来初始化 &quot;FArgument&quot; 的一些特定属性，如：Slot，Visibility 等</strong></p><p>到此，我们便知道了 <code>SNew(WidgetType) + WidgetType::Slot()</code> 的运行原理。接下来看看最后的 '[]' 运算符吧</p><h4 id="operator-2"><a class="anchor" href="#operator-2">#</a> operator []</h4><p>跟 '+' 先于 '&lt;&lt;=' 执行一样，我们的 '[]' 也是先于 '+' 执行的。所以 '[]' 实际上是 <code>WidgetType::Slot()</code> 对象的重载函数。我们先看看， <code>WidgetType::Slot()</code> 是怎么实现的</p><h5 id="soverlayslot"><a class="anchor" href="#soverlayslot">#</a> SOverlay::Slot()</h5><p></p><figure class="highlight c++"><figcaption><span>SOverlay::Slot</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SOverlay.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FOverlaySlot&amp; <span class="title">Slot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">new</span> <span class="built_in">FOverlaySlot</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SLATECORE_API</span> <span class="title">FOverlaySlot</span> :</span> <span class="keyword">public</span> TSlotBase&lt;FOverlaySlot&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FOverlaySlot</span>()</span><br><span class="line">        : TSlotBase&lt;FOverlaySlot&gt;()</span><br><span class="line">            , <span class="built_in">ZOrder</span>(<span class="number">0</span>)</span><br><span class="line">            , <span class="built_in">HAlignment</span>(HAlign_Fill)</span><br><span class="line">            , <span class="built_in">VAlignment</span>(VAlign_Fill)</span><br><span class="line">            , <span class="built_in">SlotPadding</span>(<span class="number">0.0f</span>)</span><br><span class="line">        &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FOverlaySlot&amp; <span class="title">HAlign</span><span class="params">( EHorizontalAlignment InHAlignment )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HAlignment = InHAlignment;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 与 HAlign 函数类似，省略 VAlign，Padding 的设置函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具有较大ZOrder值的插槽将在具有较小ZOrder值的插槽上方绘制。</span></span><br><span class="line"><span class="comment">     * 具有相同ZOrder的插槽将按照添加顺序简单地绘制。</span></span><br><span class="line"><span class="comment">     * 目前，这仅适用于通过AddWidget（）和RemoveWidget（）动态添加的覆盖插槽</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    int32 ZOrder;</span><br><span class="line"></span><br><span class="line">    TEnumAsByte&lt;EHorizontalAlignment&gt; HAlignment;</span><br><span class="line">    TEnumAsByte&lt;EVerticalAlignment&gt; VAlignment;</span><br><span class="line"></span><br><span class="line">    TAttribute&lt; FMargin &gt; SlotPadding;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>我们的 '[]' 运算符肯定是不能放到具体类 'FOverlaySlot'，因为所有的 &quot;SlotType&quot; 都需要该方法。我们要实现复用，就要将 '[]' 的实现放在其基类 &quot;TSlotBase&quot; 中，并以 &quot;FOverlaySlot&quot; 作为模板参数。以下是 '[]' 的实现代码：</p><p></p><figure class="highlight c++"><figcaption><span>TSlotBase</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SlotBase.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> SlotType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TSlotBase</span> :</span> <span class="keyword">public</span> FSlotBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TSlotBase</span>()</span><br><span class="line">	: <span class="built_in">FSlotBase</span>()</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TSlotBase</span>( <span class="keyword">const</span> TSharedRef&lt;SWidget&gt;&amp; InWidget )</span><br><span class="line">	: <span class="built_in">FSlotBase</span>( InWidget )</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	SlotType&amp; <span class="keyword">operator</span>[]( <span class="keyword">const</span> TSharedRef&lt;SWidget&gt;&amp; InChildWidget )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 将 FSlotBase 中的 Widget 替换为 InChildWidget</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">AttachWidget</span>(InChildWidget);</span><br><span class="line">		<span class="keyword">return</span> (SlotType&amp;)(*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">SlotType&amp; <span class="title">Expose</span><span class="params">( SlotType*&amp; OutVarToInit )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		OutVarToInit = (SlotType*)<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> (SlotType&amp;)(*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>可以看出，我们 '[]' 运算符里面是需要传入一个 &quot;TSharedRef&lt;SWidget&gt;&quot; 的，而我们的 &quot;SNew ()&quot; 宏的返回值正是该类型，以下是源码中的提示 Usage：</p><p></p><figure class="highlight c++"><figcaption><span>SOverlay.Usage</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *		SNew(SOverlay)</span></span><br><span class="line"><span class="comment"> *		+ SOverlay::Slot(SNew(SMyWidget1))</span></span><br><span class="line"><span class="comment"> *		+ SOverlay::Slot(SNew(SMyWidget2))</span></span><br><span class="line"><span class="comment"> *		+ SOverlay::Slot(SNew(SMyWidget3))</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p></p><h4 id="运算符小结"><a class="anchor" href="#运算符小结">#</a> 运算符小结</h4><p>到此我们就把三个运算符的重载都分析完了。我们在回顾以下这段代码：</p><p></p><figure class="highlight c++"><figcaption><span>SDetailsView.Construct 节选</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailsView.Construct 节选代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SNew</span>(SOverlay)</span><br><span class="line">    + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">    [</span><br><span class="line">    	<span class="comment">// 添加一个细节树，返回 TSharedRef&lt; SDetailTree &gt;</span></span><br><span class="line">    	<span class="built_in">ConstructTreeView</span>(ExternalScrollbar)</span><br><span class="line">	]</span><br><span class="line">    + SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">    .<span class="built_in">HAlign</span>(HAlign_Right)</span><br><span class="line">    [</span><br><span class="line">    	<span class="comment">// 添加一个 SBox，设置该 SBox 的 WidthOverride 属性</span></span><br><span class="line">    	<span class="built_in">SNew</span>(SBox)</span><br><span class="line">    	.<span class="built_in">WidthOverride</span>(<span class="number">16.0f</span>)</span><br><span class="line">    	[</span><br><span class="line">            <span class="comment">// SBox 是 SingleChild 的，可以直接调用 &quot;[]&quot; ，不需要 &quot;+ Slot()&quot;</span></span><br><span class="line">        	ExternalScrollbar</span><br><span class="line">    	]</span><br><span class="line">    <span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p></p><p>执行顺序如下：</p><ul><li>先执行 <code>SOverlay::Slot()</code> ，返回一个 &quot;FOverlaySlot&quot;</li><li>调用 &quot;FOverlaySlot&quot; 的 '[]' 运算符，并执行 &quot;ConstructTreeView&quot; 函数，往 '[]' 里添加一个 &quot;Slot&quot;</li><li>然后调用 &quot;SNew&quot; 里面的 &quot;SOverlay::FArgument&quot; 的 '+' 运算符，将刚刚的 &quot;FOverlaySlot&quot; 添加进 &quot;SOverlay::FArgument&quot; 中</li><li>继续执行下面的 + SOverlay::Slot () ......</li><li>最后执行 &quot;SNew&quot; 里面的 &quot;&lt;&lt;=&quot; 运算符，将 &quot;SOverlay::FArgument&quot; 作为参数，构造咱的 &quot;SOverlay&quot;。注意我们之前做的都是在初始化 &quot;SOverlay&quot; 构造所需要的 &quot;SOverlay::FArgument&quot;，最后一步才是构造 &quot;SOverlay&quot;，并返回该 &quot;SOverlay&quot; 的 SharedRef。</li></ul><h3 id="细节树的构建a-id-细节树的构建-a"><a class="anchor" href="#细节树的构建a-id-细节树的构建-a">#</a> 细节树的构建 &lt;a id = &quot;细节树的构建&quot;&gt; &lt;/a&gt;</h3><h4 id="constructtreeview"><a class="anchor" href="#constructtreeview">#</a> ConstructTreeView</h4><p></p><figure class="highlight c++"><figcaption><span>ConstructTreeView</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailsView.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">TSharedRef&lt;SDetailTree&gt; <span class="title">SDetailsView::ConstructTreeView</span><span class="params">( TSharedRef&lt;SScrollBar&gt;&amp; ScrollBar )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>( !DetailTree.<span class="built_in">IsValid</span>() || DetailTree.<span class="built_in">IsUnique</span>() );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">		<span class="built_in">SAssignNew</span>(DetailTree, SDetailTree)</span><br><span class="line">		.<span class="built_in">Visibility</span>(<span class="keyword">this</span>, &amp;SDetailsView::GetTreeVisibility)</span><br><span class="line">		.<span class="built_in">TreeItemsSource</span>(&amp;RootTreeNodes)</span><br><span class="line">		.<span class="built_in">OnGetChildren</span>(<span class="keyword">this</span>, &amp;SDetailsView::OnGetChildrenForDetailTree)</span><br><span class="line">		.<span class="built_in">OnSetExpansionRecursive</span>(<span class="keyword">this</span>, &amp;SDetailsView::SetNodeExpansionStateRecursive)</span><br><span class="line">		.<span class="built_in">OnGenerateRow</span>(<span class="keyword">this</span>, &amp;SDetailsView::OnGenerateRowForDetailTree)</span><br><span class="line">		.<span class="built_in">OnExpansionChanged</span>(<span class="keyword">this</span>, &amp;SDetailsView::OnItemExpansionChanged)</span><br><span class="line">		.<span class="built_in">SelectionMode</span>(ESelectionMode::None)</span><br><span class="line">		.<span class="built_in">HandleDirectionalNavigation</span>(<span class="literal">false</span>)</span><br><span class="line">		.<span class="built_in">AllowOverscroll</span>(DetailsViewArgs.bShowScrollBar ? EAllowOverscroll::Yes : EAllowOverscroll::No)</span><br><span class="line">		.<span class="built_in">ExternalScrollbar</span>(ScrollBar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;SAssignNew&quot; 跟 &quot;SNew&quot; 的实现原理一样，只是 &quot;SAssignNew&quot; 一般用于初始化 &quot;TSharedPtr&lt;SWidget&gt;&quot; , 使用方法如下：</p><p></p><figure class="highlight c++"><figcaption><span>SAssignNew</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Slate widgets are constructed through SNew and SAssignNew.</span></span><br><span class="line"><span class="comment"> * e.g.</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *     TSharedRef&lt;SButton&gt; MyButton = SNew(SButton);</span></span><br><span class="line"><span class="comment"> *        or</span></span><br><span class="line"><span class="comment"> *     TSharedPtr&lt;SButton&gt; MyButton;</span></span><br><span class="line"><span class="comment"> *     SAssignNew( MyButton, SButton );</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Using SNew and SAssignNew ensures that widgets are populated</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p></p><p>回到 <code>ConstructTreeView</code> 的实现上，可以看出是在初始化 &quot;SDetailTree::FArgument&quot; 的参数，最后通过 &quot;SAssignNew&quot; 的 '&lt;&lt;=' 运算符，调用了 &quot;SDetailTree::Construct&quot; 构造了一个 &quot;SDetailTree&quot;。那我们当然是直接去看 &quot;SDetailTree::Construct&quot; 的实现啦 (其他参数也会在 Construct 中用到，用到再回来看怎么初始化的)</p><h4 id="sdetailtreeconstruct"><a class="anchor" href="#sdetailtreeconstruct">#</a> SDetailTree::Construct</h4><p></p><figure class="highlight c++"><figcaption><span>SDetailTree::Construct</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailsViewBase.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> STreeView&lt; TSharedRef&lt;<span class="class"><span class="keyword">class</span> <span class="title">FDetailTreeNode</span>&gt;</span> &gt; SDetailTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ItemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">STreeView</span> :</span> <span class="keyword">public</span> SListView&lt; ItemType &gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Construct</span><span class="params">( <span class="keyword">const</span> FArguments&amp; InArgs )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;Clipping = InArgs._Clipping;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;OnGenerateRow = InArgs._OnGenerateRow;</span><br><span class="line">		<span class="keyword">this</span>-&gt;OnRowReleased = InArgs._OnRowReleased;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;OnContextMenuOpening = InArgs._OnContextMenuOpening;</span><br><span class="line">		<span class="keyword">this</span>-&gt;OnClick = InArgs._OnMouseButtonClick;</span><br><span class="line">		<span class="keyword">this</span>-&gt;OnDoubleClick = InArgs._OnMouseButtonDoubleClick;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 省略各种属性初始化</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 省略错误输出</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造表视图(List)</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">ConstructChildren</span>( <span class="number">0</span>, InArgs._ItemHeight, EListItemAlignment::LeftAligned, InArgs._HeaderRow, InArgs._ExternalScrollbar, Orient_Vertical, InArgs._OnTreeViewScrolled );</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ScrollBar.<span class="built_in">IsValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置滚动条 DargFocysCause 事件</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;ScrollBar-&gt;<span class="built_in">SetDragFocusCause</span>(InArgs._ScrollbarDragFocusCause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加元数据，不展开</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">AddMetadata</span>(MakeShared&lt;TTableViewMetadata&lt;ItemType&gt;&gt;(<span class="keyword">this</span>-&gt;<span class="built_in">SharedThis</span>(<span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建细节树容器(不生成细节属性项[Item])</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STableViewBase::ConstructChildren</span><span class="params">( <span class="keyword">const</span> TAttribute&lt;<span class="keyword">float</span>&gt;&amp; InItemWidth, <span class="keyword">const</span> TAttribute&lt;<span class="keyword">float</span>&gt;&amp; InItemHeight, <span class="keyword">const</span> TAttribute&lt;EListItemAlignment&gt;&amp; InItemAlignment, <span class="keyword">const</span> TSharedPtr&lt;SHeaderRow&gt;&amp; InHeaderRow, <span class="keyword">const</span> TSharedPtr&lt;SScrollBar&gt;&amp; InScrollBar, EOrientation InScrollOrientation, <span class="keyword">const</span> FOnTableViewScrolled&amp; InOnTableViewScrolled )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 下次 Tick 刷新细节树的每一个项</span></span><br><span class="line">	bItemsNeedRefresh = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	HeaderRow = InHeaderRow;</span><br><span class="line"></span><br><span class="line">	OnTableViewScrolled = InOnTableViewScrolled;</span><br><span class="line"></span><br><span class="line">	Orientation = InHeaderRow ? Orient_Vertical : InScrollOrientation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SNew 一个空的列表面板 (用来放属性项)</span></span><br><span class="line">	ItemsPanel = <span class="built_in">SNew</span>(SListPanel)</span><br><span class="line">		.<span class="built_in">Clipping</span>(<span class="built_in">GetClipping</span>())</span><br><span class="line">		.<span class="built_in">ItemWidth</span>(InItemWidth)</span><br><span class="line">		.<span class="built_in">ItemHeight</span>(InItemHeight)</span><br><span class="line">		.<span class="built_in">NumDesiredItems</span>(<span class="keyword">this</span>, &amp;STableViewBase::GetNumItemsBeingObserved)</span><br><span class="line">		.<span class="built_in">ItemAlignment</span>(InItemAlignment)</span><br><span class="line">		.<span class="built_in">ListOrientation</span>(Orientation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放 &quot;ItemsPanel&quot; 和 &quot;Scrollbar&quot; 的 SWidget (以下简称容器)</span></span><br><span class="line">	TSharedPtr&lt;SWidget&gt; ListAndScrollbar;</span><br><span class="line">	<span class="keyword">if</span> (InScrollBar)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 将 ScrollBar 设置为用户传进来的滚动条，并设置滚动回调</span></span><br><span class="line">		ScrollBar = InScrollBar;</span><br><span class="line">		ScrollBar-&gt;<span class="built_in">SetOnUserScrolled</span>(FOnUserScrolled::<span class="built_in">CreateSP</span>(<span class="keyword">this</span>, &amp;STableViewBase::ScrollBar_OnUserScrolled));</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 将空的 ListPanel 赋给容器</span></span><br><span class="line">		ListAndScrollbar = ItemsPanel;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 构造默认滚动条</span></span><br><span class="line">		ScrollBar = <span class="built_in">SNew</span>(SScrollBar)</span><br><span class="line">			.<span class="built_in">OnUserScrolled</span>(<span class="keyword">this</span>, &amp;STableViewBase::ScrollBar_OnUserScrolled)</span><br><span class="line">			.<span class="built_in">Orientation</span>(Orientation);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">const</span> FOptionalSize <span class="title">ScrollBarSize</span><span class="params">(<span class="number">16.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 纵向容器</span></span><br><span class="line">		<span class="keyword">if</span> (Orientation == Orient_Vertical)</span><br><span class="line">		&#123;</span><br><span class="line">			ListAndScrollbar = <span class="built_in">SNew</span>(SHorizontalBox)</span><br><span class="line">				+SHorizontalBox::<span class="built_in">Slot</span>()</span><br><span class="line">				.<span class="built_in">FillWidth</span>(<span class="number">1</span>)</span><br><span class="line">				[</span><br><span class="line">                	<span class="comment">// 将 List 添加到容器中</span></span><br><span class="line">					ItemsPanel.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">				]</span><br><span class="line">				+SHorizontalBox::<span class="built_in">Slot</span>()</span><br><span class="line">				.<span class="built_in">AutoWidth</span>()</span><br><span class="line">				[</span><br><span class="line">					<span class="built_in">SNew</span>(SBox)</span><br><span class="line">					.<span class="built_in">WidthOverride</span>( <span class="built_in">FOptionalSize</span>( <span class="number">16</span> ) )</span><br><span class="line">					[</span><br><span class="line">                        <span class="comment">// 用 SBox 把 ScrollBar 包起来添加到容器中</span></span><br><span class="line">						ScrollBar.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">					]</span><br><span class="line">				];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 横向容器</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ListAndScrollbar = <span class="built_in">SNew</span>(SVerticalBox)</span><br><span class="line">				+SVerticalBox::<span class="built_in">Slot</span>()</span><br><span class="line">				.<span class="built_in">FillHeight</span>(<span class="number">1</span>)</span><br><span class="line">				[</span><br><span class="line">					ItemsPanel.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">				]</span><br><span class="line">				+SVerticalBox::<span class="built_in">Slot</span>()</span><br><span class="line">				.<span class="built_in">AutoHeight</span>()</span><br><span class="line">				[</span><br><span class="line">					<span class="built_in">SNew</span>(SBox)</span><br><span class="line">					.<span class="built_in">HeightOverride</span>(ScrollBarSize)</span><br><span class="line">					[</span><br><span class="line">						ScrollBar.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">					]</span><br><span class="line">				];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (InHeaderRow)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 外部传入的滚动条不会出现在标题行下，不需要补偿</span></span><br><span class="line">        <span class="keyword">if</span> (!InScrollBar)</span><br><span class="line">		&#123;</span><br><span class="line">			InHeaderRow-&gt;<span class="built_in">SetAssociatedVerticalScrollBar</span>(ScrollBar.<span class="built_in">ToSharedRef</span>(), <span class="number">16.f</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;ChildSlot</span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">SNew</span>(SVerticalBox)</span><br><span class="line">			+SVerticalBox::<span class="built_in">Slot</span>()</span><br><span class="line">			.<span class="built_in">AutoHeight</span>()</span><br><span class="line">			[</span><br><span class="line">                <span class="comment">// 将标题行添加到 ChildSlot 中</span></span><br><span class="line">				InHeaderRow.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">			]</span><br><span class="line">			+SVerticalBox::<span class="built_in">Slot</span>()</span><br><span class="line">			.<span class="built_in">FillHeight</span>(<span class="number">1</span>)</span><br><span class="line">			[</span><br><span class="line">                <span class="comment">// 将容器添加到 ChildSlot 中</span></span><br><span class="line">				ListAndScrollbar.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">			]</span><br><span class="line">		];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ChildSlot</span><br><span class="line">		[</span><br><span class="line">            <span class="comment">// 没有标题行则直接把容器加到 Child 中</span></span><br><span class="line">			ListAndScrollbar.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">		];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>细节树的构建主要是创建一个可以放置细节节点的容器和滚动条，以及各种回调事件的初始化。并不负责生成每个具体属性项 (Item) 。生成 (刷新) 属性项是在 Tick 中完成的，下面我们就去看看 Tick 是怎么生成项的。</p><h3 id="tick-刷新节点"><a class="anchor" href="#tick-刷新节点">#</a> Tick 刷新节点</h3><p></p><figure class="highlight c++"><figcaption><span>STreeView.Tick</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Tick</span><span class="params">( <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, <span class="keyword">const</span> <span class="keyword">double</span> InCurrentTime, <span class="keyword">const</span> <span class="keyword">float</span> InDeltaTime )</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 决定是否需要刷新属性项(Item)，默认构造函数中会把其设置为 true</span></span><br><span class="line">    <span class="keyword">if</span> ( bTreeItemsAreDirty )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &quot;ItemPanel&quot; 是否正常初始化</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;ItemsPanel.<span class="built_in">IsValid</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 重新填充属性项；构建 TreeView 的 ListView 也需要刷新。</span></span><br><span class="line">            bTreeItemsAreDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( OnGetChildren.<span class="built_in">IsBound</span>() &amp;&amp; TreeItemsSource != <span class="literal">nullptr</span> )								</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 我们保留一份原来的Item信息，以便后面移除不再被看到的Item</span></span><br><span class="line">                <span class="comment">// &quot;TempSelectedItemsMap&quot; 当前我们选择的所有项的集合</span></span><br><span class="line">                TItemSet TempSelectedItemsMap;</span><br><span class="line">                TSparseItemMap TempSparseItemInfo;</span><br><span class="line">                TArray&lt;FItemInfo&gt; TempDenseItemInfos;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重建树数据的线性视图</span></span><br><span class="line">                LinearizedItems.<span class="built_in">Empty</span>();</span><br><span class="line">                <span class="built_in">PopulateLinearizedItems</span>( *TreeItemsSource, LinearizedItems, TempDenseItemInfos, TBitArray&lt;&gt;(), TempSelectedItemsMap, TempSparseItemInfo, <span class="literal">true</span>, INDEX_NONE );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( !bAllowInvisibleItemSelection &amp;&amp;</span><br><span class="line">                   (<span class="keyword">this</span>-&gt;SelectedItems.<span class="built_in">Num</span>() != TempSelectedItemsMap.<span class="built_in">Num</span>() ||</span><br><span class="line">                    <span class="keyword">this</span>-&gt;SelectedItems.<span class="built_in">Difference</span>(TempSelectedItemsMap).<span class="built_in">Num</span>() &gt; <span class="number">0</span> || </span><br><span class="line">                    TempSelectedItemsMap.<span class="built_in">Difference</span>(<span class="keyword">this</span>-&gt;SelectedItems).<span class="built_in">Num</span>() &gt; <span class="number">0</span> ))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;SelectedItems = TempSelectedItemsMap;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ( !TListTypeTraits&lt;ItemType&gt;::<span class="built_in">IsPtrValid</span>( <span class="keyword">this</span>-&gt;RangeSelectionStart ) ||</span><br><span class="line">                        !<span class="keyword">this</span>-&gt;SelectedItems.<span class="built_in">Contains</span>( TListTypeTraits&lt;ItemType&gt;::<span class="built_in">NullableItemTypeConvertToItemType</span>( <span class="keyword">this</span>-&gt;RangeSelectionStart ) ))</span><br><span class="line">                    &#123;</span><br><span class="line">                        TListTypeTraits&lt; ItemType &gt;::<span class="built_in">ResetPtr</span>( <span class="keyword">this</span>-&gt;RangeSelectionStart );</span><br><span class="line">                        TListTypeTraits&lt; ItemType &gt;::<span class="built_in">ResetPtr</span>( <span class="keyword">this</span>-&gt;SelectorItem );</span><br><span class="line">                    &#125;	</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ( !TListTypeTraits&lt;ItemType&gt;::<span class="built_in">IsPtrValid</span>( <span class="keyword">this</span>-&gt;SelectorItem ) || </span><br><span class="line">                             !<span class="keyword">this</span>-&gt;SelectedItems.<span class="built_in">Contains</span>( TListTypeTraits&lt;ItemType&gt;::<span class="built_in">NullableItemTypeConvertToItemType</span>( <span class="keyword">this</span>-&gt;SelectorItem ) ) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">this</span>-&gt;SelectorItem = <span class="keyword">this</span>-&gt;RangeSelectionStart;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 激活选择改变时代理(OnSelectionChanged)</span></span><br><span class="line">                    <span class="keyword">this</span>-&gt;<span class="built_in">Private_SignalSelectionChanged</span>(ESelectInfo::Direct);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这些应该在Private_Signal SelectionChanged()之后出现;</span></span><br><span class="line">                <span class="comment">// 因为通过一系列调用，Private_SignalSelectionChanged()可能会在索引到这些数组中任何一个的子级中结束（该索引尚未更新，并且可能无效）</span></span><br><span class="line">                SparseItemInfos = <span class="built_in">MoveTemp</span>(TempSparseItemInfo);</span><br><span class="line">                DenseItemInfos  = <span class="built_in">MoveTemp</span>(TempDenseItemInfos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只有选择改变事件被激活时，我们可以更新父节点的高亮状态</span></span><br><span class="line">                <span class="keyword">if</span> (bHighlightParentNodesForSelection)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;<span class="built_in">Private_UpdateParentHighlights</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TreeView 基类的 Tick，以便基类也能被刷新</span></span><br><span class="line">    <span class="comment">// 调用该函数是因为 TreeView 需要刷新，或有新的 Items 因为列表缩放或滑动变为可见</span></span><br><span class="line">    SListView&lt; ItemType &gt;::<span class="built_in">Tick</span>(AllottedGeometry, InCurrentTime, InDeltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight c++"><figcaption><span>STableViewBase.Tick</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STableViewBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STableViewBase::Tick</span><span class="params">( <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, <span class="keyword">const</span> <span class="keyword">double</span> InCurrentTime, <span class="keyword">const</span> <span class="keyword">float</span> InDeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ItemsPanel.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 先获取 ItemPanel 的几何体(位置大小信息)</span></span><br><span class="line">		FGeometry PanelGeometry = <span class="built_in">FindChildGeometry</span>( AllottedGeometry, ItemsPanel.<span class="built_in">ToSharedRef</span>() );</span><br><span class="line">        <span class="comment">// bItemNeedRefresh 在之前的 &quot;STableViewBase::ConstructChildren&quot; 中被设为 true</span></span><br><span class="line">        <span class="comment">// 几何体大小发生变化时也是需要刷新Item(项)的</span></span><br><span class="line">		<span class="keyword">if</span> ( bItemsNeedRefresh || PanelGeometryLastTick.<span class="built_in">GetLocalSize</span>() != PanelGeometry.<span class="built_in">GetLocalSize</span>())</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 缓存当前窗口的集合体数据，以备下次刷新时做对比</span></span><br><span class="line">			PanelGeometryLastTick = PanelGeometry;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">const</span> int32 NumItemsPerLine = <span class="built_in">GetNumItemsPerLine</span>();</span><br><span class="line">            <span class="comment">// 是否有新的 Item 进入视图，用于激活 OnItemScrolledIntoView 代理</span></span><br><span class="line">			<span class="keyword">const</span> EScrollIntoViewResult ScrollIntoViewResult = <span class="built_in">ScrollIntoView</span>(PanelGeometry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 目标滚动偏移(目标位置的第一个项的序号)</span></span><br><span class="line">			<span class="keyword">double</span> TargetScrollOffset = <span class="built_in">GetTargetScrollOffset</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 允许动画化滚动</span></span><br><span class="line">			<span class="keyword">if</span> (bEnableAnimatedScrolling)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 插值算滚动偏移</span></span><br><span class="line">				CurrentScrollOffset = FMath::<span class="built_in">FInterpTo</span>(CurrentScrollOffset, TargetScrollOffset, InDeltaTime, <span class="number">12.f</span>);</span><br><span class="line">				<span class="keyword">if</span> (FMath::<span class="built_in">IsNearlyEqual</span>(CurrentScrollOffset, TargetScrollOffset, <span class="number">0.01</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					CurrentScrollOffset = TargetScrollOffset;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 直接设置偏移</span></span><br><span class="line">				CurrentScrollOffset = TargetScrollOffset;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新生成项，重要函数，下文分析 (可以是List Items，也可以是table Items)</span></span><br><span class="line">			<span class="keyword">const</span> FReGenerateResults ReGenerateResults = <span class="built_in">ReGenerateItems</span>( PanelGeometry );</span><br><span class="line">            <span class="comment">// 缓存新生成项的数据</span></span><br><span class="line">			LastGenerateResults = ReGenerateResults;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取可以被看见的 Item 的个数，计算需要多少行</span></span><br><span class="line">			<span class="keyword">const</span> int32 NumItemsBeingObserved = <span class="built_in">GetNumItemsBeingObserved</span>();</span><br><span class="line">			<span class="keyword">const</span> int32 NumItemLines = NumItemsBeingObserved / NumItemsPerLine;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否可以完全容纳所有项，设置当前滚动偏移</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">double</span> InitialDesiredOffset = DesiredScrollOffset;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bEnoughRoomForAllItems = ReGenerateResults.ExactNumLinesOnScreen &gt;= NumItemLines;</span><br><span class="line">			<span class="keyword">if</span> (bEnoughRoomForAllItems)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">SetScrollOffset</span>(<span class="number">0.0</span>);</span><br><span class="line">				CurrentScrollOffset = TargetScrollOffset = DesiredScrollOffset;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ReGenerateResults.bGeneratedPastLastItem)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">SetScrollOffset</span>(FMath::<span class="built_in">Max</span>(<span class="number">0.0</span>, ReGenerateResults.NewScrollOffset));</span><br><span class="line">				CurrentScrollOffset = TargetScrollOffset = DesiredScrollOffset;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 计算当前第一行的滚动偏移</span></span><br><span class="line">			<span class="keyword">double</span> FirstLineScrollOffset = CurrentScrollOffset / NumItemsPerLine;</span><br><span class="line">			FirstLineScrollOffset = FirstLineScrollOffset - (int64)FirstLineScrollOffset;</span><br><span class="line">			ItemsPanel-&gt;<span class="built_in">SetFirstLineScrollOffset</span>(FirstLineScrollOffset);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过度滚动相关设置</span></span><br><span class="line">			<span class="keyword">if</span> (AllowOverscroll == EAllowOverscroll::Yes)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">float</span> OverscrollAmount = Overscroll.<span class="built_in">GetOverscroll</span>(<span class="built_in">GetTickSpaceGeometry</span>());</span><br><span class="line">				ItemsPanel-&gt;<span class="built_in">SetOverscrollAmount</span>( OverscrollAmount );</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新选定项集</span></span><br><span class="line">			<span class="built_in">UpdateSelectionSet</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 更新滚动条</span></span><br><span class="line">			<span class="keyword">if</span> (NumItemsBeingObserved &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ReGenerateResults.ExactNumLinesOnScreen &lt; <span class="number">1.0f</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 计算滚动条的size比例 = 几何体的Y / 所有项的Length和</span></span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">double</span> VisibleSizeFraction = AllottedGeometry.<span class="built_in">GetLocalSize</span>().Y / ReGenerateResults.LengthOfGeneratedItems;</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">double</span> ThumbSizeFraction = FMath::<span class="built_in">Min</span>(VisibleSizeFraction, <span class="number">1.0</span>);</span><br><span class="line">                    <span class="comment">// 计算偏移比例</span></span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">double</span> OffsetFraction = CurrentScrollOffset / NumItemsBeingObserved;</span><br><span class="line">					ScrollBar-&gt;<span class="built_in">SetState</span>( OffsetFraction, ThumbSizeFraction );</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 计算滚动条的size比例 = 可显示的行数 / 总行数</span></span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">double</span> ThumbSizeFraction = ReGenerateResults.ExactNumLinesOnScreen / NumItemLines;</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">double</span> OffsetFraction = CurrentScrollOffset / NumItemsBeingObserved;</span><br><span class="line">					ScrollBar-&gt;<span class="built_in">SetState</span>( OffsetFraction, ThumbSizeFraction );</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 可以容下全部 Items</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">double</span> ThumbSizeFraction = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">double</span> OffsetFraction = <span class="number">0</span>;</span><br><span class="line">				ScrollBar-&gt;<span class="built_in">SetState</span>( OffsetFraction, ThumbSizeFraction );</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否已处于列表最下方</span></span><br><span class="line">			bWasAtEndOfList = (ScrollBar-&gt;<span class="built_in">DistanceFromBottom</span>() &lt; SMALL_NUMBER);</span><br><span class="line"></span><br><span class="line">			bItemsNeedRefresh = <span class="literal">false</span>;</span><br><span class="line">			ItemsPanel-&gt;<span class="built_in">SetRefreshPending</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">Invalidate</span>(EInvalidateWidget::ChildOrder);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bScrollIntoViewSuccess = ScrollIntoViewResult == EScrollIntoViewResult::Success;</span><br><span class="line">			<span class="keyword">if</span> (bScrollIntoViewSuccess)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 只要有新的 Item 进入视图，激活该通知</span></span><br><span class="line">				<span class="built_in">NotifyItemScrolledIntoView</span>();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!bScrollIntoViewSuccess || CurrentScrollOffset != TargetScrollOffset)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 如果我们没有创建该 Item 或者仍然处于滚动状态，我们都需要在下一帧刷新</span></span><br><span class="line">                <span class="comment">// 我们调用如下函数 而不是直接将 &quot;bItemNeedRefresh&quot; 设置为 true，是为了确保 &quot;EnsureTickToRefresh&quot; 被注册</span></span><br><span class="line">                <span class="comment">// 该函数将 ItemPanel 设置为挂起刷新，会在后面的帧更新中得到更新</span></span><br><span class="line">				<span class="built_in">RequestLayoutRefresh</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到，&quot;STreeView&quot; 的 &quot;Tick&quot; 函数实际上是调用自己 及其基类 &quot;STableViewBase&quot; 的 &quot;Tick&quot; 函数的 (上面两段代码)。主要完成了以下几个任务 (具体步骤写在注释里了)：</p><ul><li>重建树数据的线性视图，激活 &quot;OnSelectionChanged&quot; 代理</li><li>将父节点设置为高亮</li><li>计算滚动偏移量，插值计算当前偏移量</li><li><strong>重新生成属性项 &quot;Items&quot;，具体代码下文分析</strong></li><li>计算 &quot;ItemsPanel&quot; 中可见的首行滚动偏移量</li><li>设置过度偏移</li><li>更新已选的 Items 集合</li><li>更新滚动条</li><li>如果有新 Item 进入窗口，则激活 &quot;OnItemScrolledIntoView&quot; 代理</li><li>如果没有创建该 Item 或者仍然处于滚动状态，进入挂起刷新状态</li></ul><p>到这里其实我们还是没有弄明白：&quot;SDetailsView&quot; 中每个项 (具体属性) 都是怎么生成出来的？</p><p>莫急，咱这就开始分析，答案就在 &quot;ReGenerateItems&quot; 函数中 😃</p><h3 id="生成属性项"><a class="anchor" href="#生成属性项">#</a> 生成属性项</h3><h4 id="regenerateitems"><a class="anchor" href="#regenerateitems">#</a> ReGenerateItems</h4><p></p><figure class="highlight c++"><figcaption><span>ReGenerateItems</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SListView.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FReGenerateResults <span class="title">ReGenerateItems</span><span class="params">( <span class="keyword">const</span> FGeometry&amp; MyGeometry )</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从我们的面板中清除所有的项。我们将重新按正确的顺序添加他们</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ClearWidgets</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的 &quot;FGenerationPassGuard&quot;，以便记录我们当前已生成的 Widget</span></span><br><span class="line">    <span class="function">FGenerationPassGuard <span class="title">GenerationPassGuard</span><span class="params">(WidgetGenerator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ItemsSource &amp;&amp; ItemsSource-&gt;<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 视图中的项，包含小数项</span></span><br><span class="line">        <span class="keyword">float</span> ItemsInView = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前为止生成的所有 Widgets 的长度(竖直列表为高度，横向列表为宽度)</span></span><br><span class="line">        <span class="keyword">float</span> LengthGeneratedSoFar = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在显示栏中生成的 Widgets 的长度</span></span><br><span class="line">        <span class="keyword">float</span> ViewLengthUsedSoFar = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于当前滚动为止，我们开始生成项的索引</span></span><br><span class="line">        <span class="comment">// 注意这里最少必须生成一个项</span></span><br><span class="line">        int32 StartIndex = FMath::<span class="built_in">Clamp</span>( FMath::<span class="built_in">FloorToInt</span>(CurrentScrollOffset), <span class="number">0</span>, ItemsSource-&gt;<span class="built_in">Num</span>() - <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个生成项的长度。此项位于用户需要我们滚动到的地方</span></span><br><span class="line">        <span class="keyword">float</span> FirstItemLength = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束标志</span></span><br><span class="line">        <span class="keyword">bool</span> bHasFilledAvailableArea = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> bAtEndOfList = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 布局缩放修改器</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> LayoutScaleMultiplier = MyGeometry.<span class="built_in">GetAccumulatedLayoutTransform</span>().<span class="built_in">GetScale</span>();</span><br><span class="line">        <span class="comment">// 表的维度信息(是否竖直表，表的长和宽)</span></span><br><span class="line">        <span class="function">FTableViewDimensions <span class="title">MyDimensions</span><span class="params">(<span class="keyword">this</span>-&gt;Orientation, MyGeometry.GetLocalSize())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有 Item 直至全部遍历完，或已填满整个可填充区域</span></span><br><span class="line">        <span class="keyword">for</span>( int32 ItemIndex = StartIndex; !bHasFilledAvailableArea &amp;&amp; ItemIndex &lt; ItemsSource-&gt;<span class="built_in">Num</span>(); ++ItemIndex )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> ItemType&amp; CurItem = (*ItemsSource)[ItemIndex];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!TListTypeTraits&lt;ItemType&gt;::<span class="built_in">IsPtrValid</span>(CurItem))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 跳过无效项</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为当前项生成 Widget，重要函数，下文分析</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> ItemLength = <span class="built_in">GenerateWidgetForItem</span>(CurItem, ItemIndex, StartIndex, LayoutScaleMultiplier);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个项需要特殊处理</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> bIsFirstItem = ItemIndex == StartIndex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bIsFirstItem)</span><br><span class="line">            &#123;</span><br><span class="line">                FirstItemLength = ItemLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跟踪视图中项的数量，包括小数</span></span><br><span class="line">            <span class="keyword">if</span> (bIsFirstItem)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 第一项可能不能完全显示出来</span></span><br><span class="line">                <span class="comment">// &quot;FirstItemFractionScrolledIntoView&quot; 是第一个项可显示的百分比</span></span><br><span class="line">                <span class="comment">// &quot;CurrentScrollOffset&quot; 表示当前的滚动偏移量，数字表示其实是 当前项 + 当前项已滑过的百分比</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">float</span> FirstItemFractionScrolledIntoView = <span class="number">1.0f</span> - FMath::<span class="built_in">Max</span>(FMath::<span class="built_in">Fractional</span>(CurrentScrollOffset), <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// FirstItemLengthScrolledIntoView 是第一项在当前滚动定位下可显示的最大长度</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">float</span> FirstItemLengthScrolledIntoView = ItemLength * FirstItemFractionScrolledIntoView;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// FirstItemVisibleFraction 是 第一项在当前窗口可显示的百分比</span></span><br><span class="line">                <span class="comment">// Min 运算中，前者用于第一项长度已大于整个列表时只显示 ScrollAxis/Length 百分比的项</span></span><br><span class="line">                <span class="comment">// 后者用于项需显示的长度可完全显示在列表中时，表示所需显示的百分比</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">float</span> FirstItemVisibleFraction = FMath::<span class="built_in">Min</span>(MyDimensions.ScrollAxis / FirstItemLengthScrolledIntoView, FirstItemFractionScrolledIntoView);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将可显示的分数添加到 ItemInView 中</span></span><br><span class="line">                ItemsInView += FirstItemVisibleFraction;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ViewLengthUsedSoFar + ItemLength &gt; MyDimensions.ScrollAxis)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 最后一项也可能不完全可见</span></span><br><span class="line">                ItemsInView += (MyDimensions.ScrollAxis - ViewLengthUsedSoFar) / ItemLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ItemsInView += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前所有生成的Item的长度和</span></span><br><span class="line">            LengthGeneratedSoFar += ItemLength;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前已使用的视图长度</span></span><br><span class="line">            ViewLengthUsedSoFar += (bIsFirstItem)</span><br><span class="line">                ? ItemLength * ItemsInView	<span class="comment">// For the first item, ItemsInView &lt;= 1.0f</span></span><br><span class="line">                : ItemLength;</span><br><span class="line"></span><br><span class="line">            bAtEndOfList = ItemIndex &gt;= ItemsSource-&gt;<span class="built_in">Num</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bIsFirstItem &amp;&amp; ViewLengthUsedSoFar &gt;= MyDimensions.ScrollAxis)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果当前已使用窗口更新是否已填满所有可填充区域</span></span><br><span class="line">                bHasFilledAvailableArea = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 注意: 如果不是第一个元素，则需要跟上一个元素保持一定距离</span></span><br><span class="line">                <span class="comment">// 为了避免累积误差，我们需要加上 FloatPrecisionOffset</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">float</span> FloatPrecisionOffset = <span class="number">0.001f</span>;</span><br><span class="line">                bHasFilledAvailableArea = ViewLengthUsedSoFar &gt;= MyDimensions.ScrollAxis + FloatPrecisionOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前滚动位置下已显示最后一个项，但还有额外空间</span></span><br><span class="line">        <span class="comment">// 这意味着我们可以在不影响当前项的显示的情况下，回退以显示更多的项</span></span><br><span class="line">        <span class="keyword">if</span> (bAtEndOfList &amp;&amp; !bHasFilledAvailableArea)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算回退到的滚动偏移量</span></span><br><span class="line">            <span class="keyword">double</span> NewScrollOffsetForBackfill = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(StartIndex) + (LengthGeneratedSoFar - MyDimensions.ScrollAxis) / FirstItemLength;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从当前第一项开始向前遍历，直至遍历完所有前面的元素，或容器填满</span></span><br><span class="line">            <span class="comment">// 计算 &quot;LengthGeneratedSoFar&quot;，用来在后面调用 &quot;FReGenerateResults&quot;</span></span><br><span class="line">            <span class="keyword">for</span> (int32 ItemIndex = StartIndex - <span class="number">1</span>; LengthGeneratedSoFar &lt; MyDimensions.ScrollAxis &amp;&amp; ItemIndex &gt;= <span class="number">0</span>; --ItemIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> ItemType&amp; CurItem = (*ItemsSource)[ItemIndex];</span><br><span class="line">                <span class="keyword">if</span> (TListTypeTraits&lt;ItemType&gt;::<span class="built_in">IsPtrValid</span>(CurItem))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">float</span> ItemLength = <span class="built_in">GenerateWidgetForItem</span>(CurItem, ItemIndex, StartIndex, LayoutScaleMultiplier);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (LengthGeneratedSoFar + ItemLength &gt; MyDimensions.ScrollAxis &amp;&amp; ItemLength &gt; <span class="number">0.f</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 生成放在顶部的Item，计算此项超出列表的部分</span></span><br><span class="line">                        NewScrollOffsetForBackfill = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(ItemIndex) + (LengthGeneratedSoFar + ItemLength - MyDimensions.ScrollAxis) / ItemLength;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新当前已使用的空间长度</span></span><br><span class="line">                    LengthGeneratedSoFar += ItemLength;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新生成回退后的列表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FReGenerateResults</span>(NewScrollOffsetForBackfill, LengthGeneratedSoFar, ItemsSource-&gt;<span class="built_in">Num</span>() - NewScrollOffsetForBackfill, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成不需要回退的列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FReGenerateResults</span>(CurrentScrollOffset, LengthGeneratedSoFar, ItemsInView, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成无项列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FReGenerateResults</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面的代码分析中可以看到，&quot;ReGenerateItems&quot; 主要是负责生成 Item (GeneratedWidgetForItem)，并把该 Item 可显示的部分显示出来。如果滑动过度，则需要额外进行回退处理。其他的细节处理都写在注释中了，不再赘述。</p><p>看似已经全部生成好了，但其实我们还是不知道引擎到底时怎么为每个项生成 Widget 的，我们继续深入看看每一项的生成是怎么做的吧</p><h3 id="generatedwidgetforitem"><a class="anchor" href="#generatedwidgetforitem">#</a> GeneratedWidgetForItem</h3><p></p><figure class="highlight c++"><figcaption><span>GeneratedWidgetForItem</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SListView.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GenerateWidgetForItem</span><span class="params">( <span class="keyword">const</span> ItemType&amp; CurItem, int32 ItemIndex, int32 StartIndex, <span class="keyword">float</span> LayoutScaleMultiplier )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ensure</span>(TListTypeTraits&lt;ItemType&gt;::<span class="built_in">IsPtrValid</span>(CurItem));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为此项寻找一个预存的 Widget (如果有)</span></span><br><span class="line">    TSharedPtr&lt;ITableRow&gt; WidgetForItem = WidgetGenerator.<span class="built_in">GetWidgetForItem</span>( CurItem );</span><br><span class="line">    <span class="keyword">if</span> ( !WidgetForItem.<span class="built_in">IsValid</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 我们如果没有找到存在的预存Widget，意味着这个 Item 之前是不可见的，需要为其生成一个新的</span></span><br><span class="line">        WidgetForItem = <span class="keyword">this</span>-&gt;<span class="built_in">GenerateNewWidget</span>(CurItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该 Item 设置一个索引，这有助于我们分清是哪个项生成的此 Widget</span></span><br><span class="line">    <span class="comment">// 还可以用于奇偶数的着色</span></span><br><span class="line">    WidgetForItem-&gt;<span class="built_in">SetIndexInList</span>(ItemIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 WidgetGenerator 将该 Widget 和 Item 关联并缓存起来，</span></span><br><span class="line">    <span class="comment">// 以到达不重复生成相同的 Widget 的目的，提高生成效率</span></span><br><span class="line">    WidgetGenerator.<span class="built_in">OnItemSeen</span>( CurItem, WidgetForItem.<span class="built_in">ToSharedRef</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此 Widget 的所有子项的 DesiredSize 预加载一遍，并缓存起来</span></span><br><span class="line">    <span class="keyword">const</span> TSharedRef&lt;SWidget&gt; NewlyGeneratedWidget = WidgetForItem-&gt;<span class="built_in">AsWidget</span>();</span><br><span class="line">    NewlyGeneratedWidget-&gt;<span class="built_in">InvalidatePrepass</span>();</span><br><span class="line">    NewlyGeneratedWidget-&gt;<span class="built_in">SlatePrepass</span>(LayoutScaleMultiplier);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们已经有这个项的 Widget，将其添加到面板中，以便成为 UI 的一部分</span></span><br><span class="line">    <span class="keyword">if</span> (ItemIndex &gt;= StartIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向下添加 Widget</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">AppendWidget</span>( WidgetForItem.<span class="built_in">ToSharedRef</span>() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 回退时往上插入 Widget</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">InsertWidget</span>( WidgetForItem.<span class="built_in">ToSharedRef</span>() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可见则返回 DesiredSize ，否则返回 ZeroVector</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> bIsVisible = NewlyGeneratedWidget-&gt;<span class="built_in">GetVisibility</span>().<span class="built_in">IsVisible</span>();</span><br><span class="line">    <span class="function">FTableViewDimensions <span class="title">GeneratedWidgetDimensions</span><span class="params">(<span class="keyword">this</span>-&gt;Orientation, bIsVisible ? NewlyGeneratedWidget-&gt;GetDesiredSize() : FVector2D::ZeroVector)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> GeneratedWidgetDimensions.ScrollAxis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;GenerateWidgetForItem&quot; 函数理解起来还是比较简单的 (注释 yyds！)，具体流程是：先用当前 Item 生成一个 Widget (默认 WidgetGenerator 一开始没有 Widget)，初始化 ItemIndex 后，在 WidgetGenerator 中将此 Widget 和对应的 Item 关联并缓存起来，以便下次需要生成该 Item 的 Widget 时可以直接取用。然后我们将此 Widget 的所有子项的 DesiredSize 预加载一遍，并缓存起来。再之后就是将此 Widget 添加到 ItemPanel 里面，最后将此 Widget 的 DesiredSize 返回出去。</p><p>那到这里我们就剩下最后一步了 —— GenerateNewWidget (真正为该项生成 Widget 的函数)</p><p></p><figure class="highlight c++"><figcaption><span>GenerateNewWidget</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SListView.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TSharedRef&lt;ITableRow&gt; <span class="title">GenerateNewWidget</span><span class="params">(ItemType InItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( OnGenerateRow.<span class="built_in">IsBound</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果用户指定了生成该 Widget 的回调方法，我们就直接调用</span></span><br><span class="line">        <span class="comment">// 这里的之所以命名为 &quot;OnGenerateRow&quot;，是因为我们生成的 &quot;ITableRow&quot; 其实是列表的行类</span></span><br><span class="line">        <span class="keyword">return</span> OnGenerateRow.<span class="built_in">Execute</span>( InItem, <span class="built_in">SharedThis</span>(<span class="keyword">this</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果用户没有指定回调，我们就直接生成一个 &quot;STableRow&quot;，</span></span><br><span class="line">        <span class="comment">// 并在其内部生成一个 &quot;STextBlock&quot; 用以提示用户没有绑定 &quot;OnGenerateWidget&quot; 回调</span></span><br><span class="line">        TSharedRef&lt; STableRow&lt;ItemType&gt; &gt; NewListItemWidget = </span><br><span class="line">            <span class="built_in">SNew</span>( STableRow&lt;ItemType&gt;, <span class="built_in">SharedThis</span>(<span class="keyword">this</span>) )</span><br><span class="line">            .<span class="built_in">Content</span>()</span><br><span class="line">            [</span><br><span class="line">            <span class="built_in">SNew</span>(STextBlock) .<span class="built_in">Text</span>( <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;SListView&quot;</span>, <span class="string">&quot;BrokenUIMessage&quot;</span>, <span class="string">&quot;OnGenerateWidget() not assigned.&quot;</span>) )</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NewListItemWidget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到 &quot;GenerateNewWidget&quot; 其实就是简单的高达拼装 (比我们之前分析的 Construct 函数里面的简单)，&quot;OnGenerateRaw&quot; 的回调函数 不同 Slate 会有不同的策略。既然我们这篇主要分析的是 &quot;SDetailsView&quot;，那自然是要看看 &quot;OnGenerateRaw&quot; 在 &quot;SDetailsView&quot; 中的实现的。</p><h3 id="ongenerateraw"><a class="anchor" href="#ongenerateraw">#</a> OnGenerateRaw</h3><p><img data-src="ConstructTreeView.png" alt="ConstructTreeView"></p><p></p><figure class="highlight c++"><figcaption><span>OnGenerateRaw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDetailsViewBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">TSharedRef&lt;ITableRow&gt; <span class="title">SDetailsViewBase::OnGenerateRowForDetailTree</span><span class="params">(TSharedRef&lt;FDetailTreeNode&gt; InTreeNode, <span class="keyword">const</span> TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;FDetailTreeNode&quot; 是 所有细节树节点的基类</span></span><br><span class="line">	<span class="keyword">return</span> InTreeNode-&gt;<span class="built_in">GenerateWidgetForTableView</span>(OwnerTable, ColumnSizeData, DetailsViewArgs.bAllowFavoriteSystem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DetailItemNode.cpp (只是 &quot;FDetailTreeNode&quot; 的其中一个子类)</span></span><br><span class="line"></span><br><span class="line"><span class="function">TSharedRef&lt; ITableRow &gt; <span class="title">FDetailItemNode::GenerateWidgetForTableView</span><span class="params">( <span class="keyword">const</span> TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable, <span class="keyword">const</span> FDetailColumnSizeData&amp; ColumnSizeData, <span class="keyword">bool</span> bAllowFavoriteSystem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加该项的元数据</span></span><br><span class="line">	<span class="function">FTagMetaData <span class="title">TagMeta</span><span class="params">(TEXT(<span class="string">&quot;DetailRowItem&quot;</span>))</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (ParentCategory.<span class="built_in">IsValid</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Customization.<span class="built_in">IsValidCustomization</span>() &amp;&amp; Customization.<span class="built_in">GetPropertyNode</span>().<span class="built_in">IsValid</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			TagMeta.Tag = *FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;DetailRowItem.%s&quot;</span>), *Customization.<span class="built_in">GetPropertyNode</span>()-&gt;<span class="built_in">GetDisplayName</span>().<span class="built_in">ToString</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Customization.<span class="built_in">HasCustomWidget</span>() )</span><br><span class="line">		&#123;</span><br><span class="line">			TagMeta.Tag = Customization.<span class="built_in">GetWidgetRow</span>().RowTagName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有属性节点，且该属性节点有分类则构造一个 &quot;SDetailCategoryTableRow&quot; </span></span><br><span class="line">    <span class="comment">// 否则构造一个 &quot;SDetailSingleItemRow&quot; </span></span><br><span class="line">	<span class="keyword">if</span>( Customization.<span class="built_in">HasPropertyNode</span>() &amp;&amp; Customization.<span class="built_in">GetPropertyNode</span>()-&gt;<span class="built_in">AsCategoryNode</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">			<span class="built_in">SNew</span>(SDetailCategoryTableRow, <span class="built_in">AsShared</span>(), OwnerTable)</span><br><span class="line">			.<span class="built_in">DisplayName</span>(Customization.<span class="built_in">GetPropertyNode</span>()-&gt;<span class="built_in">GetDisplayName</span>())</span><br><span class="line">			.AddMetaData&lt;FTagMetaData&gt;(TagMeta)</span><br><span class="line">			.<span class="built_in">ColumnSizeData</span>(&amp;ColumnSizeData)</span><br><span class="line">			.<span class="built_in">InnerCategory</span>( <span class="literal">true</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">			<span class="built_in">SNew</span>(SDetailSingleItemRow, &amp;Customization, <span class="built_in">HasMultiColumnWidget</span>(), <span class="built_in">AsShared</span>(), OwnerTable )</span><br><span class="line">			.AddMetaData&lt;FTagMetaData&gt;(TagMeta)</span><br><span class="line">			.<span class="built_in">ColumnSizeData</span>(ColumnSizeData)</span><br><span class="line">			.<span class="built_in">AllowFavoriteSystem</span>(bAllowFavoriteSystem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;SDetailsView&quot; 绑定的 &quot;OnGeneratedRow&quot; 回调还算简单，只是生成元数据和一个 &quot;SDetailSingleItemRow&quot; 对象。&quot;SDetailSingleItemRow&quot; 对象的构造咱就不展开说了，主要就是生成一个 &quot;NameWidget&quot; 和一个 &quot;ValueWidget&quot;，如果 &quot;ValueWidget&quot; 还有 &quot;ExtensionWidget&quot; ，则再把 &quot;ExtensionWidget&quot; 给处理一下 (如 &quot;Transfrom&quot; 就会有 &quot;Location&quot; 这种 &quot;ExtensionWidget&quot;)</p><p>&quot;SDetailsView&quot; 中还有很多其他函数，但基本上都是对其属性做一些读写操作的，我们分析完 &quot;Construct&quot; 和 &quot;Tick&quot; 基本就知道其运行机制和底层实现原理了，不再逐个分析内部函数。有兴趣的朋友请自行翻阅源码 )</p><p>到此，咱对 &quot;SDetailsView&quot; 的探究就先告一段落了，文章末尾还会做一次总结，以便加深印象和复习使用。</p><hr><h2 id="slate-的整体实现思路"><a class="anchor" href="#slate-的整体实现思路">#</a> Slate 的整体实现思路</h2><p>通过上面对 &quot;SDetailsView&quot; 的分析，不知道是否让读者对 Slate 的整体实现思路有所看法了呢？没有也没关系，我们下面就来从大方向上看看，如果我们要写一个自己的 Slate 要怎么做？(这对我们开发插件非常有帮助)</p><h3 id="前置知识-常识"><a class="anchor" href="#前置知识-常识">#</a> 前置知识 (常识)</h3><p>开始讲实现之前，我们要先了解一些 Slate 相关 的常识性知识。</p><p><img data-src="%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt="继承图"></p><p>知识点：</p><ul><li><p>所有 Slate 类都是 SWidget 的子类</p></li><li><p>SWidget 下有三个子类，分别是 &quot;SLeafWidget&quot;，&quot;SCompoundWidget&quot;，&quot;SPanelWidget&quot;</p><table><thead><tr><th>SWidget</th><th>Child Slot 个数</th><th>如何实现 Child Slot</th></tr></thead><tbody><tr><td>SLeafWidget</td><td>0</td><td>不需要实现</td></tr><tr><td>SCompoundWidget</td><td>1</td><td>内置了 ChildSlot 属性，不需要实现</td></tr><tr><td>SPanelWidget</td><td>n</td><td>需要在子类内部自定义一个继承于 &quot;TSlotBase&lt;FSlot&gt;&quot; 的 &quot;FSlot&quot; 结构体，然后声明一个 &quot;TPanelChildren&lt;FSlot&gt;&quot; 变量，实现 &quot;AddSlot&quot; 函数等</td></tr></tbody></table></li><li><p>大部分的 Slate 类都是继承自 &quot;SCompoundWidget&quot; 的</p></li><li><p>我们一般用共享指针 (SharedRef，SharedPtr) 来创建并管理 Slate 对象，SWidget 中已经继承了 TSharedFromThis 类，我们尽管用其共享指针就好了</p></li><li><p>&quot;FArgument&quot; 中的属性一般在 &quot;SNew&quot;(如: Slot) 或 &quot;FArgument&quot; 的构造函数中初始化。而 Slate 类内部的属性，一般在 Slate 的构造函数 或 定义特定的函数来进行赋值。</p></li><li></li></ul><h3 id="实现-slate-类的流程"><a class="anchor" href="#实现-slate-类的流程">#</a> 实现 Slate 类的流程</h3><p>写者想了很久，实在是不知道实现什么 Slate 好 (UMG 中的 Slate 实现的功能不适合太复杂，而简单的 unreal 都给我们集成好了，再实现一次也只有抄代码的份... 心累)，所以咱就直接拿 &quot;SButton&quot; 的实现来总结一遍好了。</p><p>大概由一下几个步骤组成：</p><ol><li>明确该 Slate 是否有 Child Slot，并继承对应的 SWidget</li><li>明确该 Slate 需要实现的功能，并列出需要提供的属性和需要实现的回调函数</li><li>定义 &quot;FArgument&quot; 结构体</li><li>实现 &quot;Construct&quot; 函数</li><li>实现 &quot;OnPaint&quot; 函数 (如何绘制该 Slate 对象)</li><li>实现 回调方法 和 一些对属性的读写方法</li></ol><p>咱跟着上面的步骤走一遍。</p><p>UE 中 &quot;SButton&quot; 是直接继承自 &quot;SBorder&quot; 的，可以说 &quot;SButton&quot; 只是一个拥有点击事件的 &quot;SBroder&quot;，但因为类内结构体是不和子类共享的，我们的 &quot;SButton&quot; 需要实现自己的 &quot;FArgument&quot;，其定义如下：</p><h4 id="定义-fargument-结构体"><a class="anchor" href="#定义-fargument-结构体">#</a> 定义 FArgument 结构体</h4><p></p><figure class="highlight c++"><figcaption><span>SButton</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SButton.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SLATE_API</span> <span class="title">SButton</span></span></span><br><span class="line"><span class="class">	:</span> <span class="keyword">public</span> SBorder</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SLATE_BEGIN_ARGS</span>( SButton )</span><br><span class="line">		: _Content()</span><br><span class="line">		, _ButtonStyle( &amp;FCoreStyle::<span class="built_in">Get</span>().GetWidgetStyle&lt; FButtonStyle &gt;( <span class="string">&quot;Button&quot;</span> ) )</span><br><span class="line">		, _TextStyle( &amp;FCoreStyle::<span class="built_in">Get</span>().GetWidgetStyle&lt; FTextBlockStyle &gt;(<span class="string">&quot;NormalText&quot;</span>) )</span><br><span class="line">		, _HAlign( HAlign_Fill )</span><br><span class="line">		, _VAlign( VAlign_Fill )</span><br><span class="line">		, _ContentPadding(<span class="built_in">FMargin</span>(<span class="number">4.0</span>, <span class="number">2.0</span>))</span><br><span class="line">		, _Text()</span><br><span class="line">		, _ClickMethod( EButtonClickMethod::DownAndUp )</span><br><span class="line">		, _TouchMethod( EButtonTouchMethod::DownAndUp )</span><br><span class="line">		, _PressMethod( EButtonPressMethod::DownAndUp )</span><br><span class="line">		, _DesiredSizeScale( <span class="built_in">FVector2D</span>(<span class="number">1</span>,<span class="number">1</span>) )</span><br><span class="line">		, _ContentScale( <span class="built_in">FVector2D</span>(<span class="number">1</span>,<span class="number">1</span>) )</span><br><span class="line">		, _ButtonColorAndOpacity(FLinearColor::White)</span><br><span class="line">		, _ForegroundColor( FCoreStyle::<span class="built_in">Get</span>().<span class="built_in">GetSlateColor</span>( <span class="string">&quot;InvertedForeground&quot;</span> ) )</span><br><span class="line">		, _IsFocusable( <span class="literal">true</span> )</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// FArgument 的默认构造函数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FArgument 的属性，也是我们 SNew 时可以直接初始化的属性</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">/** button 的内容插槽 (可选) */</span></span><br><span class="line">		<span class="built_in">SLATE_DEFAULT_SLOT</span>( FArguments, Content )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** button 的视觉风格 */</span></span><br><span class="line">		<span class="built_in">SLATE_STYLE_ARGUMENT</span>( FButtonStyle, ButtonStyle )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** button 的字体风格(提示文本的字体，默认 Button 是不支持内容直接显示文字的)*/</span></span><br><span class="line">		<span class="built_in">SLATE_STYLE_ARGUMENT</span>( FTextBlockStyle, TextStyle )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 水平对齐 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( EHorizontalAlignment, HAlign )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 竖直对齐 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( EVerticalAlignment, VAlign )</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/** 边界和内容的间隔空间(Padding) */</span></span><br><span class="line">		<span class="built_in">SLATE_ATTRIBUTE</span>( FMargin, ContentPadding )</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/** button 内没有内容时显示的 提示文本 */</span></span><br><span class="line">		<span class="built_in">SLATE_ATTRIBUTE</span>( FText, Text )</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/** 鼠标点击事件代理 */</span></span><br><span class="line">		<span class="built_in">SLATE_EVENT</span>( FOnClicked, OnClicked )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 鼠标按下事件代理 */</span></span><br><span class="line">		<span class="built_in">SLATE_EVENT</span>( FSimpleDelegate, OnPressed )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 鼠标松开事件代理 */</span></span><br><span class="line">		<span class="built_in">SLATE_EVENT</span>( FSimpleDelegate, OnReleased )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 鼠标划入事件代理 */</span></span><br><span class="line">		<span class="built_in">SLATE_EVENT</span>( FSimpleDelegate, OnHovered )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 鼠标划出事件代理 */</span></span><br><span class="line">		<span class="built_in">SLATE_EVENT</span>( FSimpleDelegate, OnUnhovered )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 点击规则，左键点击还是右键点击，一般不用设置，默认左键 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( EButtonClickMethod::Type, ClickMethod )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** touch 事件的规则，一般不用设置 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( EButtonTouchMethod::Type, TouchMethod )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** press 事件的规则，一般不用设置 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( EButtonPressMethod::Type, PressMethod )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 按钮的缩放 (横向和纵向) */</span></span><br><span class="line">		<span class="built_in">SLATE_ATTRIBUTE</span>( FVector2D, DesiredSizeScale )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 内容的缩放 (横向和纵向) */</span></span><br><span class="line">		<span class="built_in">SLATE_ATTRIBUTE</span>( FVector2D, ContentScale )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 按钮的颜色和不透明度 */</span></span><br><span class="line">		<span class="built_in">SLATE_ATTRIBUTE</span>( FSlateColor, ButtonColorAndOpacity )</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 前景颜色 */</span></span><br><span class="line">		<span class="built_in">SLATE_ATTRIBUTE</span>( FSlateColor, ForegroundColor )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 当前是否被聚焦 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( <span class="keyword">bool</span>, IsFocusable )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 点击声音 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( TOptional&lt;FSlateSound&gt;, PressedSoundOverride )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 鼠标划入声音 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( TOptional&lt;FSlateSound&gt;, HoveredSoundOverride )</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 文本塑造方法，一般使用默认值 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( TOptional&lt;ETextShapingMethod&gt;, TextShapingMethod )</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/** 文本流反向，一般使用默认值 */</span></span><br><span class="line">		<span class="built_in">SLATE_ARGUMENT</span>( TOptional&lt;ETextFlowDirection&gt;, TextFlowDirection )</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SLATE_END_ARGS</span>()</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 用上面的 FArgument 在 Construct 函数中初始化以下以下属性</span></span><br><span class="line">        </span><br><span class="line">	<span class="keyword">const</span> FButtonStyle* Style;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">const</span> FSlateBrush* NormalImage;</span><br><span class="line">	<span class="keyword">const</span> FSlateBrush* HoverImage;</span><br><span class="line">	<span class="keyword">const</span> FSlateBrush* PressedImage;</span><br><span class="line">	<span class="keyword">const</span> FSlateBrush* DisabledImage;</span><br><span class="line"></span><br><span class="line">	FOnClicked OnClicked;</span><br><span class="line">	FSimpleDelegate OnPressed;</span><br><span class="line">	FSimpleDelegate OnReleased;</span><br><span class="line">	FSimpleDelegate OnHovered;</span><br><span class="line">	FSimpleDelegate OnUnhovered;</span><br><span class="line">        </span><br><span class="line">	FSlateSound HoveredSound;</span><br><span class="line">	FSlateSound PressedSound;</span><br><span class="line"></span><br><span class="line">	TEnumAsByte&lt;EButtonClickMethod::Type&gt; ClickMethod;</span><br><span class="line">	TEnumAsByte&lt;EButtonTouchMethod::Type&gt; TouchMethod;</span><br><span class="line">	TEnumAsByte&lt;EButtonPressMethod::Type&gt; PressMethod;</span><br><span class="line"></span><br><span class="line">	uint8 bIsFocusable:<span class="number">1</span>;</span><br><span class="line">	uint8 bIsPressed:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>无奖问答：为什么要这么做呢？</p><p>因为我们的 FArgument 可以在 SNew 的后面直接初始化，并调用该 SButton 的 Construct 函数。讲参数集成到一个结构体中可以使代码的可读性更高，且方便使用。</p><h4 id="定义-construct-函数"><a class="anchor" href="#定义-construct-函数">#</a> 定义 Construct 函数</h4><p></p><figure class="highlight c++"><figcaption><span>Construct</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SButton.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SButton::Construct</span><span class="params">( <span class="keyword">const</span> FArguments&amp; InArgs )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bIsPressed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于返回当前 button 的内容</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="function">TSharedRef&lt;SWidget&gt; <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> FArguments&amp; InOpArgs )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ((InOpArgs._Content.Widget == SNullWidget::NullWidget) &amp;&amp; (InOpArgs._Text.<span class="built_in">IsBound</span>() || !InOpArgs._Text.<span class="built_in">Get</span>().<span class="built_in">IsEmpty</span>()) )</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// SNew 一个提示文本 Slate</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">SNew</span>(STextBlock)</span><br><span class="line">					.<span class="built_in">Visibility</span>(EVisibility::HitTestInvisible)</span><br><span class="line">					.<span class="built_in">Text</span>( InOpArgs._Text )</span><br><span class="line">					.<span class="built_in">TextStyle</span>( InOpArgs._TextStyle )</span><br><span class="line">					.<span class="built_in">TextShapingMethod</span>( InOpArgs._TextShapingMethod )</span><br><span class="line">					.<span class="built_in">TextFlowDirection</span>( InOpArgs._TextFlowDirection );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 返回一个构造好的 Button Slate</span></span><br><span class="line">				<span class="keyword">return</span> InOpArgs._Content.Widget;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; DetermineContent; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 父类中的属性(包括 Button 内容)</span></span><br><span class="line">	SBorder::<span class="built_in">Construct</span>( SBorder::<span class="built_in">FArguments</span>()</span><br><span class="line">		.<span class="built_in">ContentScale</span>(InArgs._ContentScale)</span><br><span class="line">		.<span class="built_in">DesiredSizeScale</span>(InArgs._DesiredSizeScale)</span><br><span class="line">		.<span class="built_in">BorderBackgroundColor</span>(InArgs._ButtonColorAndOpacity)</span><br><span class="line">		.<span class="built_in">ForegroundColor</span>(InArgs._ForegroundColor)</span><br><span class="line">		.<span class="built_in">BorderImage</span>( <span class="keyword">this</span>, &amp;SButton::GetBorder )</span><br><span class="line">		.<span class="built_in">HAlign</span>( InArgs._HAlign )</span><br><span class="line">		.<span class="built_in">VAlign</span>( InArgs._VAlign )</span><br><span class="line">		.<span class="built_in">Padding</span>( TAttribute&lt;FMargin&gt;(<span class="keyword">this</span>, &amp;SButton::GetCombinedPadding) )</span><br><span class="line">		.<span class="built_in">ShowEffectWhenDisabled</span>( TAttribute&lt;<span class="keyword">bool</span>&gt;(<span class="keyword">this</span>, &amp;SButton::GetShowDisabledEffect) )</span><br><span class="line">		[</span><br><span class="line">			<span class="built_in">DetermineContent</span>(InArgs)</span><br><span class="line">		]</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只有在我们确实是一个 Button 的时候允许 Tick</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetType</span>() == SButtonTypeName)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SetCanTick</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化自身的属性</span></span><br><span class="line">	ContentPadding = InArgs._ContentPadding;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetButtonStyle</span>(InArgs._ButtonStyle);</span><br><span class="line"></span><br><span class="line">	bIsFocusable = InArgs._IsFocusable;</span><br><span class="line"></span><br><span class="line">	OnClicked = InArgs._OnClicked;</span><br><span class="line">	OnPressed = InArgs._OnPressed;</span><br><span class="line">	OnReleased = InArgs._OnReleased;</span><br><span class="line">	OnHovered = InArgs._OnHovered;</span><br><span class="line">	OnUnhovered = InArgs._OnUnhovered;</span><br><span class="line"></span><br><span class="line">	ClickMethod = InArgs._ClickMethod;</span><br><span class="line">	TouchMethod = InArgs._TouchMethod;</span><br><span class="line">	PressMethod = InArgs._PressMethod;</span><br><span class="line"></span><br><span class="line">	HoveredSound = InArgs._HoveredSoundOverride.<span class="built_in">Get</span>(Style-&gt;HoveredSlateSound);</span><br><span class="line">	PressedSound = InArgs._PressedSoundOverride.<span class="built_in">Get</span>(Style-&gt;PressedSlateSound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Construct 函数其实就是在初始化我们刚刚定义出来的属性 (变量，代理等)，以及初始化 ChildSlot 的布局 (用 SNew 来完成设置)</p><p>紧接着 我们要写 &quot;OnPaint&quot; 函数，设置咱的 &quot;Slate&quot; 对象的绘制方法</p><h4 id="onpaint"><a class="anchor" href="#onpaint">#</a> OnPaint</h4><p></p><figure class="highlight c++"><figcaption><span>OnPaint</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SButton.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">int32 <span class="title">SButton::OnPaint</span><span class="params">(<span class="keyword">const</span> FPaintArgs&amp; Args, <span class="keyword">const</span> FGeometry&amp; AllottedGeometry, <span class="keyword">const</span> FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, int32 LayerId, <span class="keyword">const</span> FWidgetStyle&amp; InWidgetStyle, <span class="keyword">bool</span> bParentEnabled)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取绘制资源列表</span></span><br><span class="line">	<span class="keyword">bool</span> bEnabled = <span class="built_in">ShouldBeEnabled</span>(bParentEnabled);</span><br><span class="line">	<span class="keyword">bool</span> bShowDisabledEffect = <span class="built_in">GetShowDisabledEffect</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> FSlateBrush* BrushResource = !bShowDisabledEffect &amp;&amp; !bEnabled ? DisabledImage : <span class="built_in">GetBorder</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取绘制效果</span></span><br><span class="line">	ESlateDrawEffect DrawEffects = bShowDisabledEffect &amp;&amp; !bEnabled ? ESlateDrawEffect::DisabledEffect : ESlateDrawEffect::None;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BrushResource &amp;&amp; BrushResource-&gt;DrawAs != ESlateBrushDrawType::NoDrawType)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 真正的绘制函数，以矩形的形式绘制一张 FSlateBrush (还有其他绘制函数)</span></span><br><span class="line">		FSlateDrawElement::<span class="built_in">MakeBox</span>(</span><br><span class="line">			OutDrawElements,	<span class="comment">// 用来添加元素的列表</span></span><br><span class="line">			LayerId,		<span class="comment">// 绘制元素的图层</span></span><br><span class="line">			AllottedGeometry.<span class="built_in">ToPaintGeometry</span>(),	<span class="comment">// 需要绘制的空间</span></span><br><span class="line">			BrushResource,	<span class="comment">// 用于绘制的资源列表</span></span><br><span class="line">			DrawEffects,	<span class="comment">// 绘制效果</span></span><br><span class="line">			BrushResource-&gt;<span class="built_in">GetTint</span>(InWidgetStyle) * InWidgetStyle.<span class="built_in">GetColorAndOpacityTint</span>() * BorderBackgroundColor.<span class="built_in">Get</span>().<span class="built_in">GetColor</span>(InWidgetStyle)	<span class="comment">// 	为元素着色的颜色</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制基类</span></span><br><span class="line">	<span class="keyword">return</span> SCompoundWidget::<span class="built_in">OnPaint</span>(Args, AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle, bEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是 SWidget 的接口函数，我们不用担心在哪里调用，我们只需要用传进来的参数来绘制出我们想要的效果就可以了。我们一般会用 &quot;MakeBox&quot; 来进行矩形绘制，前面主要是对 &quot;MakeBox&quot; 的参数的处理，如 &quot;PaintGeometry&quot;，&quot;BrushResource&quot;，&quot;DrawEffects&quot;。也可以用循环语句来绘制多张图片，总之就是画出我们想要的效果即可</p><p>剩下的就是一些简单的绑定，广播，获取，设置，调用等函数的设置。如下：</p><p></p><figure class="highlight c++"><figcaption><span>OtherFunc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SButton.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> FSlateBrush* <span class="title">SButton::GetBorder</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">GetShowDisabledEffect</span>() &amp;&amp; !<span class="built_in">IsEnabled</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> DisabledImage;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">IsPressed</span>() )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> PressedImage;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsHovered</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> HoverImage;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> NormalImage;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SButton::OnFocusLost</span><span class="params">( <span class="keyword">const</span> FFocusEvent&amp; InFocusEvent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SBorder::<span class="built_in">OnFocusLost</span>(InFocusEvent);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FReply <span class="title">SButton::OnKeyDown</span><span class="params">( <span class="keyword">const</span> FGeometry&amp; MyGeometry, <span class="keyword">const</span> FKeyEvent&amp; InKeyEvent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FReply Reply = FReply::<span class="built_in">Unhandled</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsEnabled</span>() &amp;&amp; FSlateApplication::<span class="built_in">Get</span>().<span class="built_in">GetNavigationActionFromKey</span>(InKeyEvent) == EUINavigationAction::Accept)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Press</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (PressMethod == EButtonPressMethod::ButtonPress)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//execute our &quot;OnClicked&quot; delegate, and get the reply</span></span><br><span class="line">			Reply = <span class="built_in">ExecuteOnClick</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//You should ALWAYS handle the OnClicked event.</span></span><br><span class="line">			<span class="built_in">ensure</span>(Reply.<span class="built_in">IsEventHandled</span>() == <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Reply = FReply::<span class="built_in">Handled</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Reply = SBorder::<span class="built_in">OnKeyDown</span>(MyGeometry, InKeyEvent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return the constructed reply</span></span><br><span class="line">	<span class="keyword">return</span> Reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FReply <span class="title">SButton::OnMouseButtonDoubleClick</span><span class="params">( <span class="keyword">const</span> FGeometry&amp; InMyGeometry, <span class="keyword">const</span> FPointerEvent&amp; InMouseEvent )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">OnMouseButtonDown</span>( InMyGeometry, InMouseEvent );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// .........</span></span><br></pre></td></tr></table></figure><p></p><p>函数实现都比较简单，没什么可以展开的。</p><p>这就能在蓝图的 UMG 里面用了吗？答案是：不行！我们还需要把 &quot;SButton&quot; 做成 &quot;UObject&quot; 的形式 (也就是 &quot;UButton&quot;)，让 GC 替我们管理 Widget 的释放。我们也可以利用 &quot;UWidget&quot; 这一层实现更多有趣的 &quot;高达零件&quot; 来提供给蓝图用。我们下面就来实现一个支持红点提醒的 &quot;UMyButton&quot; 😃</p><hr><h2 id="从-swidget-到-uwidget"><a class="anchor" href="#从-swidget-到-uwidget">#</a> 从 SWidget 到 UWidget</h2><p>UWidget 类比 SWidget 类理解起来会简单不少。所以咱直接上代码了。</p><p></p><figure class="highlight c++"><figcaption><span>MyButton.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyButton.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HELLOSLATE_API</span> <span class="title">UMyButton</span> :</span> <span class="keyword">public</span> UButton</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ActiveRedPoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ToggleRedPoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InActiveRedPoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsRedPointActive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HasNewNotify;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ReleaseSlateResources</span><span class="params">(<span class="keyword">bool</span> bReleaseChildren)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">/** Handle the actual click event from slate and forward it on */</span></span><br><span class="line">	<span class="function">FReply <span class="title">SlateHandleClicked</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//~ Begin UWidget Interface</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> TSharedRef&lt;SWidget&gt; <span class="title">RebuildWidget</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">bool</span> HasNewNotify;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = Appearance)</span><br><span class="line">	FSlateBrush RedPointImage;</span><br><span class="line"></span><br><span class="line">	TSharedPtr&lt;SOverlay&gt; MyOverlay;</span><br><span class="line"></span><br><span class="line">	TSharedPtr&lt;SImage&gt; RedPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们直接继承 &quot;UButton&quot;，因为我们是要在保存 UButton 的所有功能下，拓展红点提醒功能。没有必要把 “UButton&quot;重新实现一遍。要加红点提醒，那我们就要给 Button 添加一个 Image，然后把原来的 UButton 和 Image 放到一起，然后再实现一些方法来控制我们的红点是否显示，最后再实现基类必须要我们实现的接口类，比如&quot;ReleaseSlateResources&quot;(释放 Slate 资源，我们另外加了&quot;MyOverlay&quot;和&quot;RedPoint&quot;，这些都需要我们自己加到这个方法里面来释放掉)</p><p>下面是源文件的实现：</p><p></p><figure class="highlight c++"><figcaption><span>UMyButton.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyButton.cpp</span></span><br><span class="line"></span><br><span class="line">UMyButton::<span class="built_in">UMyButton</span>(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">	HasNewNotify = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyButton::ActiveRedPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HasNewNotify = <span class="literal">true</span>;</span><br><span class="line">	RedPoint-&gt;<span class="built_in">SetVisibility</span>(EVisibility::Visible);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyButton::ToggleRedPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HasNewNotify = !HasNewNotify;</span><br><span class="line">	<span class="keyword">if</span> (HasNewNotify)</span><br><span class="line">	&#123;</span><br><span class="line">		RedPoint-&gt;<span class="built_in">SetVisibility</span>(EVisibility::Visible);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		RedPoint-&gt;<span class="built_in">SetVisibility</span>(EVisibility::Hidden);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyButton::InActiveRedPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HasNewNotify = <span class="literal">false</span>;</span><br><span class="line">	RedPoint-&gt;<span class="built_in">SetVisibility</span>(EVisibility::Hidden);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FReply <span class="title">UMyButton::SlateHandleClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">InActiveRedPoint</span>();</span><br><span class="line"></span><br><span class="line">	OnClicked.<span class="built_in">Broadcast</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FReply::<span class="built_in">Handled</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyButton::ReleaseSlateResources</span><span class="params">(<span class="keyword">bool</span> bReleaseChildren)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">ReleaseSlateResources</span>(bReleaseChildren);</span><br><span class="line"></span><br><span class="line">	MyOverlay.<span class="built_in">Reset</span>();</span><br><span class="line">	RedPoint.<span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TSharedRef&lt;SWidget&gt; <span class="title">UMyButton::RebuildWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">RebuildWidget</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SAssignNew</span>(RedPoint, SImage)</span><br><span class="line">		.<span class="built_in">Image</span>(&amp;RedPointImage);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	MyOverlay = <span class="built_in">SNew</span>(SOverlay)</span><br><span class="line">		+ SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">		[</span><br><span class="line">			MyButton.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">		]</span><br><span class="line">		+SOverlay::<span class="built_in">Slot</span>()</span><br><span class="line">		.<span class="built_in">HAlign</span>(HAlign_Right)</span><br><span class="line">		.<span class="built_in">VAlign</span>(VAlign_Top)</span><br><span class="line">		[</span><br><span class="line">			RedPoint.<span class="built_in">ToSharedRef</span>()</span><br><span class="line">		];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MyOverlay.<span class="built_in">ToSharedRef</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>RebuildWidget</code> 是我们构造 UWidget 的方法，跟 SWidget 的 <code>Construct</code> 方法类似。我们需要先把 &quot;MyButton&quot;(UButton 基类里面的) 给构造好，然后再自己构造一个 &quot;SImage&quot; 来存放红点。最后把这两个给 SWidget 添加到 MyOverlay 里面，并返回去即可。&quot;ReleaseSlateResources&quot; 方法则需要把我们另外加的两个 SWidget 给加进去就完成了。</p><p>以上代码中创建的红点按钮虽然可以正常使用，但其实还只是雏形，我们可以实现更多基类的接口函数以获得更细致的处理。这里我们就不再展开了。那么..... 最后总结一下，准备结束本次旅程啦～～～</p><p>本篇总结：</p><ul><li>介绍了 &quot;Widget Reflector&quot; (Widget 反射器) 的用法，并用其追踪了 &quot;SDetailsView&quot; 的组成</li><li>通过研究 &quot;SDetailsView&quot; 的源码，我们分析了定义 &quot;FArgument&quot; 结构体的几个宏代码</li><li>分析了 &quot;SDetailsView&quot; 的 &quot;Construct&quot; 函数，主要就是用 &quot;FArgument&quot; 初始化对象属性，用 &quot;SNew&quot; 拼高达。</li><li>分析了 &quot;SNew&quot; 宏，'+'，'[]' 运算符重载的源码以及为什么要这么做的原因</li><li>分析了 &quot;SDetailsView&quot; 中细节树 (装载属性项的容器) 构建的过程</li><li>为了弄明白细节树中每一个属性项的生成过程，我们详细分析了 &quot;STreeView&quot; 的 &quot;Tick&quot; 函数，&quot;ReGenerateItems&quot; 函数，&quot;GeneratedWidgetForItem&quot; 函数，作用分别如下：<ul><li>&quot;Tick&quot; 计算滚动偏移，确定开始生成的第一项的位置，并调用 &quot;ReGenerateItems&quot; 来重新生成每一项 (还有滚动条的更新等等)</li><li>&quot;ReGenerateItems&quot; 调用 &quot;GenerateWidgetForItem&quot; 来生成 Widget，并把每个 Widget 可显示的部分显示出来，还做了过度滑动的回退处理</li><li>&quot;GeneratedWidgetForItem&quot; 用具体的 Item 来生成一个 Widget，并缓存一起来，如果下次需要生成相同的 Widget，则直接返回即可</li></ul></li><li>继续深入分析了每一项的具体生成代码 &quot;OnGenerateRaw&quot;，主要就是生成一个 名字 Widget 和 值 Widget，如果值 Widget 可以展开，这还需要加载展开的部分 (如：Transform)</li><li>介绍了 &quot;Slate&quot; 系统的基本框架，分析了 &quot;SButton&quot; 的基本实现思路</li><li>分析了 &quot;SWidget&quot; 的 &quot;Construct&quot; , &quot;OnPaint&quot; 等函数的实现</li><li>最后我们实现了一个支持红点提醒的 &quot;UMyButton&quot;，分别说明了 &quot;SWidget&quot; 和 &quot;UWidget&quot; 的作用，比较了 &quot;SWidget&quot; 和 &quot;UWidget&quot; 在实现上的区别。</li></ul><p>结语：u1s1，本篇博客其实只是分析了 Slate 源码中非常基础的一部分，我们也都知道，虚幻编辑器的整个界面包括所有工具化的窗口，其实都是用 &quot;UMG&quot; 系统搭建出来的。&quot;UMG&quot; 的坑，深不见底。我们不可能也没有必要把所有 Slate 类都弄明白，但是我起码得搞清楚 Slate 语法的底层实现，也要具备自己实现 Slate 类的能力，也算是给插件开发打下一个比较好的基础吧。</p><p>那么，本次旅程到此结束。咱们插件开发篇见。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-12-01 09:20:47" itemprop="dateModified" datetime="2021-12-01T09:20:47+08:00">2021-12-01</time> </span><span id="2021/11/26/UE4/UE4CPP/Unreal Slate/" class="item leancloud_visitors" data-flag-title="Unreal Slate" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" title="Unreal Slate">https://kotori_suki.github.io/2021/11/26/UE4/UE4CPP/Unreal Slate/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclj9410cj20zk0m8h12.jpg" title="Unreal 多种指针实现原理"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal 多种指针实现原理</h3></a></div><div class="item right"><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeuibk9fj20zk0m8ay2.jpg" title="Gameplay —— 总览 &amp; UEngine &amp; UGameInstance"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Gameplay</span><h3>Gameplay —— 总览 & UEngine & UGameInstance</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unreal-slate"><span class="toc-number">1.</span> <span class="toc-text">Unreal Slate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-widget-reflector-%E5%BC%80%E5%A7%8B"><span class="toc-number">1.1.</span> <span class="toc-text">从 Widget Reflector 开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#details-view-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Details View 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#snew"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">SNew</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#operator"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">operator +</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#operator-2"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">operator []</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#soverlayslot"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">SOverlay::Slot()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">运算符小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BAa-id-%E7%BB%86%E8%8A%82%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA-a"><span class="toc-number">1.2.2.</span> <span class="toc-text">细节树的构建 &lt;a id &#x3D; &quot;细节树的构建&quot;&gt; &lt;&#x2F;a&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constructtreeview"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">ConstructTreeView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sdetailtreeconstruct"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">SDetailTree::Construct</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tick-%E5%88%B7%E6%96%B0%E8%8A%82%E7%82%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">Tick 刷新节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%B1%9E%E6%80%A7%E9%A1%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">生成属性项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#regenerateitems"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">ReGenerateItems</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#generatedwidgetforitem"><span class="toc-number">1.2.5.</span> <span class="toc-text">GeneratedWidgetForItem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ongenerateraw"><span class="toc-number">1.2.6.</span> <span class="toc-text">OnGenerateRaw</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slate-%E7%9A%84%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.</span> <span class="toc-text">Slate 的整体实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%B8%B8%E8%AF%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">前置知识 (常识)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-slate-%E7%B1%BB%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">实现 Slate 类的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-fargument-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">定义 FArgument 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-construct-%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">定义 Construct 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onpaint"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">OnPaint</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-swidget-%E5%88%B0-uwidget"><span class="toc-number">1.4.</span> <span class="toc-text">从 SWidget 到 UWidget</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li><li class="active"><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" rel="bookmark" title="Unreal Slate">Unreal Slate</a></li><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li><li><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></li><li><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="bookmark" title="Custom Item Module">Custom Item Module</a></li><li><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></li><li><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">54</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 操作系统">操作系统</a></div><span><a href="/2021/08/17/ComputerBase/OperatingSystem/32%E4%BD%8D64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E3%80%81%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" title="32位64位系统、字节对齐">32位64位系统、字节对齐</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/Gameplay/" title="分类于 Gameplay">Gameplay</a></div><span><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" title="Gameplay —— 总览 &amp; UEngine &amp; UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A6%82%E8%BF%B0/" title="分类于 概述">概述</a></div><span><a href="/2021/08/16/CPPBase/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%20&%20%E6%A6%82%E8%BF%B0/" title="设计模式六大原则 &amp; 概述">设计模式六大原则 & 概述</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" title="UE4代理的实现与用法">UE4代理的实现与用法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" title="Unreal 序列化~~~">Unreal 序列化~~~</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/Gameplay/" title="分类于 Gameplay">Gameplay</a></div><span><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" title="Gameplay —— APawn &amp; AController &amp; APlayerController">Gameplay —— APawn & AController & APlayerController</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/21/CPPBase/DesignPattern/State/" title="状态模式">状态模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/21/CPPBase/DesignPattern/Decorater/" title="装饰器模式">装饰器模式</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/11/26/UE4/UE4CPP/Unreal Slate/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>