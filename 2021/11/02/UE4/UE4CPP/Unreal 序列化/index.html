<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/"><title>Unreal 序列化~~~ - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unreal 序列化~~~</h1><div class="meta"><span class="item" title="创建时间：2021-11-02 12:32:10"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-11-02T12:32:10+08:00">2021-11-02</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="unreal-序列化~~~"><a class="anchor" href="#unreal-序列化~~~">#</a> Unreal 序列化～～～</h1><p>简介：来跟着我走一遍 unreal 序列化的流程吧～～～</p><h2 id="从savegametoslot出发"><a class="anchor" href="#从savegametoslot出发">#</a> 从 SaveGameToSlot 出发</h2><p>SaveGameToSlot 可以说是我们最熟悉的，也最常用的，对 UObject 进行序列化，并将其写入磁盘的 API 了。话不多说，咱们开始吧（有点导游的感觉了 😃</p><h5 id="savegametoslot"><a class="anchor" href="#savegametoslot">#</a> SaveGameToSlot</h5><p><img data-src="SaveGameToSlot.png" alt="SaveGameToSlot"></p><p>SaveGameToSlot 里面有两个函数，都极其重要！</p><ul><li>SaveGameToMemory 负责把咱的 SaveGameObject 给序列化到咱的 ObjectBytes 里面，ObjectBytes 是一个字节型的数组。</li><li>SaveDataToSlot 则负责把刚刚的序列化好的数组给存到磁盘里面。</li><li>这里补充一个常识，在 unreal 中，如果要往磁盘里写入数据（或者读取数据），那就必须把数据处理为 uint8 类型。而这个处理的过程正是咱说得序列化。序列化后的数据写入磁盘只需要调用不同硬件平台提供的 API 即可。这些过程都会在下文做详细解析，暂时只需要了解即可。</li></ul><p>好的，接下来看看 SaveGameToMemory 和 SaveDataToSlot 到底都干了什么吧</p><h5 id="savegametomemory"><a class="anchor" href="#savegametomemory">#</a> SaveGameToMemory</h5><p><img data-src="SaveGameToMemory.png" alt="SaveGameToMemory"></p><ul><li><p>首先要咱要确认一下这个 &quot;SaveGameObject&quot; 是不是存在，不存在咱就直接跑路，嘿嘿</p></li><li><p>这里需要补充一点，unreal 里面的序列化都由 &quot;FArchive&quot; 类来完成，里面提供了各种数据类型的序列化的虚方法。我们这里的 &quot;FMemoryWriter&quot; 实际上就是 &quot;FArchive&quot; 的子类，&quot;FArchive&quot; 是所有 &quot;archives&quot; 的基类，具体解析留到后面</p></li><li><p>继续，如果 SaveGameObject 存在，那咱就先整一个 &quot;FMemoryWriter&quot;，这个类是的作用是 把数据存到指定内存中。指定内存 在这里是 &quot;OutSaveData&quot;，初始化的时候要传进来。</p></li><li><p>然后再整个 &quot;FSaveGameHeader&quot;，这是个结构体，主要负责往 &quot;MemoryWriter&quot; 里面序列化一些版本信息，当然还有 &quot;Read&quot; 方法，负责读 &quot;MemoryReader&quot; 的版本信息。这些版本信息的来源，正是初始化时传入的 SaveGameObject。</p></li><li><p>最后我们要用刚刚处理好的 &quot;MemoryWriter&quot; 来序列化咱的 SaveGameObject，出于各种原因，unreal 里面用于序列化的 &quot;Archive&quot; 其实是 &quot;ArchiveProxy&quot; 而不是直接用 &quot;Archive&quot; 的子类 (虽然 ArchiveProxy 也继承自 &quot;Archive&quot;)，因为代理类能添加一些额外的处理的同时，还能避免对 Archive 的直接访问。</p></li><li><p>所以，咱要先整一个 &quot;FObjectAndNameAsStringProxyArchive&quot; 对象，这个对象将用于 SaveGameObject 的序列化。最后调用 &quot;Serialize&quot; 完成序列化。</p><hr><h4 id="序列化过程-真的很长很长"><a class="anchor" href="#序列化过程-真的很长很长">#</a> 序列化过程 (真的很长很长......)</h4><p>其实也就是 &quot;SaveGameObject-&gt;Serialize (Ar)&quot; 方法的执行过程，先看看都做了什么吧</p><h5 id="objectserialize"><a class="anchor" href="#objectserialize">#</a> Object.Serialize</h5><p></p><figure class="highlight c++"><figcaption><span>Object.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Handles reading, writing, and reference collecting using FArchive.</span></span><br><span class="line"><span class="comment"> * This implementation handles all FProperty serialization, but can be overridden for native variables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(FArchive&amp; Ar)</span></span>;		<span class="comment">// 我们调用的是这条，下面是该函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(FStructuredArchive::FRecord Record)</span></span>;	<span class="comment">//这条等等也要用到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight c++"><figcaption><span>UObject.Serialize(FArchive& Ar)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IMPLEMENT_FARCHIVE_SERIALIZER</span>(UObject) 			<span class="comment">// &quot;Obj.cpp&quot; 中的函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_FARCHIVE_SERIALIZER( TClass ) void TClass::Serialize(FArchive&amp; Ar) &#123; TClass::Serialize(FStructuredArchiveFromArchive(Ar).GetSlot().EnterRecord()); &#125;			<span class="comment">// &quot;ObjectMacro.h&quot; 中的宏</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">展开后，</span></span><br><span class="line"><span class="comment">UObject::Serialize(FArchive&amp; Ar) == UObject::Serialize(FStructuredArchiveFromArchive(Ar).GetSlot().EnterRecord())</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p><code>Serialize(FArchive&amp; Ar)</code> 在 obj.cpp 里面是以宏的方式定义的，展开之后是下面这条：</p><p><code>UObject::Serialize(FStructuredArchiveFromArchive(Ar).GetSlot().EnterRecord())</code></p><p>那咱先从参数入手，以下会对几个类进行解析，可以<a href="#%E5%BC%80%E5%A7%8B%E5%AF%BB%E6%89%BE%E5%8F%82%E6%95%B0">跳过</a>，但不建议 😃</p><h5 id="fstructuredarchivefromarchive"><a class="anchor" href="#fstructuredarchivefromarchive">#</a> FStructuredArchiveFromArchive</h5><p></p><figure class="highlight c++"><figcaption><span>StructuredArchiveFromArchive.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StructuredArchiveFromArchive.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORE_API</span> <span class="title">FStructuredArchiveFromArchive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">UE_NONCOPYABLE</span>(FStructuredArchiveFromArchive)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> uint32 ImplSize      = <span class="number">400</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> uint32 ImplAlignment = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FImpl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">FStructuredArchiveFromArchive</span><span class="params">(FArchive&amp; Ar)</span></span>;</span><br><span class="line">	~<span class="built_in">FStructuredArchiveFromArchive</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">FStructuredArchiveSlot <span class="title">GetSlot</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// Implmented as a pimpl in order to reduce dependencies, but an inline one to avoid heap allocations</span></span><br><span class="line">	<span class="built_in"><span class="keyword">alignas</span></span>(ImplAlignment) uint8 ImplStorage[ImplSize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p></p><figure class="highlight c++"><figcaption><span>StructuredArchiveFromArchive.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StructuredArchiveFromArchive.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FStructuredArchiveFromArchive</span>:</span>:FImpl</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">FImpl</span><span class="params">(FArchive&amp; Ar)</span></span></span><br><span class="line"><span class="function">		: Formatter(Ar)</span></span><br><span class="line"><span class="function">		, StructuredArchive(Formatter)</span></span><br><span class="line"><span class="function">		, Slot(StructuredArchive.Open())</span></span><br><span class="line"><span class="function">	&#123;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FBinaryArchiveFormatter Formatter;</span><br><span class="line">	FStructuredArchive StructuredArchive;</span><br><span class="line">	FStructuredArchive::FSlot Slot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FStructuredArchiveFromArchive::<span class="built_in">FStructuredArchiveFromArchive</span>(FArchive&amp; Ar)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">new</span> (ImplStorage) <span class="built_in">FImpl</span>(Ar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FStructuredArchiveFromArchive::~<span class="built_in">FStructuredArchiveFromArchive</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DestructItem</span>((FImpl*)ImplStorage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FStructuredArchive::FSlot <span class="title">FStructuredArchiveFromArchive::GetSlot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((FImpl*)ImplStorage)-&gt;Slot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;FStructuredArchiveFromArchive&quot; 是帮助 &quot;FArchive&quot; 成为 &quot;FStructuredArchive&quot; 的一个类，其成员就只有一个结构体 &quot;FImpl&quot;，和一个获取结构体的里的 &quot;Slot&quot; 的函数，构造函数就是在初始化这个结构体。<strong>重点在这个结构体里面的三个类</strong>，以下是对这三个类的解析 😃</p><h5 id="fstructuredarchiveformatter"><a class="anchor" href="#fstructuredarchiveformatter">#</a> &quot;FStructuredArchiveFormatter&quot;</h5><p>&quot;FBinaryArchiveFormatter&quot; ，二进制格式输入存档程序，其基类是 &quot;FStructuredArchiveFormatter&quot;，一个用于 把各种格式化数据读 / 写到 archive 的接口，里面定义了对字段、数组等格式的数据的各种栈操作，及其序列化，该接口的子类暂时只有三个：</p><ol><li>&quot;FBinaryArchiveFormatter&quot; // 二进制格式输入存档程序，直接序列化</li><li>&quot;FJsonArchiveInputFormatter&quot; // Json 格式输入存档程序，读 Json 文件的</li><li>&quot;FJsonArchiveOutputFormatter&quot; // Json 格式输出存档程序，写 Json 文件的</li></ol><h5 id="fstructuredarchive"><a class="anchor" href="#fstructuredarchive">#</a> &quot;FStructuredArchive&quot;</h5><p>&quot;FStructuredArchive&quot; 用于管理 &quot;FStructuredArchiveFormatter&quot;，并提供一些读写 StructuredArchive 的 API（流程是 先 Open，会获得一个 Slot，然后往 Slot 的 Formatter 里面序列化想要的数据，最后 Close，当然如果是其他数据类型的话，就要 Enter 相应的类型，再序列化，比如 &quot;EnterArray&quot; ）</p><p></p><figure class="highlight c++"><figcaption><span>FStructuredArchive</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FStructuredArchive.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">FStructuredArchiveSlot <span class="title">FStructuredArchive::Open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RootElementId = ElementIdGenerator.<span class="built_in">Generate</span>();</span><br><span class="line">	CurrentScope.<span class="built_in">Emplace</span>(RootElementId, UE4StructuredArchive_Private::EElementType::Root);</span><br><span class="line"></span><br><span class="line">	CurrentSlotElementId = ElementIdGenerator.<span class="built_in">Generate</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FStructuredArchiveSlot</span>(*<span class="keyword">this</span>, <span class="number">0</span>, CurrentSlotElementId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FStructuredArchiveSlot.h</span></span><br><span class="line"></span><br><span class="line"><span class="function">FStructuredArchiveRecord <span class="title">EnterRecord</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FStructuredArchiveRecord</span>(Ar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FStructuredArchiveArray <span class="title">EnterArray</span><span class="params">(int32&amp; Num)</span></span>;</span><br><span class="line"><span class="function">FStructuredArchiveStream <span class="title">EnterStream</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">FStructuredArchiveMap <span class="title">EnterMap</span><span class="params">(int32&amp; Num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don&#x27;t support chaining writes to a single slot, so this returns void.</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (uint32&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (int32&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (<span class="keyword">bool</span>&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (FString&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (FName&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (UObject*&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (FText&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (FWeakObjectPtr&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (FSoftObjectPtr&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (FSoftObjectPath&amp; Value);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (FLazyObjectPtr&amp; Value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FStructuredArchiveRecord.cpp 自定义类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; FORCEINLINE FStructuredArchiveRecord&amp; <span class="keyword">operator</span>&lt;&lt;(TNamedValue&lt;T&gt; Item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">EnterField</span>(Item.Name) &lt;&lt; Item.Value;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FStructuredArchive.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FStructuredArchive::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历退出Formatter中的所有栈操作，并退出Slot操作</span></span><br><span class="line">	<span class="built_in">SetScope</span>(UE4StructuredArchive_Private::<span class="built_in">FSlotPosition</span>(<span class="number">0</span>, RootElementId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><h5 id="fstructuredarchivefslot"><a class="anchor" href="#fstructuredarchivefslot">#</a> &quot;FStructuredArchive::FSlot&quot;</h5><p>&quot;FStructuredArchive::FSlot&quot; -&gt; FStructuredArchiveSlot，可以说是 &quot;FStructuredArchive&quot; 的附属类，其声明和使用都必须建立在 &quot;FStructuredArchive&quot; 类上。定义在上面的代码里，其实就是一个序列化数据的总槽。</p><h5 id="开始寻找参数a-id开始寻找参数a"><a class="anchor" href="#开始寻找参数a-id开始寻找参数a">#</a> 开始寻找参数 &lt;a id=&quot;开始寻找参数&quot;&gt;&lt;/a&gt;</h5><p></p><figure class="highlight c++"><figcaption><span>FindParam</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FStructuredArchiveFromArchive(Ar).GetSlot().EnterRecord()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取咱刚刚初始化好的FImpl结构体中的Slot，需要注意的是，这里的 &quot;Slot&quot; 中的 &quot;Ar&quot; 实际上的我们刚刚的代理Archive &quot;FObjectAndNameAsStringProxyArchive&quot;</span></span><br><span class="line"><span class="function">FStructuredArchiveSlot <span class="title">FStructuredArchiveFromArchive::GetSlot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((FImpl*)ImplStorage)-&gt;Slot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为UObject序列化要的是Record，所以这里EnterRecord来获取</span></span><br><span class="line"><span class="function">FStructuredArchiveRecord <span class="title">FStructuredArchiveSlot::EnterRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int32 NewDepth = Ar.<span class="built_in">EnterSlotAsType</span>(*<span class="keyword">this</span>, UE4StructuredArchive_Private::EElementType::Record);</span><br><span class="line"></span><br><span class="line">	Ar.Formatter.<span class="built_in">EnterRecord</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是我们最后想要的 &quot;FStructuredArchiveRecord&quot;，&quot;Record&quot; 中的 &quot;Ar&quot; 也是Object的代理Archive </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FStructuredArchiveRecord</span>(Ar, NewDepth, ElementId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>参数解析完，该回到 &quot;Object::Serialize&quot; 函数的解析了</p><h5 id="uobjectserializefstructuredarchivefrecord-record"><a class="anchor" href="#uobjectserializefstructuredarchivefrecord-record">#</a> <code>UObject::Serialize(FStructuredArchive::FRecord Record)</code></h5><p></p><figure class="highlight c++"><figcaption><span>UObject::Serialize(Record)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObject::Serialize(FStructuredArchive::FRecord Record)</span></span><br><span class="line"></span><br><span class="line">UObject::<span class="built_in">Serialize</span>(FStructuredArchive::FRecord Record)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 也就是SaveGameToMemory中生成的 &quot;FObjectAndNameAsStringProxyArchive&quot;，以下简称 &quot;Ar&quot;</span></span><br><span class="line">    FArchive&amp; UnderlyingArchive = Record.<span class="built_in">GetUnderlyingArchive</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面的变量仅帮助序列化，但不会被序列化</span></span><br><span class="line">	UClass *ObjClass = <span class="built_in">GetClass</span>();</span><br><span class="line">	UObject* LoadOuter = <span class="built_in">GetOuter</span>();</span><br><span class="line">	FName LoadName = <span class="built_in">GetFName</span>();</span><br><span class="line">	UPackage* LoadPackage = <span class="built_in">GetExternalPackage</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保这个object的class的数据已经被加载</span></span><br><span class="line">    <span class="keyword">if</span>(ObjClass-&gt;<span class="built_in">HasAnyFlags</span>(RF_NeedLoad) )</span><br><span class="line">    &#123;</span><br><span class="line">        UnderlyingArchive.<span class="built_in">Preload</span>(ObjClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject) &amp;&amp; ObjClass-&gt;<span class="built_in">GetDefaultsCount</span>() &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            UnderlyingArchive.<span class="built_in">Preload</span>(ObjClass-&gt;<span class="built_in">GetDefaultObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个 &quot;Ar&quot; 既没有在读取，也没有在写入，也不是只处理UObject，那就让 &quot;Ar&quot; 序列化一些额外的信息，加载时用的</span></span><br><span class="line">    <span class="keyword">if</span> ((!UnderlyingArchive.<span class="built_in">IsLoading</span>() &amp;&amp; !UnderlyingArchive.<span class="built_in">IsSaving</span>() &amp;&amp; !UnderlyingArchive.<span class="built_in">IsObjectReferenceCollector</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 让 &quot;Record&quot; 序列化一个 &quot;TNamedValue&quot;，里面存着 &quot;LoadName&quot;，下面也一样</span></span><br><span class="line">        Record &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadName&quot;</span>), LoadName);</span><br><span class="line">        <span class="keyword">if</span> (!UnderlyingArchive.<span class="built_in">IsIgnoringOuterRef</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Record &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadOuter&quot;</span>), LoadOuter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!UnderlyingArchive.<span class="built_in">IsIgnoringClassRef</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Record &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;ObjClass&quot;</span>), ObjClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 &quot;Ar&quot; Is Transacting (支持对象更改跟踪)，比如支持撤销系统，则让 &quot;Ar&quot; 加载额外信息</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (UnderlyingArchive.<span class="built_in">IsTransacting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &quot;Ar&quot; 是否忽略UObject的外部引用</span></span><br><span class="line">        <span class="keyword">if</span> (!UnderlyingArchive.<span class="built_in">IsIgnoringOuterRef</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (UnderlyingArchive.<span class="built_in">IsLoading</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                Record &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadName&quot;</span>), LoadName) &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadOuter&quot;</span>), LoadOuter) &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadPackage&quot;</span>), LoadPackage);</span><br><span class="line"></span><br><span class="line">             	<span class="comment">// 如果读取到的名字跟之前的不一样，对unhash这个object，改名后hash回来。</span></span><br><span class="line">                <span class="keyword">bool</span> bDifferentName = <span class="built_in">GetFName</span>() != NAME_None &amp;&amp; LoadName != <span class="built_in">GetFName</span>();</span><br><span class="line">                <span class="keyword">bool</span> bDifferentOuter = LoadOuter != <span class="built_in">GetOuter</span>();</span><br><span class="line">                <span class="keyword">if</span> ( bDifferentName == <span class="literal">true</span> || bDifferentOuter == <span class="literal">true</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 找到同名的UObject</span></span><br><span class="line">                    UObject* Collision = <span class="built_in">StaticFindObjectFast</span>(UObject::<span class="built_in">StaticClass</span>(), LoadOuter, LoadName);</span><br><span class="line">                    <span class="comment">// 存在Collision，且Collision不是咱的SaveGameObject</span></span><br><span class="line">                    <span class="keyword">if</span>(Collision &amp;&amp; Collision != <span class="keyword">this</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 返回一个唯一的FName</span></span><br><span class="line">                        FName NewNameForCollision = <span class="built_in">MakeUniqueObjectName</span>(LoadOuter, Collision-&gt;<span class="built_in">GetClass</span>(), LoadName);</span><br><span class="line">                        <span class="comment">// check 这个name是否被其他的Object占用</span></span><br><span class="line">                        <span class="built_in">checkf</span>( <span class="built_in">StaticFindObjectFast</span>(UObject::<span class="built_in">StaticClass</span>(), LoadOuter, NewNameForCollision) == <span class="literal">nullptr</span>,</span><br><span class="line">                               <span class="built_in">TEXT</span>(<span class="string">&quot;Failed to MakeUniqueObjectName for object colliding with transaction buffer state: %s %s&quot;</span>),</span><br><span class="line">                               *LoadName.<span class="built_in">ToString</span>(),</span><br><span class="line">                               *NewNameForCollision.<span class="built_in">ToString</span>()</span><br><span class="line">                              );</span><br><span class="line">                        <span class="comment">// 重命名Collision对象</span></span><br><span class="line">                        Collision-&gt;<span class="built_in">LowLevelRename</span>(NewNameForCollision,LoadOuter);</span><br><span class="line">                        <span class="meta">#<span class="meta-keyword">if</span> DO_CHECK</span></span><br><span class="line">                        UObject* SubsequentCollision = <span class="built_in">StaticFindObjectFast</span>(UObject::<span class="built_in">StaticClass</span>(), LoadOuter, LoadName);</span><br><span class="line">                        <span class="built_in">checkf</span>( SubsequentCollision == <span class="literal">nullptr</span>,</span><br><span class="line">                               <span class="built_in">TEXT</span>(<span class="string">&quot;Multiple name collisions detected in the transaction buffer: %x %x with name %s&quot;</span>),</span><br><span class="line">                               Collision,</span><br><span class="line">                               SubsequentCollision,</span><br><span class="line">                               *LoadName.<span class="built_in">ToString</span>()</span><br><span class="line">                              );</span><br><span class="line">                        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">LowLevelRename</span>(LoadName,LoadOuter);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">SetExternalPackage</span>(LoadPackage);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Record &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadName&quot;</span>), LoadName) &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadOuter&quot;</span>), LoadOuter) &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;LoadPackage&quot;</span>), LoadPackage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化类中的属性</span></span><br><span class="line">    <span class="comment">// UClass对象时本地的，不应该被序列化</span></span><br><span class="line">    <span class="keyword">if</span> (ObjClass != UClass::<span class="built_in">StaticClass</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SerializeScriptProperties</span>(Record.<span class="built_in">EnterField</span>(<span class="built_in">SA_FIELD_NAME</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Properties&quot;</span>))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留对 &quot;pending kill&quot; 的记录 (pending kill -&gt; 对象即将被销毁的标记)</span></span><br><span class="line">    <span class="keyword">if</span> (UnderlyingArchive.<span class="built_in">IsTransacting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> WasKill = <span class="built_in">IsPendingKill</span>();</span><br><span class="line">        <span class="keyword">if</span> (UnderlyingArchive.<span class="built_in">IsLoading</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Record &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;WasKill&quot;</span>), WasKill);</span><br><span class="line">            <span class="keyword">if</span> (WasKill)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">MarkPendingKill</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ClearPendingKill</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (UnderlyingArchive.<span class="built_in">IsSaving</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Record &lt;&lt; <span class="built_in">SA_VALUE</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;WasKill&quot;</span>), WasKill);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个对象有GUID，则序列化其GUID</span></span><br><span class="line">    FLazyObjectPtr::<span class="built_in">PossiblySerializeObjectGuid</span>(<span class="keyword">this</span>, Record);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载新对象时，使资源指针缓存无效化</span></span><br><span class="line">    <span class="keyword">if</span> (UnderlyingArchive.<span class="built_in">IsLoading</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &quot;InvalidateTag&quot; 是通过一个全局计数器来实现的，每次调用自增1，当这个线程安全计数器回到1时，恢复资源指针的使用，并重新搜索路径</span></span><br><span class="line">        FSoftObjectPath::<span class="built_in">InvalidateTag</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内存</span></span><br><span class="line">    SIZE_T Size = <span class="built_in">GetClass</span>()-&gt;<span class="built_in">GetStructureSize</span>();</span><br><span class="line">    UnderlyingArchive.<span class="built_in">CountBytes</span>(Size, Size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>UObject 的序列化到这里就基本结束了，但其实 <code>SerializeScriptProperties()</code> 函数还是值得我们深入探究的，因为和 UObject 不一样，这是 ScriptProperties 的序列化</p><h5 id="serializescriptproperties"><a class="anchor" href="#serializescriptproperties">#</a> SerializeScriptProperties</h5><p></p><figure class="highlight c++"><figcaption><span>SerializeScriptProperties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In obj.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UObject::SerializeScriptProperties</span><span class="params">( FStructuredArchive::FSlot Slot )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FArchive&amp; UnderlyingArchive = Slot.<span class="built_in">GetUnderlyingArchive</span>();</span><br><span class="line"></span><br><span class="line">	UnderlyingArchive.<span class="built_in">MarkScriptSerializationStart</span>(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject) )</span><br><span class="line">	&#123;</span><br><span class="line">		UnderlyingArchive.<span class="built_in">StartSerializingDefaults</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UClass *ObjClass = <span class="built_in">GetClass</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(UnderlyingArchive.<span class="built_in">IsTextFormat</span>() || ((UnderlyingArchive.<span class="built_in">IsLoading</span>() || UnderlyingArchive.<span class="built_in">IsSaving</span>()) &amp;&amp; !UnderlyingArchive.<span class="built_in">WantBinaryPropertySerialization</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 先从loader中加载原型，因为蓝图类和EventDrivenLoader调用GetArchetype()是会报错的</span></span><br><span class="line">		UObject* DiffObject = UnderlyingArchive.<span class="built_in">GetArchetypeFromLoader</span>(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (!DiffObject)</span><br><span class="line">		&#123;</span><br><span class="line">			DiffObject = <span class="built_in">GetArchetype</span>();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> bBreakSerializationRecursion = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 真正执行属性序列化的函数，会根据Slot来选择是否有VersionedTag的函数来序列化Properties</span></span><br><span class="line">		ObjClass-&gt;<span class="built_in">SerializeTaggedProperties</span>(Slot, (uint8*)<span class="keyword">this</span>, <span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject) ? ObjClass-&gt;<span class="built_in">GetSuperClass</span>() : ObjClass, (uint8*)DiffObject, bBreakSerializationRecursion ? <span class="keyword">this</span> : <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (UnderlyingArchive.<span class="built_in">GetPortFlags</span>() != <span class="number">0</span> &amp;&amp; !UnderlyingArchive.ArUseCustomPropertyList )</span><br><span class="line">	&#123;</span><br><span class="line">		UObject* DiffObject = UnderlyingArchive.<span class="built_in">GetArchetypeFromLoader</span>(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (!DiffObject)</span><br><span class="line">		&#123;</span><br><span class="line">			DiffObject = <span class="built_in">GetArchetype</span>();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正执行属性序列化的函数，序列化和类中的默认值不同的数据</span></span><br><span class="line">		ObjClass-&gt;<span class="built_in">SerializeBinEx</span>(Slot, <span class="keyword">const_cast</span>&lt;UObject *&gt;(<span class="keyword">this</span>), DiffObject, DiffObject ? DiffObject-&gt;<span class="built_in">GetClass</span>() : <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正执行属性序列化的函数，序列化类中的所有数据</span></span><br><span class="line">		ObjClass-&gt;<span class="built_in">SerializeBin</span>(Slot, <span class="keyword">const_cast</span>&lt;UObject *&gt;(<span class="keyword">this</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject))</span><br><span class="line">	&#123;</span><br><span class="line">		UnderlyingArchive.<span class="built_in">StopSerializingDefaults</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	UnderlyingArchive.<span class="built_in">MarkScriptSerializationEnd</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>SerializeTaggedProperties</code> ， <code>SerializeBinEx</code> ， <code>SerializeBin</code> 最后都会调用 <code>FProperty::SerializeItem(FStructureArchive::Slot Slot, Void* Value, void const* Defaults)</code> 虚函数来序列化 Value，不同 FProperty 的序列化需要处理的工作会有所不同，这里就不展开聊了。</p><p>不过还是应该贴一个 &quot;FBoolProperty&quot; 的 &quot;SerializeItem&quot; 供读者参考的 😃</p><p></p><figure class="highlight c++"><figcaption><span>FBoolProperty.SerializeItem</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In BoolProperty.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FBoolProperty::SerializeItem</span><span class="params">( FStructuredArchive::FSlot Slot, <span class="keyword">void</span>* Value, <span class="keyword">void</span> <span class="keyword">const</span>* Defaults )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">check</span>(FieldSize != <span class="number">0</span>);</span><br><span class="line">	uint8* ByteValue = (uint8*)Value + ByteOffset;</span><br><span class="line">	uint8 B = (*ByteValue &amp; FieldMask) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	Slot &lt;&lt; B;</span><br><span class="line">	*ByteValue = ((*ByteValue) &amp; ~FieldMask) | (B ? ByteMask : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>序列化算是聊完了，已经好长了... 但还有 &quot;SaveDataToSlot&quot; ，再努力一下 😃</p></li></ul><hr><h5 id="savedatatoslot"><a class="anchor" href="#savedatatoslot">#</a> SaveDataToSlot</h5><p><img data-src="SaveDataToSlot.png" alt="SaveDataToSlot"></p><ul><li><p>&quot;SaveDataToSlot&quot; 是用来把 序列化好的字节型 &quot;TArray&quot; 写到磁盘中的函数</p></li><li><p>&quot;ISaveGameSystem&quot; 里面提供了各种关于读写硬盘的操作，下面的 &quot;SaveGame&quot; 就是其中一种写操作，当然还有 DeleteGame 之类的</p></li><li><p>其实 &quot;ISaveGameSystem&quot; 并不是直接读写硬盘的类，因为实际上 &quot;SaveGame&quot; 里面还借助了 &quot;FFileHelper&quot; 这个结构体，并调用了其 &quot;SaveArrayToFile&quot; 函数，见下图</p><p><img data-src="SaveGame.png" alt="SaveGame"></p></li><li><p>SaveArrayToFile 里 Create 了一个 &quot;FArchive&quot;，并用这个 &quot;Ar&quot; 来序列化咱的 &quot;字节型数组&quot;，代码如下：</p><p><img data-src="SaveArrayToFile.png" alt="SaveArrayToFile"></p></li><li><p>然而刚刚 Create 的 &quot;FArchive&quot; 其实不是一般的 &quot;FArchive&quot;，从下面的代码中可以看出，这个 &quot;FArchive&quot; 的具体类是 &quot;FArchiveFileWriterGeneric&quot; 。没错，这才是真正往磁盘写数据的类。当然还有对应的 &quot;FArchiveFileReaderGeneric&quot; 来读取磁盘数据。</p><p><img data-src="CreateFileWriterInternal.png" alt="CreateFileWriterInternal"></p></li><li><p>很好，我们跳进了一个大坑。以下是对 &quot;FArchiveFileWriterGeneric&quot; 的具体解析， &quot;FArchiveFileReaderGeneric&quot; 留给感兴趣的读者自行探及（真的不是我偷懒 😃</p><h5 id="farchivefilewritergeneric"><a class="anchor" href="#farchivefilewritergeneric">#</a> FArchiveFileWriterGeneric</h5><p>下面是 &quot;FArchiveFileWriterGeneric&quot; 中的属性和函数的定义：</p><p></p><figure class="highlight c++"><figcaption><span>FArchiveFileWriterGeneric</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileManagerGeneric.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORE_API</span> <span class="title">FArchiveFileWriterGeneric</span> :</span> <span class="keyword">public</span> FArchive</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FArchiveFileWriterGeneric</span>( IFileHandle* InHandle, <span class="keyword">const</span> TCHAR* InFilename, int64 InPos, uint32 InBufferSize = PLATFORM_FILE_WRITER_BUFFER_SIZE, uint32 InFlags = FILEWRITE_None);</span><br><span class="line">	~<span class="built_in">FArchiveFileWriterGeneric</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到 &quot;InPos&quot; 对应的磁盘位置</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">( int64 InPos )</span> <span class="keyword">final</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> int64 <span class="title">Tell</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Pos;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> int64 <span class="title">TotalSize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Close</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往刚刚定位好的Pos中，写入Length长度的数据，数据内容是*V</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">( <span class="keyword">void</span>* V, int64 Length )</span> <span class="keyword">final</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加个文件句柄写入到磁盘</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Flush</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> FString <span class="title">GetArchiveName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Filename;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">   	 * 写入任何内部 buffer 到 &quot;file handle&quot; (文件句柄)中</span></span><br><span class="line"><span class="comment">   	 * @note 不会刷新句柄本身，因此这些数据可能被操作系统缓存，而尚未写入磁盘！</span></span><br><span class="line"><span class="comment">   	 * @return 写入成功返回真，buffer中没有数据或写入失败返回false</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">FlushBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 平台特有定位函数(不同平台会有所不同)</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">SeekLowLevel</span><span class="params">(int64 InPos)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 关闭文件句柄</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">CloseLowLevel</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 平台特有 将数据写入磁盘的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">WriteLowLevel</span><span class="params">(<span class="keyword">const</span> uint8* Src, int64 CountToWrite)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * Logs(日志输出) I/O 错误</span></span><br><span class="line"><span class="comment">	 * 在错误发生后和调用此函数之前，不要调用任何平台API函数，这一点很重要，</span></span><br><span class="line"><span class="comment">	 * 因为系统错误代码可能会被重置，并且不会正确记录在此消息中。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LogWriteError</span><span class="params">(<span class="keyword">const</span> TCHAR* Message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果当前archive在发生错误时不进行log，则返回真 */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsSilent</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !!(Flags &amp; FILEWRITE_Silent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** &quot;Filename&quot; 只用于调试 */</span></span><br><span class="line">	FString Filename;</span><br><span class="line">	uint32 Flags;</span><br><span class="line">	int64 Pos;							<span class="comment">// 文件句柄的Pos</span></span><br><span class="line">	TUniquePtr&lt;IFileHandle&gt; Handle;		<span class="comment">// 文件句柄，用来存二进制数据并写入磁盘的</span></span><br><span class="line">	TArray64&lt;uint8&gt; BufferArray;		<span class="comment">// 要写入磁盘的二进制数据</span></span><br><span class="line">	int64 BufferSize;					<span class="comment">// 4096</span></span><br><span class="line">	<span class="keyword">bool</span> bLoggingError;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ul><li>&quot;IFileHandle&quot; 这个文件句柄很重要，我们对磁盘文件的读写操作都基于 &quot;IFileHandle&quot; ，其由 &quot;IPlatformFile&quot; 生成（调用 &quot;OpenWrite&quot; 函数，打开一个文件，并生成一个操作该文件的 &quot;IFileHandle&quot; 指针 ）</li><li>在上面最后一张图中， &quot;CreateFileWriterInternal&quot; 函数便是 &quot;FFileManagerGeneric&quot; 通过调用 &quot;GetLowLevel&quot; 获取一个 &quot;IPlatformFile&quot; 的单例，然后生成 &quot;IFileHandle&quot;，并用其初始化咱的 &quot;FArchiveFileWriterGeneric&quot; 的。</li><li>接下来分析 &quot;FFileManagerGeneric&quot; 的 &quot;Serialize&quot; 函数和 &quot;Flush&quot; 函数，看看是怎么把我们的 uint8 数组写到磁盘中的</li></ul><p></p><figure class="highlight c++"><figcaption><span>FArchiveFileWriterGeneric.Serialize</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileManagerGeneric.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 &quot;FlushHandle&quot; 定位，</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FArchiveFileWriterGeneric::Serialize</span><span class="params">( <span class="keyword">void</span>* V, int64 Length )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pos += Length;		<span class="comment">// 将文件句柄的Pos向后移</span></span><br><span class="line">	<span class="keyword">if</span> ( Length &gt;= BufferSize )	<span class="comment">// BufferArray容不下该数据</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 因为BufferArray未初始化，Num为0，所以不会写入任何东西</span></span><br><span class="line">		<span class="built_in">FlushBuffer</span>();</span><br><span class="line">        <span class="comment">// 尝试把传进来的字节型地址写道内存，写的长度为length</span></span><br><span class="line">		<span class="keyword">if</span>( !<span class="built_in">WriteLowLevel</span>( (uint8*)V, Length ) )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetError</span>();</span><br><span class="line">			<span class="built_in">LogWriteError</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Error writing to file&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		int64 Copy;</span><br><span class="line">        <span class="comment">// buffer已满，把数据写入磁盘，并重置buff后，继续存入buffer，写入磁盘...</span></span><br><span class="line">		<span class="keyword">while</span>( Length &gt;( Copy=BufferSize-BufferArray.<span class="built_in">Num</span>() ) )</span><br><span class="line">		&#123;</span><br><span class="line">			BufferArray.<span class="built_in">Append</span>((uint8*)V, Copy);</span><br><span class="line">			Length      -= Copy;</span><br><span class="line">			V            =( uint8* )V + Copy;</span><br><span class="line">			<span class="built_in">FlushBuffer</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( Length )	<span class="comment">// Buffer未满 所以不调用FlushBuffer来写数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			BufferArray.<span class="built_in">Append</span>((uint8*)V, Length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新FileHandle</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FArchiveFileWriterGeneric::Flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">FlushBuffer</span>() &amp;&amp; Handle)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 调用平台特定的 FlushFileBuffers 函数</span></span><br><span class="line">		Handle-&gt;<span class="built_in">Flush</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 Handle.Write 的包装，返回是否Flush成功，输出日志，重置BUfferArray</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FArchiveFileWriterGeneric::FlushBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bDidWriteData = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (int64 BufferNum = BufferArray.<span class="built_in">Num</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		bDidWriteData = <span class="built_in">WriteLowLevel</span>(BufferArray.<span class="built_in">GetData</span>(), BufferNum);</span><br><span class="line">		<span class="keyword">if</span> (!bDidWriteData)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetError</span>();</span><br><span class="line">			<span class="built_in">LogWriteError</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Error flushing file&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		BufferArray.<span class="built_in">Reset</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDidWriteData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正写数据进磁盘的函数，可能会被操作系统暂时缓存，但最终还是会写入磁盘的</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FArchiveFileWriterGeneric::WriteLowLevel</span><span class="params">( <span class="keyword">const</span> uint8* Src, int64 CountToWrite )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里会根据不同平台调用不同的 WriteFile API 来完成写入</span></span><br><span class="line"><span class="comment">  	 * @param Src 要写入数据开头字节的指针</span></span><br><span class="line"><span class="comment">  	 * @param CountToWrite 要写入的字节个数</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">	<span class="keyword">return</span> Handle-&gt;<span class="built_in">Write</span>( Src, CountToWrite );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>到这里，咱总算是把 &quot;SaveGame&quot; 数据写进磁盘了，是不是很有成就感 😃</p></li></ul><hr><p><strong>总结：</strong></p><p>本篇没有逐个列举分析参与序列化的所有类，而是通过研究 &quot;SaveGameToSlot&quot; 方法，一步步探究序列化的整个过程。毕竟... 逐个列举分析，别说读者，写者也会写着写着睡着啊。真的很枯燥 😦</p><p>不过列举分析可能会分析得更全面一点吧，有空再回来补一下吧 😃</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-11-25 20:34:43" itemprop="dateModified" datetime="2021-11-25T20:34:43+08:00">2021-11-25</time> </span><span id="2021/11/02/UE4/UE4CPP/Unreal 序列化/" class="item leancloud_visitors" data-flag-title="Unreal 序列化~~~" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" title="Unreal 序列化~~~">https://kotori_suki.github.io/2021/11/02/UE4/UE4CPP/Unreal 序列化/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhnx9glj20zk0m8npd.jpg" title="Session的使用 C++篇"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Session的使用 C++篇</h3></a></div><div class="item right"><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclg5ms2rj20zk0m8u0x.jpg" title="Unreal GC过程"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal GC过程</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unreal-%E5%BA%8F%E5%88%97%E5%8C%96~~~"><span class="toc-number">1.</span> <span class="toc-text">Unreal 序列化～～～</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8Esavegametoslot%E5%87%BA%E5%8F%91"><span class="toc-number">1.1.</span> <span class="toc-text">从 SaveGameToSlot 出发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#savegametoslot"><span class="toc-number">1.1.0.0.1.</span> <span class="toc-text">SaveGameToSlot</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#savegametomemory"><span class="toc-number">1.1.0.0.2.</span> <span class="toc-text">SaveGameToMemory</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B-%E7%9C%9F%E7%9A%84%E5%BE%88%E9%95%BF%E5%BE%88%E9%95%BF"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">序列化过程 (真的很长很长......)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#objectserialize"><span class="toc-number">1.1.0.1.1.</span> <span class="toc-text">Object.Serialize</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fstructuredarchivefromarchive"><span class="toc-number">1.1.0.1.2.</span> <span class="toc-text">FStructuredArchiveFromArchive</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fstructuredarchiveformatter"><span class="toc-number">1.1.0.1.3.</span> <span class="toc-text">&quot;FStructuredArchiveFormatter&quot;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fstructuredarchive"><span class="toc-number">1.1.0.1.4.</span> <span class="toc-text">&quot;FStructuredArchive&quot;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fstructuredarchivefslot"><span class="toc-number">1.1.0.1.5.</span> <span class="toc-text">&quot;FStructuredArchive::FSlot&quot;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E5%AF%BB%E6%89%BE%E5%8F%82%E6%95%B0a-id%E5%BC%80%E5%A7%8B%E5%AF%BB%E6%89%BE%E5%8F%82%E6%95%B0a"><span class="toc-number">1.1.0.1.6.</span> <span class="toc-text">开始寻找参数 &lt;a id&#x3D;&quot;开始寻找参数&quot;&gt;&lt;&#x2F;a&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uobjectserializefstructuredarchivefrecord-record"><span class="toc-number">1.1.0.1.7.</span> <span class="toc-text">UObject::Serialize(FStructuredArchive::FRecord Record)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serializescriptproperties"><span class="toc-number">1.1.0.1.8.</span> <span class="toc-text">SerializeScriptProperties</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#savedatatoslot"><span class="toc-number">1.1.0.1.9.</span> <span class="toc-text">SaveDataToSlot</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#farchivefilewritergeneric"><span class="toc-number">1.1.0.1.10.</span> <span class="toc-text">FArchiveFileWriterGeneric</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li class="active"><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li><li><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" rel="bookmark" title="Unreal Slate">Unreal Slate</a></li><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li><li><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></li><li><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="bookmark" title="Custom Item Module">Custom Item Module</a></li><li><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></li><li><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">54</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/2021/08/16/ComputerBase/ComputerNetworks/TCPUDP%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/" title="TCP&#x2F;UDP传输层协议">TCP/UDP传输层协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/2021/08/16/ComputerBase/Algorithm/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针">双指针</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/20/CPPBase/%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%A3%E6%9E%90/" title="C++关键词解析">C++关键词解析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/21/CPPBase/DesignPattern/Decorater/" title="装饰器模式">装饰器模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/21/CPPBase/DesignPattern/State/" title="状态模式">状态模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="unreal引擎启动流程">unreal引擎启动流程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" title="Unreal 序列化~~~">Unreal 序列化~~~</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/TemplateMethod/" title="模板模式">模板模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/ChainOfResponsibility/" title="责任链模式">责任链模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/11/02/UE4/UE4CPP/Unreal 序列化/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>