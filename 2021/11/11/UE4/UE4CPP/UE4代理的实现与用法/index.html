<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/"><title>UE4代理的实现与用法 - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">UE4代理的实现与用法</h1><div class="meta"><span class="item" title="创建时间：2021-11-11 18:32:17"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-11-11T18:32:17+08:00">2021-11-11</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclga70tsj20zk0m84mr.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="ue4代理的实现与用法"><a class="anchor" href="#ue4代理的实现与用法">#</a> UE4 代理的实现与用法</h1><p>简介：这次旅程的重点是分析引擎怎么实现各种代理，用法只会稍微总结一下。跟反射，GC 比起来，这次的旅程会相对比较轻松（因为代理的模块内容比较少，而且相对来说比较独立，理解起来也会简单一点），出发（￣︶￣）↗</p><p>阅读本文可能需要你了解：</p><ul><li>比较好的 C++ 基础</li><li>UE 共享指针的作用及使用规则</li><li>UE 代理的基本使用规则（只总结</li><li>UE 的 GC 规则（代理绑定对象的 GC</li><li>序列化的相关知识（动态代理原理</li></ul><h2 id="代理的使用总结"><a class="anchor" href="#代理的使用总结">#</a> 代理的使用总结</h2><p>代理的主要作用是：解耦触发者和监听者之间的直接联系，让触发者可以在完全不认识监听者的情况下，调用到其函数，当然还可以解绑和重新绑定，提高代码的灵活性。</p><h3 id="代理的类型及说明"><a class="anchor" href="#代理的类型及说明">#</a> 代理的类型及说明：</h3><table><thead><tr><th>代理类型</th><th>绑定函数个数</th><th>是否可以返回值</th><th>是否支持 payload</th><th>是否可以绑定蓝图函数</th></tr></thead><tbody><tr><td>单播代理</td><td>1</td><td>是</td><td>是</td><td>否</td></tr><tr><td>多播代理</td><td>n</td><td>否</td><td>是</td><td>否</td></tr><tr><td>动态单播代理</td><td>1</td><td>是</td><td>否</td><td>是</td></tr><tr><td>动态多播代理</td><td>n</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><p>Q：为什么要这么多类型的代理？不能一个搞定吗？</p><ol><li>首先不同代理的性能消耗是完全不同的，我们不能为了统一而牺牲大量的性能（下文会对不同代理的性能消耗进行分析）</li><li>其次，从表格中也可以看出，并不是所有的代理能支持的功能都完全一致，拆开能让我们的代理更灵活，同时也能支持更为具体的功能</li><li>最后，使用过代理的同学也知道，有一些代理是硬性要求只能绑定一个函数的，而又有一些代理我们并不想让蓝图触碰到，如果不拆开，这些都是没办法保证的，程序的健壮性会降低</li></ol><h3 id="代理的声明"><a class="anchor" href="#代理的声明">#</a> 代理的声明</h3><table><thead><tr><th>代理类型</th><th>宏声明</th></tr></thead><tbody><tr><td>单播代理</td><td>DECLARE_DELEGATE_* / DECLARE_DELEGATE_RetVal_*</td></tr><tr><td>多播代理</td><td>DECLARE_MULTICAST_DELEGATE_*</td></tr><tr><td>动态单播代理</td><td>DECLARE_DYNAMIC_DELEGATE_* / DECLARE_DYNAMIC_DELEGATE_RetVal_*</td></tr><tr><td>动态多播代理</td><td>DECLARE_DYNAMIC_MULTICAST_DELEGATE_*</td></tr></tbody></table><p>注：* 表示不同参数个数</p><h3 id="代理的绑定"><a class="anchor" href="#代理的绑定">#</a> 代理的绑定</h3><ul><li><p><strong>单播代理：</strong></p><table><thead><tr><th>绑定函数</th><th>说明</th></tr></thead><tbody><tr><td>BindStatic</td><td>绑定 C++ 的 Static 函数</td></tr><tr><td>BindRaw</td><td>绑定 C++ 对象的成员函数</td></tr><tr><td>BindLambda</td><td>绑定 Lambda 函数（对 Lambda 所属对象持有弱引用</td></tr><tr><td>BindWeakLambda</td><td>绑定 UObject 的 Lambda 函数（对 Lambda 所属对象持有弱引用</td></tr><tr><td>BindSP</td><td>绑定共享指针指向的 C++ 对象的成员函数</td></tr><tr><td>BindThreadSafeSP</td><td>绑定线程安全的共享指针指向的 C++ 对象的成员函数</td></tr><tr><td>BindUObject</td><td>绑定 UObject 对象的成员函数（对该 UObject 持有弱引用</td></tr><tr><td>BindUFunction</td><td>绑定 UObject 对象的 UFunction 函数（对该 UObject 持有弱引用</td></tr></tbody></table></li><li><p><strong>多播代理：</strong></p><table><thead><tr><th>绑定函数</th><th>说明</th></tr></thead><tbody><tr><td>AddStatic</td><td>AddStatic(FuncPtr, Vars...)</td></tr><tr><td>AddRaw</td><td>AddRaw(UObject*, FuncAddress)</td></tr><tr><td>AddLambda</td><td>AddLambda(Functor, Vars...)</td></tr><tr><td>AddWeakLambda</td><td>AddWeakLambda(UObject*, Functor, Vars...)</td></tr><tr><td>AddSP</td><td>AddSP(TSharedRef, FuncAddress)</td></tr><tr><td>AddThreadSafeSP</td><td>AddThreadSafeSP(TSharedRef, FuncAddress)</td></tr><tr><td>AddUObject</td><td>AddUObject(UObject*, FuncAddress)</td></tr><tr><td>AddUFunction</td><td>AddUFunction(UObject*,STATIC_FUNCTION_FNAME(TEXT(&quot;UClassName::FuncName&quot;)))</td></tr></tbody></table></li><li><p><strong>动态单播代理：</strong></p><table><thead><tr><th>绑定函数 / 宏</th><th>说明</th></tr></thead><tbody><tr><td>BindUFunction</td><td>BindUFunction(UObject*,STATIC_FUNCTION_FNAME(TEXT(&quot;UClassName::FuncName&quot;)))</td></tr><tr><td>BindDynamic</td><td>BindDynamic(UObject*, FuncPtr)</td></tr></tbody></table></li><li><p><strong>动态多播代理：</strong></p><table><thead><tr><th>绑定函数</th><th></th></tr></thead><tbody><tr><td>Add</td><td>Add(FScriptDelegate)，FScriptDelegate.BindUFunction(UObject*, FuncPtr)</td></tr><tr><td>AddUnique</td><td>同上，重复添加会报错</td></tr><tr><td>AddDynamic</td><td>可以不借助 &quot;FScriptDelegate&quot; 直接绑定，AddDynamic (UObject*, FuncPtr)</td></tr><tr><td>AddUniqueDynamic</td><td>同上，重复添加会报错</td></tr></tbody></table><p>不知道读者们会不会有这样的疑惑：为什么要这么多绑定函数？为什么不能统一成一个接口？其实是因为绑定不同类型函数需要对绑定的 &quot;FDelegate&quot; 做不同的初始化，我们没有办法通过判断传进来的函数指针来判断是什么类型的函数，有的读者就会说了：加个 Enum 来表示函数类型不行吗？确实可以，但每种类型的函数的参数也是不同的，如果强行统一，会导致参数的冗余。而且我个人认为没有必要，因为拆开可以让代码更直观更易于理解。</p></li></ul><h3 id="代理的触发"><a class="anchor" href="#代理的触发">#</a> 代理的触发</h3><table><thead><tr><th>代理类型</th><th>触发函数</th></tr></thead><tbody><tr><td>单播代理</td><td>Execute / ExecuteIfBound | Execute (有返回值)</td></tr><tr><td>多播代理</td><td>Broadcast（不一定按绑定顺序执行</td></tr><tr><td>动态单播代理</td><td>同单播</td></tr><tr><td>动态多播代理</td><td>同多播</td></tr></tbody></table><h3 id="代理的解绑"><a class="anchor" href="#代理的解绑">#</a> 代理的解绑</h3><table><thead><tr><th>代理类型</th><th>解绑函数</th></tr></thead><tbody><tr><td>单播代理</td><td>UnBind() / Clear()</td></tr><tr><td>多播代理</td><td>Remove(Handle) / RemoveAll(Object) / Clear()</td></tr><tr><td>动态单播代理</td><td>同单播</td></tr><tr><td>动态多播代理</td><td>同多播 (Handle -&gt; FScriptDelegate) + RemoveDynamic (UObject* , FunctionPtr)</td></tr></tbody></table><p>代理的使用篇到此结束，当然还有一些其他实用性比较强的函数，比如 &quot;IsBound&quot; 等。读者可以自行到官方文档中了解</p><hr><h2 id="代理在源码中的实现"><a class="anchor" href="#代理在源码中的实现">#</a> 代理在源码中的实现</h2><p>源码中实现代理的类其实并不多但也不少，我觉得直接把类罗列出来分析，不如从我们认识的宏或者函数出发，一步一步地接近底层类，因为这样逻辑性会更强，更易于理解，而且还能适当地思考引擎如此实现代理其背后的原因是什么，我认为理解这些比读懂源码更为重要。那么，让我们开始吧 😃</p><h3 id="从-declare_delegate-出发"><a class="anchor" href="#从-declare_delegate-出发">#</a> 从 DECLARE_DELEGATE () 出发</h3><p>我们要用代理，那就离不开这个宏，所以要先看看这个宏是怎么实现的</p><p></p><figure class="highlight c++"><figcaption><span>DECLARE_DELEGATE</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateCombinations.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_DELEGATE( DelegateName ) FUNC_DECLARE_DELEGATE( DelegateName, void )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个类型 TDelegate&lt;ReturnType(__VA_ARGS__)&gt;，其定义在下面</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNC_DECLARE_DELEGATE( DelegateName, ReturnType, ... ) \</span></span><br><span class="line"><span class="meta">	typedef TDelegate<span class="meta-string">&lt;ReturnType(__VA_ARGS__)&gt;</span> DelegateName;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类，将函数签名和代理策略联系起来，函数签名为 void() ，代理策略使用默认策略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DelegateSignature, <span class="keyword">typename</span> UserPolicy = FDefaultDelegateUserPolicy&gt;</span><br><span class="line">class TDelegate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态断言，函数签名的size为0</span></span><br><span class="line">	<span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DelegateSignature) == <span class="number">0</span>, <span class="string">&quot;Expected a function signature for the delegate template parameter&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认策略只是为三个类(都很重要，下文解析)重命名，没有属性，也没有方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FDefaultDelegateUserPolicy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">using</span> FDelegateInstanceExtras  = IDelegateInstance;</span><br><span class="line">	<span class="keyword">using</span> FDelegateExtras          = FDelegateBase;</span><br><span class="line">	<span class="keyword">using</span> FMulticastDelegateExtras = TMulticastDelegateBase&lt;FDefaultDelegateUserPolicy&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InRetValType, <span class="keyword">typename</span>... ParamTypes, <span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TDelegate</span>&lt;</span><span class="built_in">InRetValType</span>(ParamTypes...), UserPolicy&gt; : <span class="keyword">public</span> TDelegateBase&lt;UserPolicy&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看出，其实咱的宏就是在定义一个 &quot;TDelegate&lt;void (), ..., FDefaultDelegateUserPolicy&gt;&quot; 的代理，其中可变参数为空（如果有朋友理解不了这段代码，建议先回去补一下 C++）</p><p>到这里其实我们就已经定义好一个代理类了。至于 &quot;FDefaultDelegateUserPolicy&quot; 和 &quot;TDelegate&quot; 两个类，我想结合代理的绑定和触发来具体分析，那咱就来看看引擎是怎么帮我们绑定代理的吧 ）</p><h3 id="理解-binduobject"><a class="anchor" href="#理解-binduobject">#</a> 理解 BindUObject ()</h3><p>如前文我们总结的一样，代理的绑定其实有很多种方法，但是实现基本也都大同小异。所以这里咱只对 &quot;BindUObject&quot; 函数进行分析</p><h4 id="binduobject"><a class="anchor" href="#binduobject">#</a> BindUObject</h4><p></p><figure class="highlight c++"><figcaption><span>BindUObject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateSignatureImpl.inl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InRetValType, <span class="keyword">typename</span>... ParamTypes, <span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TDelegate</span>&lt;</span><span class="built_in">InRetValType</span>(ParamTypes...), UserPolicy&gt; : <span class="keyword">public</span> TDelegateBase&lt;UserPolicy&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> UserClass, <span class="keyword">typename</span>... VarTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BindUObject</span><span class="params">(<span class="keyword">const</span> UserClass* InUserObject, <span class="keyword">typename</span> TMemFunPtrType&lt;<span class="literal">true</span>, UserClass, RetValType (ParamTypes..., VarTypes...)&gt;::Type InFunc, VarTypes... Vars)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        *<span class="keyword">this</span> = <span class="built_in">CreateUObject</span>(InUserObject, InFunc, Vars...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 	&quot;TMemFunPtrType&quot; 的定义</span></span><br><span class="line"><span class="comment">        template &lt;typename Class, typename RetType, typename... ArgTypes&gt;</span></span><br><span class="line"><span class="comment">        struct TMemFunPtrType&lt;false, Class, RetType(ArgTypes...)&gt;</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            typedef RetType (Class::* Type)(ArgTypes...);</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> UserClass, <span class="keyword">typename</span>... VarTypes&gt;</span><br><span class="line">    <span class="function">UE_NODISCARD <span class="keyword">inline</span> <span class="keyword">static</span> TDelegate&lt;<span class="title">RetValType</span><span class="params">(ParamTypes...)</span>, UserPolicy&gt; <span class="title">CreateUObject</span><span class="params">(<span class="keyword">const</span> UserClass* InUserObject, <span class="keyword">typename</span> TMemFunPtrType&lt;<span class="literal">true</span>, UserClass, RetValType (ParamTypes..., VarTypes...)&gt;::Type InFunc, VarTypes... Vars)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TDelegate&lt;<span class="built_in">RetValType</span>(ParamTypes...), UserPolicy&gt; Result;</span><br><span class="line">        TBaseUObjectMethodDelegateInstance&lt;<span class="literal">true</span>, <span class="keyword">const</span> UserClass, FuncType, UserPolicy, VarTypes...&gt;::<span class="built_in">Create</span>(Result, InUserObject, InFunc, Vars...);</span><br><span class="line">        <span class="keyword">return</span> Result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> bConst, <span class="class"><span class="keyword">class</span> <span class="title">UserClass</span>, <span class="title">typename</span> <span class="title">WrappedRetValType</span>, <span class="title">typename</span>... <span class="title">ParamTypes</span>, <span class="title">typename</span> <span class="title">UserPolicy</span>, <span class="title">typename</span>... <span class="title">VarTypes</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TBaseUObjectMethodDelegateInstance</span>&lt;</span>bConst, UserClass, <span class="built_in">WrappedRetValType</span>(ParamTypes...), UserPolicy, VarTypes...&gt; : <span class="keyword">public</span> TCommonDelegateInstanceState&lt;<span class="built_in">WrappedRetValType</span>(ParamTypes...), UserPolicy, VarTypes...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">using</span> Super             = TCommonDelegateInstanceState&lt;<span class="built_in">WrappedRetValType</span>(ParamTypes...), UserPolicy, VarTypes...&gt;;</span><br><span class="line">	<span class="keyword">using</span> RetValType        = <span class="keyword">typename</span> Super::RetValType;</span><br><span class="line">	<span class="keyword">using</span> UnwrappedThisType = TBaseUObjectMethodDelegateInstance&lt;bConst, UserClass, <span class="built_in">RetValType</span>(ParamTypes...), UserPolicy, VarTypes...&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造该类的同时，构造基类 &quot;TCommonDelegateInstanceState&quot;，</span></span><br><span class="line">    <span class="comment">// 可以看出其基类只是用来处理不定参数的，基类的定义在下面</span></span><br><span class="line">    <span class="built_in">TBaseUObjectMethodDelegateInstance</span>(UserClass* InUserObject, FMethodPtr InMethodPtr, VarTypes... Vars)</span><br><span class="line">        : <span class="built_in">Super</span>(Vars...)</span><br><span class="line">        , <span class="built_in">UserObject</span>(InUserObject)</span><br><span class="line">        , <span class="built_in">MethodPtr</span> (InMethodPtr)</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供给外部调用的统一构造接口</span></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span><span class="params">(FDelegateBase&amp; Base, UserClass* InUserObject, FMethodPtr InFunc, VarTypes... Vars)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">// 在传进来的 &quot;FDelegateBase&quot; 中构造一个该类对象。注意！这里构造的类对象并不是 &quot;FDelegateBase&quot; 的子类，而是 &quot;IDelegateInstance&quot; 的子类。也就是在一个 &quot;FDelegateBase&quot; 的头地址里面，构造一个 &quot;IDelegateInstance&quot;，原因下文详细解析</span></span><br><span class="line">		<span class="keyword">new</span> (Base) <span class="built_in">UnwrappedThisType</span>(InUserObject, InFunc, Vars...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定的UObject的弱指针(不参与引用计数)</span></span><br><span class="line">	TWeakObjectPtr&lt;UserClass&gt; UserObject;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// C++成员函数指针</span></span><br><span class="line">	FMethodPtr MethodPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 &quot;IDelegateInstance&quot;，一个存着 &quot;payload&quot; 元组和 &quot;DelegateHandle&quot; 信息的模板类，下文会对两个属性进行分析</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InRetValType, <span class="keyword">typename</span>... ParamTypes, <span class="keyword">typename</span> UserPolicy, <span class="keyword">typename</span>... VarTypes&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCommonDelegateInstanceState</span>&lt;</span><span class="built_in">InRetValType</span>(ParamTypes...), UserPolicy, VarTypes...&gt; : IBaseDelegateInstance&lt;<span class="built_in">InRetValType</span>(ParamTypes...), UserPolicy&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> RetValType = InRetValType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将不定参数存到 &quot;Payload&quot; 元组里面，默认值初始化代理句柄</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">TCommonDelegateInstanceState</span><span class="params">(VarTypes... Vars)</span></span></span><br><span class="line"><span class="function">		: Payload(Vars...)</span></span><br><span class="line"><span class="function">		, Handle (FDelegateHandle::GenerateNewHandle)</span></span><br><span class="line"><span class="function">	&#123;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">FDelegateHandle <span class="title">GetHandle</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Handle;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// &quot;TTuple&quot; 元组，用来存一些不变的参数(如果有) 和 &quot;Invoke&quot;(执行)函数</span></span><br><span class="line">	TTuple&lt;VarTypes...&gt; Payload;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 该代理的句柄，&quot;FDelegateHandle&quot; 代理句柄类</span></span><br><span class="line">	FDelegateHandle Handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>上面这段代码看起来似乎干了很多事，实际上只是在咱的 &quot;FDelegateBase&quot; 中构造了一个 &quot;IDelegateInstance&quot;，并初始化他的一些参数，包括：引用对象的弱指针，绑定的 C++ 函数指针，Payload 参数 (可以没有)，默认的 DelegateHandle。（如果还是看不懂，那一定得好好补一补 C++ 啊，朋友）</p><p>突然想起一个曾经困扰了我很久的一个问题：为什么这里都拿到了函数的指针了，还要把这个对象给绑进去？其实会问这个问题，完全是因为对 C++ 的理解还不够深刻。我们知道，在 C++ 中，类的成员函数是单独存在内存中的代码段的，所有该类的对象调用该函数时，其实都是访问的同样一块地址，所以如果我们要改变一个具体的对象，那就必须要把这个对象也一起传给我们的代理对象。相信聪明的读者们不会问这种问题，但是其实算是一个提醒吧。UE 是建立在 C++ 的基础上的，没有良好的 C++ 基础在理解一些源码实现上是会比较吃力的。C++ yyds！</p><p>其实到这里我们已经挖下不少坑了，比如：&quot;FDefaultDelegateUserPolicy&quot; , &quot;IDelegateInstance&quot; , &quot;FDelegateBase&quot; , &quot;TMulticastDelegateBase&lt;&gt;&quot; , &quot;TTuple&lt;&gt;&quot; 这些类都是非常重要，且需要逐个分析的。先别着急，咱会在下面的 &quot;Execute&quot; 接口中，给他逐个击破！</p><h2 id="开始-execute"><a class="anchor" href="#开始-execute">#</a> 开始 Execute</h2><p></p><figure class="highlight c++"><figcaption><span>Execute</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateSignatureImpl.inl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InRetValType, <span class="keyword">typename</span>... ParamTypes, <span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TDelegate</span>&lt;</span><span class="built_in">InRetValType</span>(ParamTypes...), UserPolicy&gt; : <span class="keyword">public</span> TDelegateBase&lt;UserPolicy&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">FORCEINLINE RetValType <span class="title">Execute</span><span class="params">(ParamTypes... Params)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取父类的 &quot;DelegateInstance&quot;，其存着绑定的对象和函数的对象，函数定义在下面</span></span><br><span class="line">        DelegateInstanceInterfaceType* LocalDelegateInstance = <span class="built_in">GetDelegateInstanceProtected</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这里触发断言，说明 &quot;Execute()&quot; 在未绑定的情况下就被调用了。</span></span><br><span class="line">        <span class="comment">// 可以考虑使用 ExecuteIfSafe() 代替</span></span><br><span class="line">        <span class="built_in">checkSlow</span>(LocalDelegateInstance != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用绑定的对象调用绑定的函数，下文解析</span></span><br><span class="line">        <span class="keyword">return</span> LocalDelegateInstance-&gt;<span class="built_in">Execute</span>(Params...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FORCEINLINE DelegateInstanceInterfaceType* <span class="title">GetDelegateInstanceProtected</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 前面定义了 using Super = TDelegateBase&lt;UserPolicy&gt;，类的详细定义在下面 */</span></span><br><span class="line">        <span class="keyword">return</span> (DelegateInstanceInterfaceType*)Super::<span class="built_in">GetDelegateInstanceProtected</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看出 &quot;TDelegateBase&quot; 是没有定义 &quot;GetDelegateInstanceProtected&quot; 函数的</span></span><br><span class="line"><span class="comment">// 所以唯一的可能就是 那是其基类&quot;UserPolicy::FDelegateExtras&quot; 的函数</span></span><br><span class="line"><span class="comment">// 得出结论: 引擎对 &quot;UserPolicy&quot; 这个模板类的实现一定是有硬性要求的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TDelegateBase</span> :</span> <span class="keyword">public</span> UserPolicy::FDelegateExtras</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TMulticastDelegateBase</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> Super = <span class="keyword">typename</span> UserPolicy::FDelegateExtras;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FName <span class="title">TryGetBoundFunctionName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">FORCEINLINE class UObject* <span class="title">GetUObject</span><span class="params">( )</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">IsBound</span><span class="params">( )</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">const</span> <span class="keyword">void</span>* <span class="title">GetObjectForTimerManager</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">uint64 <span class="title">GetBoundProgramCounterForTimerManager</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">bool</span> <span class="title">IsBoundToObject</span><span class="params">( <span class="keyword">void</span> <span class="keyword">const</span>* InUserObject )</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">FORCEINLINE FDelegateHandle <span class="title">GetHandle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过上面的分析，我们知道，<strong>&quot;Execute&quot; 里面其实只是获取了之前我们绑定好的数据，并调用而已</strong>。但是他怎么获取的呢？通过逐步溯源，我们知道，<strong>&quot;GetDelegateInstanceProtected&quot; 其实是 &quot;UserPolicy&quot; 模板中的函数，且引擎对 &quot;UserPolicy&quot; 的实现是有硬性要求的</strong>。回顾一下咱之前定义代理的代码：</p><blockquote><p>// 模板类，将函数签名和代理策略联系起来，函数签名为 void () ，代理策略使用默认策略<br>template &lt;typename DelegateSignature, typename UserPolicy = <strong>FDefaultDelegateUserPolicy</strong>&gt;<br>class TDelegate<br>{<br>static_assert(sizeof(DelegateSignature) == 0, &quot;Expected a function signature for the delegate template parameter&quot;);<br>};</p></blockquote><p>可以看出，咱的 &quot;UserPolicy&quot; 其实就是 &quot;FDefaultDelegateUserPolicy&quot;，那咱直接去 &quot;FDefaultDelegateUserPolicy&quot; 里面找（<strong>咱现在的目的是 弄清楚 &quot;GetDelegateInstanceProtected&quot; 是怎么获取到咱之前绑定的对象和函数的</strong>）</p><p></p><figure class="highlight c++"><figcaption><span>FDefaultDelegateUserPolicy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateBase.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FDefaultDelegateUserPolicy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">using</span> FDelegateInstanceExtras  = IDelegateInstance;</span><br><span class="line">	<span class="keyword">using</span> FDelegateExtras          = FDelegateBase;		<span class="comment">// 这是我们的 &quot;TDelegateBase&quot; 继承的</span></span><br><span class="line">	<span class="keyword">using</span> FMulticastDelegateExtras = TMulticastDelegateBase&lt;FDefaultDelegateUserPolicy&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FDelegateBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TMulticastDelegateBase</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TDelegateBase</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">FDelegateBase</span><span class="params">()</span>: DelegateSize(<span class="number">0</span>)&#123;</span>	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">FDelegateBase</span>() &#123;<span class="built_in">Unbind</span>();&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FDelegateBase</span>(FDelegateBase&amp;&amp; Other);</span><br><span class="line"></span><br><span class="line">	FDelegateBase&amp; <span class="keyword">operator</span>=(FDelegateBase&amp;&amp; Other);</span><br><span class="line"></span><br><span class="line">	<span class="function">FORCEINLINE <span class="keyword">void</span> <span class="title">Unbind</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 果然在这里，这里获取到的是一个 &quot;IDelegateInstance&quot;，这说明什么?</span></span><br><span class="line">	<span class="function">FORCEINLINE IDelegateInstance* <span class="title">GetDelegateInstanceProtected</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> DelegateSize ? (IDelegateInstance*)DelegateAllocator.<span class="built_in">GetAllocation</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重载 new 运算符</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> Size, FDelegateBase&amp; Base)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base.<span class="built_in">Allocate</span>((int32)Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 &quot;DelegateAllocator&quot; 属性分配内存，在 &quot;new&quot; 中调用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="title">Allocate</span><span class="params">(int32 Size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (IDelegateInstance* CurrentInstance = <span class="built_in">GetDelegateInstanceProtected</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            CurrentInstance-&gt;~<span class="built_in">IDelegateInstance</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算新代理的大小，&quot;FAlignedInlineDelegateType&quot; 是代理类型的对齐字节后的模板结构体</span></span><br><span class="line">        <span class="comment">// 引擎会根据系统是32位还是64位返回不同的值，用于后面的 &quot;ResizeAllocation&quot; 重新分配堆内存。</span></span><br><span class="line">        int32 NewDelegateSize = FMath::<span class="built_in">DivideAndRoundUp</span>(Size, (int32)<span class="built_in"><span class="keyword">sizeof</span></span>(FAlignedInlineDelegateType));</span><br><span class="line">        <span class="keyword">if</span> (DelegateSize != NewDelegateSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 为 &quot;DelegateAllocator&quot; 重新分配内存(存的是FAlignedInlineDelegateType型数据)</span></span><br><span class="line">            DelegateAllocator.<span class="built_in">ResizeAllocation</span>(<span class="number">0</span>, NewDelegateSize, <span class="built_in"><span class="keyword">sizeof</span></span>(FAlignedInlineDelegateType));</span><br><span class="line">            <span class="comment">// 记录新内存的Size</span></span><br><span class="line">            DelegateSize = NewDelegateSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回刚刚分配好的内存 &quot;FAlignedInlineDelegateType&quot; 型指针</span></span><br><span class="line">        <span class="keyword">return</span> DelegateAllocator.<span class="built_in">GetAllocation</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	FDelegateAllocatorType::ForElementType&lt;FAlignedInlineDelegateType&gt; DelegateAllocator;</span><br><span class="line">	int32 DelegateSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>刚刚的代码可能看着就有点晕，因为确实挺绕的。总的来说就是模板类外加组合模式。</p><p>首先需要明确的是：咱的 <strong>&quot;TDelegate&quot; 是继承于咱的 &quot;FDelegate&quot; 的。而这个 &quot;FDelegate&quot; 只是 &quot;UserPolicy&quot; 这个组合中一部分，且 &quot;UserPolicy&quot; 是作为 &quot;FDelegate&quot; 的模板传进来的</strong>。这么做的好处是 低解耦高聚合，且 &quot;UserPolicy&quot; 可被重写，代码的可拓展性更强。</p><p>其次，<strong>&quot;FDelegate&quot; 中其实是存着 &quot;IDelegateInstance&quot; 的，怎么理解？简单来说，&quot;FDelegate&quot; 只是 &quot;IDelegateInstance&quot; 的包装器，真正存着绑定对象与绑定函数的是 &quot;IDelegateInstance&quot;，&quot;FDelegate&quot; 中只提供 &quot;IDelegateInstance&quot; 的构造方法</strong> (&quot;BindUObject&quot; 等)</p><p>知道了这些，我们再分析上面的代码。</p><ol><li><p>首先调用的是 &quot;GetDelegateInstanceProtected&quot;，这是在获取该 &quot;FDelegate&quot;(代理包装器) 对象的 &quot;DelegateAllocator&quot; (代理内存) 中的 &quot;Allocation&quot;(内存数据) ，而内存数据又是个 &quot;IDelegateInstance&quot;(代理实例) 对象，设计模式学得好的同学就直接反应过来了，好一个组合模式！这个 &quot;IDelegateInstance&quot; 拥有所有关于这个代理的所有信息。</p></li><li><p>其次我们要搞清楚，这个 &quot;IDelegateInstance&quot; 是什么时候被初始化的？那作为 C++ 的学生，我们第一反应当然是 &quot;new&quot; 运算符啊。确实是 &quot;new&quot; 运算符，但不是上面 &quot;FDelegateBase&quot; 里面重载的，而是 &quot;IDelegateInstance&quot; 接口的默认构造函数。上面重载的 &quot;new&quot; 是为 &quot;FDelegateBase&quot; 的 &quot;DelegateAllocator&quot; 分配堆内存的，以便将 &quot;IDelegateInstance&quot; 存进去</p></li><li><p>那是什么时候初始化的呢？这就得回去找找咱的 &quot;BindUObject&quot; 了：</p></li></ol><blockquote><p>&quot;BindUObject&quot; 的调用链中，调用了以下函数：</p><p></p><figure class="highlight c++"><figcaption><span>IDelegateInstance</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateSignatureImpl.inl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... VarTypes&gt;</span><br><span class="line"><span class="function">UE_NODISCARD <span class="keyword">inline</span> <span class="keyword">static</span> TDelegate&lt;<span class="title">RetValType</span><span class="params">(ParamTypes...)</span>, UserPolicy&gt; <span class="title">CreateStatic</span><span class="params">(<span class="keyword">typename</span> TIdentity&lt;RetValType (*)(ParamTypes..., VarTypes...)&gt;::Type InFunc, VarTypes... Vars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;TDelegate&quot; 的默认构造函数什么都没做，但会调用基类 &quot;FDelegate&quot; 的默认构造函数，虽然也什么都没做(并不会调用重载的new)</span></span><br><span class="line">    TDelegate&lt;<span class="built_in">RetValType</span>(ParamTypes...), UserPolicy&gt; Result;</span><br><span class="line">    TBaseStaticDelegateInstance&lt;FuncType, UserPolicy, VarTypes...&gt;::<span class="built_in">Create</span>(Result, InFunc, Vars...);</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;TBaseStaticDelegateInstance&quot; 提供给外部调用的统一构造接口</span></span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span><span class="params">(FDelegateBase&amp; Base, UserClass* InUserObject, FMethodPtr InFunc, VarTypes... Vars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在传进来的 &quot;FDelegateBase&quot; 中构造一个该类对象。注意！这里构造的类对象并不是 &quot;FDelegateBase&quot; 的子类，而是 &quot;IDelegateInstance&quot; 的子类。也就是在一个 &quot;FDelegateBase&quot; 的头地址里面，构造一个 &quot;IDelegateInstance&quot;，原因下文详细解析</span></span><br><span class="line">	<span class="keyword">new</span> (Base) <span class="built_in">UnwrappedThisType</span>(InUserObject, InFunc, Vars...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>这里的 &quot;UnwrappedThisType&quot;，其实就是咱 &quot;IDelegateInstance&quot; 的子类。那这一步到底做了什么？</p><ol start="2"><li>首先会调用接口下的类 &quot;TCommonDelegateInstanceState&quot; 的构造函数，初始化该代理的 &quot;payload&quot; 和 &quot;DelegateHandle&quot;</li><li>其次是调用 &quot;TBaseUObjectMethodDelegateInstance&quot; 的构造函数，初始化该代理所绑定的 &quot;UObject&quot; 及其函数（ &quot;TBaseUObjectMethodDelegateInstance&quot; 即是 &quot;UnwrappedThisType&quot;）</li><li>最后再把初始化好的 &quot;IDelegateInstance&quot; 对象给放到 &quot;Base&quot; 里面</li></ol><p>有的同学可能就要问了，你这个 &quot;Base&quot; 空间够不够啊，直接在上面 &quot;new&quot; 一个 &quot;IDelegateInstance&quot; 不会溢出吗？首先我们知道，&quot;IDelegateInstance&quot; 并不会直接存在 &quot;FDelegateBase&quot; 里面，而是存在其 &quot;DelegateAllocator&quot; 中的 &quot;Data&quot; 里面，&quot;Data&quot; 指向另一块堆内存。而 &quot;GetDelegateInstanceProtected&quot; 实际上就只是把 &quot;Data&quot; 拿过来做一次强制类型转换罢了</p><p>如果还是没理解的读者，建议多看两遍前面的解释，或者自己翻翻源码，这块确实有点绕。那么，到这里咱就知道怎么获取到绑定数据了，接下来就是调用 <code>LocalDelegateInstance-&gt;Execute(Params...)</code> ，以下是其源码：</p><p></p><figure class="highlight c++"><figcaption><span>Instance.Execute</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateInstancesImpl.h</span></span><br><span class="line"></span><br><span class="line"><span class="function">RetValType <span class="title">Execute</span><span class="params">(ParamTypes... Params)</span> <span class="keyword">const</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> MutableUserClass = <span class="keyword">typename</span> TRemoveConst&lt;UserClass&gt;::Type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为我们拥有的只是 UObject 的弱指针，所以需要确认一下该对象是否仍然存在</span></span><br><span class="line">    <span class="built_in">checkSlow</span>(UserObject.<span class="built_in">IsValid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全移除 &quot;UserObject&quot; 的 &quot;const&quot;，避免编译器报错。</span></span><br><span class="line">    <span class="comment">// Safely remove const to work around a compiler issue with instantiating template permutations for </span></span><br><span class="line">	<span class="comment">// overloaded functions that take a function pointer typedef as a member of a templated class.  </span></span><br><span class="line">    <span class="comment">// In all cases where this code is actually invoked, the UserClass will already be a const pointer.</span></span><br><span class="line">    MutableUserClass* MutableUserObject = <span class="keyword">const_cast</span>&lt;MutableUserClass*&gt;(UserObject.<span class="built_in">Get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checkSlow</span>(MethodPtr != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 通过 &quot;payload&quot; 来调用绑定的函数，</span></span><br><span class="line"><span class="comment">     * &quot;Payload&quot; 的类型 &quot;TTuple&quot;，其本身可以存一些变量，用于 &quot;Invoke&quot; (执行)函数</span></span><br><span class="line"><span class="comment">     * &quot;Invoke&quot; 是unreal中非常实用的函数之一，其原理是通过函数指针来调用函数，使用完美转发是为了兼容左右值函数</span></span><br><span class="line"><span class="comment">     * 参数: &quot;MethodPtr&quot; 是之前绑定的函数；&quot;Params&quot; 是传进来运行的参数，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;Payload.<span class="built_in">ApplyAfter</span>(MethodPtr, MutableUserObject, Params...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FuncType, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">ApplyAfter</span><span class="params">(FuncType&amp;&amp; Func, ArgTypes&amp;&amp;... Args)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 &quot;this-&gt;template Get&lt;Indices&gt;()...&quot; 其实是 &quot;Payload&quot; 中之前存的参数，可以为空</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">Invoke</span>(Func, Forward&lt;ArgTypes&gt;(Args)..., <span class="keyword">this</span>-&gt;<span class="keyword">template</span> Get&lt;Indices&gt;()...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个重载，分别运行函子，函数指针，成员函数(引用参数和智能指针各一条)，咱们这里调用的显然是引用的成员函数:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span> ObjType, <span class="keyword">typename</span>... PMFArgTypes, <span class="keyword">typename</span> CallableType, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">auto</span> <span class="title">Invoke</span><span class="params">(ReturnType (ObjType::*PtrMemFun)(PMFArgTypes...), CallableType&amp;&amp; Callable, ArgTypes&amp;&amp;... Args)</span></span></span><br><span class="line"><span class="function">	-&gt; <span class="title">decltype</span><span class="params">((UE4Invoke_Private::DereferenceIfNecessary&lt;ObjType&gt;(Forward&lt;CallableType&gt;(Callable)).*PtrMemFun)(Forward&lt;ArgTypes&gt;(Args)...))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (UE4Invoke_Private::DereferenceIfNecessary&lt;ObjType&gt;(Forward&lt;CallableType&gt;(Callable)).*PtrMemFun)(Forward&lt;ArgTypes&gt;(Args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BaseType, <span class="keyword">typename</span> CallableType, <span class="keyword">typename</span> TEnableIf&lt;TPointerIsConvertibleFromTo&lt;<span class="keyword">typename</span> TDecay&lt;CallableType&gt;::Type, <span class="keyword">typename</span> TDecay&lt;BaseType&gt;::Type&gt;::Value&gt;::Type* = <span class="literal">nullptr</span></span><br><span class="line">    &gt;</span><br><span class="line">    FORCEINLINE <span class="keyword">auto</span> <span class="built_in">DereferenceIfNecessary</span>(CallableType&amp;&amp; Callable) -&gt; <span class="keyword">decltype</span>((CallableType&amp;&amp;)Callable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (CallableType&amp;&amp;)Callable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>看到这里相信 C++ 基础好的同学都整明白了。就是用之前存起来的 &quot;MethodPtr&quot; 和 &quot;UObject*&quot; 和 不定参数，调用 &quot;Invoke&quot; 来让该函数被该对象中执行，至于一些 C++11 的新特性，咱放到另外一篇文章中来讲。</p><p>到这里咱之前挖的坑已经全部填上了，至于多播委托，其实跟单播的原理也差不多，所以我们的分析过程其实也差不多。就是分析 &quot;DECLARE_MULTICATE_DELEGATE&quot;，&quot;AddUObject&quot; 和 &quot;Broadcast&quot; 的实现就可以了。</p><h3 id="multicastdelegate"><a class="anchor" href="#multicastdelegate">#</a> MulticastDelegate</h3><p>因为跟单播的原理非常相似，以下分析略过一些相似的部分</p><h4 id="declare_multicast_delegate"><a class="anchor" href="#declare_multicast_delegate">#</a> DECLARE_MULTICAST_DELEGATE</h4><p></p><figure class="highlight c++"><figcaption><span>DECLARE_MULTICAST_DELEGATE</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateCombinations.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_MULTICAST_DELEGATE( DelegateName ) FUNC_DECLARE_MULTICAST_DELEGATE( DelegateName, void )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNC_DECLARE_MULTICAST_DELEGATE( MulticastDelegateName, ReturnType, ... ) \</span></span><br><span class="line"><span class="meta">	typedef TMulticastDelegate<span class="meta-string">&lt;ReturnType(__VA_ARGS__)&gt;</span> MulticastDelegateName;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有函数签名的多播将直接触发断言</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DelegateSignature, <span class="keyword">typename</span> UserPolicy = FDefaultDelegateUserPolicy&gt;</span><br><span class="line">class TMulticastDelegate</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(DelegateSignature) == <span class="number">0</span>, <span class="string">&quot;Expected a function signature for the delegate template parameter&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有返回值类型的多播将直接触发断言</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RetValType, <span class="keyword">typename</span>... ParamTypes, <span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TMulticastDelegate</span>&lt;</span><span class="built_in">RetValType</span>(ParamTypes...), UserPolicy&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(RetValType) == <span class="number">0</span>, <span class="string">&quot;The return type of a multicast delegate must be void&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多播最外层类，继承于 &quot;TMulticastDelegateBase&lt;&gt;&quot;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ParamTypes, <span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TMulticastDelegate</span>&lt;</span><span class="built_in"><span class="keyword">void</span></span>(ParamTypes...), UserPolicy&gt; : <span class="keyword">public</span> UserPolicy::FMulticastDelegateExtras</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老朋友了(如果重写代理策略，记得也要重写定义新代理类的宏)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FDefaultDelegateUserPolicy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">using</span> FDelegateInstanceExtras  = IDelegateInstance;</span><br><span class="line">	<span class="keyword">using</span> FDelegateExtras          = FDelegateBase;</span><br><span class="line">	<span class="keyword">using</span> FMulticastDelegateExtras = TMulticastDelegateBase&lt;FDefaultDelegateUserPolicy&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多播最最底层的基类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TMulticastDelegateBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> InvocationListType = TArray&lt;TDelegateBase&lt;UserPolicy&gt;, FMulticastInvocationListAllocatorType&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 保存要调用的委托实例的数组 */</span></span><br><span class="line">	InvocationListType InvocationList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 用于 移除委托实例后，收缩 &quot;InvocationList&quot;. */</span></span><br><span class="line">	int32 CompactionThreshold;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** &quot;InvocationList&quot; 锁计数器 */</span></span><br><span class="line">	<span class="keyword">mutable</span> int32 InvocationListLockCount;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看出，多播相较于单播，只是多维护了一个 &quot;InvocationList&quot;（观察者模式）后面的 &quot;AddUObject&quot;，&quot;Broadcast&quot; 等操作，都是围绕 &quot;Invocation&quot; 展开的。</p><h4 id="adduobject"><a class="anchor" href="#adduobject">#</a> AddUObject</h4><p></p><figure class="highlight c++"><figcaption><span>MulticastDelegate.Add</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateSignatureImpl.inl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UserClass, <span class="keyword">typename</span>... VarTypes&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> FDelegateHandle <span class="title">AddUObject</span><span class="params">(UserClass* InUserObject, <span class="keyword">typename</span> TMemFunPtrType&lt;<span class="literal">false</span>, UserClass, <span class="keyword">void</span> (ParamTypes..., VarTypes...)&gt;::Type InFunc, VarTypes... Vars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(!TIsConst&lt;UserClass&gt;::Value, <span class="string">&quot;Attempting to bind a delegate with a const object pointer and non-const member function.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 &quot;CreateUObejct&quot; 跟单播的是一样的，不做赘述</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Add</span>(FDelegate::<span class="built_in">CreateUObject</span>(InUserObject, InFunc, Vars...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的 Add... 函数最终都会调用这一条函数，不同的 Add... 函数只是对 &quot;FDelegate&quot; 的初始化有所不同</span></span><br><span class="line"><span class="function">FDelegateHandle <span class="title">Add</span><span class="params">(FDelegate&amp;&amp; InNewDelegate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FDelegateHandle Result;</span><br><span class="line">    <span class="keyword">if</span> (Super::<span class="built_in">GetDelegateInstanceProtectedHelper</span>(InNewDelegate))</span><br><span class="line">    &#123;</span><br><span class="line">        Result = Super::<span class="built_in">AddDelegateInstance</span>(<span class="built_in">MoveTemp</span>(InNewDelegate));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没错，又是刚刚那个存着委托实例数组的类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> UserPolicy&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TMulticastDelegateBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> InvocationListType = TArray&lt;TDelegateBase&lt;UserPolicy&gt;, FMulticastInvocationListAllocatorType&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> FDelegateHandle <span class="title">AddDelegateInstance</span><span class="params">(TDelegateBase&lt;UserPolicy&gt;&amp;&amp; NewDelegateBaseRef)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 收缩 &quot;InvocationList&quot; 数组</span></span><br><span class="line">		<span class="built_in">CompactInvocationList</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 保留 &quot;DelegateHandle&quot;，用于后续对该委托实例的操作</span></span><br><span class="line">		FDelegateHandle Result = NewDelegateBaseRef.<span class="built_in">GetHandle</span>();</span><br><span class="line">        <span class="comment">// 往 &quot;InvocationList&quot; 添加代理实例</span></span><br><span class="line">		InvocationList.<span class="built_in">Add</span>(<span class="built_in">MoveTemp</span>(NewDelegateBaseRef));</span><br><span class="line">		<span class="keyword">return</span> Result;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收缩 &quot;InvocationList&quot; 数组</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CompactInvocationList</span><span class="params">(<span class="keyword">bool</span> CheckThreshold=<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 上锁则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (InvocationListLockCount &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 收缩阈值大于 &quot;InvocationList&quot; 内元素的数量，则无需收缩，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (CheckThreshold 	&amp;&amp; --CompactionThreshold &gt; InvocationList.<span class="built_in">Num</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		int32 OldNumItems = InvocationList.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将空代理和不可用代理移除掉</span></span><br><span class="line">		<span class="keyword">for</span> (int32 InvocationListIndex = <span class="number">0</span>; InvocationListIndex &lt; InvocationList.<span class="built_in">Num</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span>&amp; DelegateBaseRef = InvocationList[InvocationListIndex];</span><br><span class="line"></span><br><span class="line">			IDelegateInstance* DelegateInstance = DelegateBaseRef.<span class="built_in">GetDelegateInstanceProtected</span>();</span><br><span class="line">			<span class="keyword">if</span> (DelegateInstance == <span class="literal">nullptr</span>	|| DelegateInstance-&gt;<span class="built_in">IsCompactable</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				InvocationList.<span class="built_in">RemoveAtSwap</span>(InvocationListIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				InvocationListIndex++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		CompactionThreshold = FMath::<span class="built_in">Max</span>(<span class="number">2</span>, <span class="number">2</span> * InvocationList.<span class="built_in">Num</span>());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (OldNumItems &gt; CompactionThreshold)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 压缩 &quot;InvocationList&quot;</span></span><br><span class="line">			InvocationList.<span class="built_in">Shrink</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>没错，其实就是对 &quot;InvocationList&quot; 的一些操作而已，&quot;CreateUObject&quot; 都还是跟单播的一样。</p><p>最后是 &quot;Broadcast&quot;（其实也跟 Execute 差不多...）</p><h4 id="broadcast"><a class="anchor" href="#broadcast">#</a> Broadcast</h4><p></p><figure class="highlight c++"><figcaption><span>Broadcast</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelegateSignatureImpl.inl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Broadcast</span><span class="params">(ParamTypes... Params)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> NeedsCompaction = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;TMulticastDelegateBase&quot; 基类中的锁计数器加1，上锁后不能收缩代理</span></span><br><span class="line">    Super::<span class="built_in">LockInvocationList</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取代理实例列表</span></span><br><span class="line">        <span class="keyword">const</span> InvocationListType&amp; LocalInvocationList = Super::<span class="built_in">GetInvocationList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以相反的顺序调用绑定函数，因此会忽略同一时刻添加进来的任何实例</span></span><br><span class="line">        <span class="keyword">for</span> (int32 InvocationListIndex = LocalInvocationList.<span class="built_in">Num</span>() - <span class="number">1</span>; InvocationListIndex &gt;= <span class="number">0</span>; --InvocationListIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这个下行转换是被允许的！允许在基类中管理调用列表，而不需要虚函数</span></span><br><span class="line">            <span class="keyword">const</span> FDelegate&amp; DelegateBase = (<span class="keyword">const</span> FDelegate&amp;)LocalInvocationList[InvocationListIndex];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 &quot;IDelegateInstance&quot;，&quot;GetDelegateInstanceProtectedHelper&quot; 里面只是调用了 &quot;GetDelegateInstanceProtected&quot;，跟单播一样</span></span><br><span class="line">            IDelegateInstance* DelegateInstanceInterface = Super::<span class="built_in">GetDelegateInstanceProtectedHelper</span>(DelegateBase);</span><br><span class="line">            <span class="comment">// 如果 &quot;DelegateInstanceInterface&quot; 为空或不能安全运行，则在运行后进行代理实例的清理</span></span><br><span class="line">            <span class="comment">// 这里的 &quot;ExecuteIfSafe&quot; 是真正运行每个代理的函数，跟单播一样。</span></span><br><span class="line">            <span class="keyword">if</span> (DelegateInstanceInterface == <span class="literal">nullptr</span> || !((DelegateInstanceInterfaceType*)DelegateInstanceInterface)-&gt;<span class="built_in">ExecuteIfSafe</span>(Params...))</span><br><span class="line">            &#123;</span><br><span class="line">                NeedsCompaction = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁，&quot;TMulticastDelegateBase&quot; 基类中的锁计数器减1</span></span><br><span class="line">    Super::<span class="built_in">UnlockInvocationList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NeedsCompaction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;TMulticastDelegate*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">CompactInvocationList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;Broadcast&quot; 比 &quot;ExcuteIfSafe&quot; 多的操作也只是上锁，遍历和收缩。剩下就是获取代理信息的简单函数，这里不再展开了。最后我们总结一下吧：</p><ol><li>首先，使用宏声明代理的时候，我们只是定义了一个代理类 &quot;TDelegate&quot;，并根据我我们定义的代理的参数个数和返回值，确定 &quot;TDelegate&quot; 的函数签名，这里的 &quot;UserPolicy&quot;(代理策略) 我们一般情况下用的是默认的，如果重新定义，需要把里面的三个类全部定义好</li><li>当我们 &quot;BindUObject&quot; 的时候，程序会用传进来的参数，在咱的代理对象的父类中构造一个 &quot;IDelegateInstance&quot; 对象，里面存的数据包括：&quot;UserObject&quot;(TWeakObjectPtr) , MethodPtr (FMethodPtr) , Payload (TTuple) , Handle (FDelegateHandle)</li><li>最后咱调用 &quot;Execute&quot;，实际上是在调用 &quot;Payload&quot; 中的 &quot;Invoke&quot;，&quot;Invoke&quot; 的实现有四种，分别对应不同的使用场景。&quot;Payload&quot; 中的参数会在 &quot;Invoke&quot; 的末尾传进去。&quot;Invoke&quot; 的调用实际上是利用了函数指针，加不定参数来完成的。</li></ol><p>到这里，咱 ue 代理的旅程也差不多该结束了，如果有什么地方讲得还是不够清除，或者有不明白的地方，可以在下面留言 看到我就回复（溜啦溜啦 😃</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-11-26 09:27:53" itemprop="dateModified" datetime="2021-11-26T09:27:53+08:00">2021-11-26</time> </span><span id="2021/11/11/UE4/UE4CPP/UE4代理的实现与用法/" class="item leancloud_visitors" data-flag-title="UE4代理的实现与用法" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" title="UE4代理的实现与用法">https://kotori_suki.github.io/2021/11/11/UE4/UE4CPP/UE4代理的实现与用法/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipew28b65j20zk0m8hdt.jpg" title="UClass的诞生与成长"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>UClass的诞生与成长</h3></a></div><div class="item right"><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipew28b65j20zk0m8hdt.jpg" title="FProperty的分析与总结"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>FProperty的分析与总结</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ue4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">UE4 代理的实现与用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">代理的使用总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.1.</span> <span class="toc-text">代理的类型及说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.2.</span> <span class="toc-text">代理的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">代理的绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">代理的触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E8%A7%A3%E7%BB%91"><span class="toc-number">1.1.5.</span> <span class="toc-text">代理的解绑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%9C%A8%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">代理在源码中的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-declare_delegate-%E5%87%BA%E5%8F%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">从 DECLARE_DELEGATE () 出发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-binduobject"><span class="toc-number">1.2.2.</span> <span class="toc-text">理解 BindUObject ()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#binduobject"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">BindUObject</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B-execute"><span class="toc-number">1.3.</span> <span class="toc-text">开始 Execute</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#multicastdelegate"><span class="toc-number">1.3.1.</span> <span class="toc-text">MulticastDelegate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#declare_multicast_delegate"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">DECLARE_MULTICAST_DELEGATE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adduobject"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">AddUObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#broadcast"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Broadcast</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li class="active"><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li><li><a href="/2021/11/26/UE4/UE4CPP/Unreal%20Slate/" rel="bookmark" title="Unreal Slate">Unreal Slate</a></li><li><a href="/2021/12/01/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20%E6%80%BB%E8%A7%88%20&%20UEngine%20&%20UGameInstance/" rel="bookmark" title="Gameplay —— 总览 & UEngine & UGameInstance">Gameplay —— 总览 & UEngine & UGameInstance</a></li><li><a href="/2021/12/03/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20FWorldContext%20&%20UWorld%20&%20ULevel/" rel="bookmark" title="Gameplay —— FWorldContext & UWorld & ULevel">Gameplay —— FWorldContext & UWorld & ULevel</a></li><li><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" rel="bookmark" title="Gameplay —— AActor & UActorComponent">Gameplay —— AActor & UActorComponent</a></li><li><a href="/2021/12/09/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20APawn%20&%20AController%20&%20APlayerController/" rel="bookmark" title="Gameplay —— APawn & AController & APlayerController">Gameplay —— APawn & AController & APlayerController</a></li><li><a href="/2021/12/12/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AGameMode%20&%20AGameState%20&%20APlayerState/" rel="bookmark" title="Gameplay —— AGameMode & AGameState & APlayerState">Gameplay —— AGameMode & AGameState & APlayerState</a></li><li><a href="/2021/12/15/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20USavegame%20&%20UPlayer/" rel="bookmark" title="Gameplay —— USavegame & UPlayer">Gameplay —— USavegame & UPlayer</a></li><li><a href="/2021/12/17/UE4/UE4CPP/Unreal%20GAS%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal GAS 源码解析">Unreal GAS 源码解析</a></li><li><a href="/2021/12/28/UE4/UE4CPP/CustomItemModule/" rel="bookmark" title="Custom Item Module">Custom Item Module</a></li><li><a href="/2021/12/30/UE4/UE4CPP/Unreal%20%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="Unreal 异步与并行编程">Unreal 异步与并行编程</a></li><li><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></li><li><a href="/2022/01/08/UE4/UE4CPP/Unreal%20%E8%93%9D%E5%9B%BE%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" rel="bookmark" title="Unreal 蓝图底层实现机制">Unreal 蓝图底层实现机制</a></li><li><a href="/2022/02/12/UE4/UE4CPP/Unreal%20%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/" rel="bookmark" title="Unreal MotionMatching">Unreal MotionMatching</a></li><li><a href="/2022/03/15/UE4/UE4CPP/Unreal%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E4%B9%8B%E4%B8%80/" rel="bookmark" title="Unreal 常用接口源码分析 之一">Unreal 常用接口源码分析 之一</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">57</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/17/CPPBase/DesignPattern/SimpleFactory/" title="简单工厂模式">简单工厂模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/17/CPPBase/DesignPattern/AbstractFactory/" title="抽象工厂模式">抽象工厂模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2022/01/03/UE4/UE4CPP/Unreal%20MovementComponent%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Unreal MovementComponent 源码解析">Unreal MovementComponent 源码解析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 结构型模式">结构型模式</a></div><span><a href="/2021/08/18/CPPBase/DesignPattern/Proxy/" title="代理模式">代理模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" title="反射系统API  解析和使用">反射系统API 解析和使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/Gameplay/" title="分类于 Gameplay">Gameplay</a></div><span><a href="/2021/12/06/UE4/UE4CPP/Gameplay%20%E2%80%94%E2%80%94%20AActor%20&%20UActorComponent/" title="Gameplay —— AActor &amp; UActorComponent">Gameplay —— AActor & UActorComponent</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" title="Unreal 序列化~~~">Unreal 序列化~~~</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/unreal%20%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="unreal引擎启动流程">unreal引擎启动流程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2022/03/15/UE4/UE4CPP/Unreal%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E4%B9%8B%E4%B8%80/" title="Unreal 常用接口源码分析 之一">Unreal 常用接口源码分析 之一</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/11/11/UE4/UE4CPP/UE4代理的实现与用法/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>