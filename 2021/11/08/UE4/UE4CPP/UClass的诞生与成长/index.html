<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/atom.xml"><link rel="alternate" type="application/json" title="一个年轻人奔向梦想的足迹" href="https://kotori_suki.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://kotori_suki.github.io/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/"><title>UClass的诞生与成长 - UE4_C++ - UE4 | Afei's Blog = 一个年轻人奔向梦想的足迹 = Welcome to my blog !</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">UClass的诞生与成长</h1><div class="meta"><span class="item" title="创建时间：2021-11-08 11:02:38"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-11-08T11:02:38+08:00">2021-11-08</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Afei's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph47e9vtj20zk0m8x6l.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevgoki5j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/" itemprop="item" rel="index" title="分类于 UE4"><span itemprop="name">UE4</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE4/UE4CPP/" itemprop="item" rel="index" title="分类于 UE4_C++"><span itemprop="name">UE4_C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://kotori_suki.github.io/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="-YIFEI-"><meta itemprop="description" content="Welcome to my blog !, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一个年轻人奔向梦想的足迹"></span><div class="body md" itemprop="articleBody"><h1 id="uclass的诞生与成长"><a class="anchor" href="#uclass的诞生与成长">#</a> UClass 的诞生与成长</h1><p>简介：本篇将对 &quot;UClass&quot; 的构造和初始化进行解析，同时也会涉及到 &quot;UClass&quot; 中的所有属性和函数的解析。为什么会想到去研究 &quot;UClass&quot; 呢？主要是因为源码中很多函数的实现，都用到了 &quot;UClass&quot; 中的反射信息。如果想深入地了解这个函数，那就得先了解这个 &quot;UClass&quot; 里面都有些什么属性，又是怎么工作的。让我们开始吧 😃</p><p>前置知识：</p><ol start="2"><li>了解 &quot;UHT&quot; 的编译过程</li><li>了解 &quot;SparseClassData&quot; 结构体 （宏中对其进行处理）</li><li>了解 &quot;RPC&quot; 函数 （宏中对其进行处理）</li><li>了解 &quot;StaticAutoRegister&quot; 设计模式</li><li>了解 &quot;反射机制&quot; 的概念与作用</li><li>了解 &quot;GC&quot; 的过程，包括用到的一些结构体和函数</li></ol><h2 id="uclass-简介"><a class="anchor" href="#uclass-简介">#</a> UClass 简介</h2><p>首先，&quot;UClass&quot; 是描述一个类的类，是存储 UObject 类及其子类的反射信息的类，可以说是 UE 整个放射系统的核心。以下是 &quot;UClass&quot; 的继承关系图（引自<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDc5MDM4Ng=="> InsideUE4</span>），我们只对 &quot;UClass&quot; 进行展开，当然也会涉及到 &quot;UObject&quot; 的解析。其他分支其实也类似，留给读者自己探究。</p><p><img data-src="UClass%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.jpg" alt="UClass继承关系"></p><h2 id="从-generated_body-开始"><a class="anchor" href="#从-generated_body-开始">#</a> 从 &quot;GENERATED_BODY ()&quot; 开始</h2><p>&quot;UClass&quot; 是用来存储引擎生成的反射信息的，而反射代码的生成又是从 &quot;GENERATED_BODY ()&quot; 开始的，自然我们需要回顾一下这个宏（只总结宏定义，详细的溯源过程建议看 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNTA5ODY4NQ==">类型系统代码生成</span>）</p><p><code>GENERATED_BODY()</code> 宏展开后是 <code>&quot;ProjectName_Source_ProjectName_ClassName_h_11_GENERATED_BODY&quot;</code> (&quot;ProjectName&quot;是我们的项目名，&quot;ClassPath&quot;是我们类的相对路径，11 是&quot;GENERATED_BODY ()&quot; 所在的行号 )，其宏定义如下：</p><p></p><figure class="highlight c++"><figcaption><span>GENERATED_BODY</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ProjectName_Source_ProjectName_ClassPath_h_11_GENERATED_BODY \</span></span><br><span class="line"><span class="meta">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">	ProjectName_Source_ProjectName_ClassPath_h_11_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">	ProjectName_Source_ProjectName_ClassPath_h_11_SPARSE_DATA \</span></span><br><span class="line"><span class="meta">	ProjectName_Source_ProjectName_ClassPath_h_11_RPC_WRAPPERS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">	ProjectName_Source_ProjectName_ClassPath_h_11_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">	ProjectName_Source_ProjectName_ClassPath_h_11_ENHANCED_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span></span><br></pre></td></tr></table></figure><p></p><p>以下对各个宏进行简单介绍：</p><ul><li><p>&quot;PRIVATE_PROPERTY_OFFSET&quot;，该宏<strong>定义 获取该类的私有属性的偏移量的函数</strong>（每个私有属性各生成一条），如：</p><p></p><figure class="highlight c++"><figcaption><span>PRIVATE_PROPERTY_OFFSET</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ProjectName_Source_ClassPath_ClassName_h_11_PRIVATE_PROPERTY_OFFSET \</span></span><br><span class="line"><span class="meta">	FORCEINLINE static uint32 __PPO__PropertyName() &#123; return STRUCT_OFFSET(UClassName, PropertyName); &#125; \</span></span><br></pre></td></tr></table></figure><p></p><p>其中 &quot;PropertyName&quot; 为 私有属性名（ &quot;private&quot; 或 &quot;protect&quot; ），&quot;UClassName&quot; 为 带前缀的类名</p></li><li><p>&quot;SPARSE_DATA&quot;，该宏<strong>定义 获取 &quot;SparseClassData&quot; 结构体，及该结构体内数据的函数</strong>，如：</p></li></ul><p></p><figure class="highlight c++"><figcaption><span>SPARSE_DATA</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ProjectName_Source_ClassPath_ClassName_h_11_SPARSE_DATA \</span></span><br><span class="line"><span class="meta">FMySparseClassData* GetMySparseClassData() \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return (FMySparseClassData*)(GetClass()-&gt;GetOrCreateSparseClassData()); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">FMySparseClassData* GetMySparseClassData() const \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return (FMySparseClassData*)(GetClass()-&gt;GetOrCreateSparseClassData()); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">int32 GetMyIntProperty() \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return GetMySparseClassData()-&gt;MyIntProperty; \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">int32 GetMyIntProperty() const \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return GetMySparseClassData()-&gt;MyIntProperty; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>其中 &quot;FMySparseClassData&quot; 是一个 &quot;SparseClassData&quot; 结构体。这个宏会自动为我们生成一些获取 &quot;SparseClassData&quot; 数据的函数，以保证了我们的 &quot;UClass&quot; 中的 &quot;SparseClassData&quot; 属性能够正常使用。</p><ul><li>&quot;RPC_WRAPPERS_NO_PURE_DECLS&quot;，该宏<strong>定义 所有 &quot;RPC&quot; 函数的 &quot;Implementation&quot; 版本和 所有 &quot;UFUNCTION&quot; 函数的 &quot;exec&quot; 版本</strong>，如：</li></ul><p></p><figure class="highlight c++"><figcaption><span>RPC_WRAPPERS_NO_PURE_DECLS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ProjectName_Source_ClassPath_ClassName_h_11_RPC_WRAPPERS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">	virtual void MyRPCFunction_Implementation(int Param1, bool param2); \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">	DECLARE_FUNCTION(execMyUFunction); \</span></span><br></pre></td></tr></table></figure><p></p><p>其中 &quot;MyRPCFunction&quot; 是一条 &quot;RPC&quot; 函数，&quot;MyUFunction&quot; 是一条 &quot;UFunction&quot; ，&quot;DECLARE_FUNCTION&quot; 宏也很重要，下文会详细分析</p><ul><li><p>&quot;ENHANCED_CONSTRUCTORS&quot;，该宏<strong>定义 一个用于反射系统创建对象的构造函数包装器</strong>，因为类的构造函数不能用函数指针指向。其工作原理下文会分析，咱先看看这个宏的实现：</p><p></p><figure class="highlight c++"><figcaption><span>ENHANCED_CONSTRUCTORS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ProjectName_Source_ClassPath_ClassName_h_11_ENHANCED_CONSTRUCTORS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** 移动拷贝私有化，不应被调用 */</span> \</span></span><br><span class="line"><span class="meta">	NO_API UClassName(UClassName&amp;&amp;); \</span></span><br><span class="line"><span class="meta">	NO_API UClassName(const UClassName&amp;); \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** 热重载的构造函数及调用器 */</span> \</span></span><br><span class="line"><span class="meta">	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UClassName); \</span></span><br><span class="line"><span class="meta">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UClassName); \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** 定义一个用于反射系统创建对象的构造函数包装器，最终会存到UClass里面 */</span> \</span></span><br><span class="line"><span class="meta">	DEFINE_DEFAULT_CONSTRUCTOR_CALL(UClassName) </span></span><br></pre></td></tr></table></figure><p></p><p>每条函数都写了注释，不做赘述。</p></li><li><p>&quot;INCLASS_NO_PURE_DECLS&quot;，该宏比较复杂，而且跟 UClass 息息相关，咱对着源码来讲</p><p></p><figure class="highlight c++"><figcaption><span>INCLASS_NO_PURE_DECLS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ProjectName_Source_ClassPath_ClassName_h_11_INCLASS_NO_PURE_DECLS \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	<span class="comment">/* 定义在 &quot;ClassName.gen.cpp&quot; 中，用于将函数注册到 &quot;UClass&quot; 的函数表 &quot;NativeFunctionLookupTable&quot; 里面，只注册 &quot;exec&quot; 版本的函数，也就是非UFunction函数将不会进行注册，也不支持反射功能*/</span> \</span></span><br><span class="line"><span class="meta">	static void StaticRegisterNativesUClassName(); \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">    <span class="comment">/* 定义在 &quot;ClassName.gen.cpp&quot; 中的友元结构体，里面有构造该类的 &quot;UClass&quot;和 &quot;UPackage&quot; 的函数指针，还有一个结构体数组，以及一些生成反射代码要用的参数 */</span> \</span></span><br><span class="line"><span class="meta">	friend struct Z_Construct_UClass_UClassName_Statics; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* 该宏定义在 &quot;ObjectMacros.h&quot; 中，内容很多，很重要，下文介绍 */</span> \</span></span><br><span class="line"><span class="meta">	DECLARE_CLASS(UClassName, UObject, COMPILED_IN_FLAGS(0 | CLASS_Config), CASTCLASS_None, TEXT(<span class="meta-string">&quot;/Script/ProjectName&quot;</span>), NO_API) \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">    <span class="comment">/* 该宏定义在 &quot;ObjectMacros.h&quot; 中，定义两个函数以支持序列化 */</span> \</span></span><br><span class="line"><span class="meta">	DECLARE_SERIALIZER(UClassName)</span></span><br></pre></td></tr></table></figure><p></p><p>&quot;DECLARE_CLASS&quot; 跟 UClass 关系密切，在展开分析 &quot;DECLARE_CLASS&quot; 宏之前，我想提醒一下读者：</p><blockquote><p>以上的内容全部都是由 &quot;UHT&quot; 帮我们自动写到 &quot;ClassName.generated.h&quot; 文件中，再通过 &quot;GENERATED_BODY ()&quot; 宏把定义好的内容导入到 &quot;ClassName.h&quot; 中的。</p></blockquote><h3 id="declare_class"><a class="anchor" href="#declare_class">#</a> DECLARE_CLASS</h3><p>其宏定义如下：</p><p></p><figure class="highlight c++"><figcaption><span>DECLARE_CLASS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \</span></span><br><span class="line"><span class="meta">private: \</span></span><br><span class="line"><span class="meta">	<span class="comment">/* 移动复制私有化 */</span> \</span></span><br><span class="line"><span class="meta">    TClass&amp; operator=(TClass&amp;&amp;);   \</span></span><br><span class="line"><span class="meta">    TClass&amp; operator=(const TClass&amp;);   \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* 重要！&quot;StaticClass&quot; 函数的内部实现，下文详细展开 */</span> \</span></span><br><span class="line"><span class="meta">	TRequiredAPI static UClass* GetPrivateStaticClass(); \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** 属于此类的 #EClassFlags 位并集，具体可以查看 &quot;EClassFlags&quot; */</span> \</span></span><br><span class="line"><span class="meta">	enum &#123;StaticClassFlags=TStaticFlags&#125;; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** 基类的 &quot;typedef&quot; */</span> \</span></span><br><span class="line"><span class="meta">	typedef TSuperClass Super;\</span></span><br><span class="line"><span class="meta">	<span class="comment">/** 该类的 &quot;typedef&quot; */</span> \</span></span><br><span class="line"><span class="meta">	typedef TClass ThisClass;\</span></span><br><span class="line"><span class="meta">    <span class="comment">/** &quot;runtime&quot; 下返回引用该类的 &quot;UClass&quot; 对象 */</span> \</span></span><br><span class="line"><span class="meta">	inline static UClass* StaticClass() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return GetPrivateStaticClass(); \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** 返回该类所属的包 */</span> \</span></span><br><span class="line"><span class="meta">	inline static const TCHAR* StaticPackage() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return TPackage; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** Returns the static cast flags for this class */</span> \</span></span><br><span class="line"><span class="meta">    <span class="comment">/** 返回该类的 &quot;StaticCastFlags&quot;，用于检验是否 &quot;Cast&quot; 成功 */</span> \</span></span><br><span class="line"><span class="meta">	inline static EClassCastFlags StaticClassCastFlags() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return TStaticCastFlags; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** 仅限内部使用，外部可以使用 &quot;StaticConstructObject&quot; 函数来new对象 */</span> \</span></span><br><span class="line"><span class="meta">	inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br><span class="line"><span class="meta">	<span class="comment">/** 仅限内部使用，外部可以使用 &quot;StaticConstructObject&quot; 函数来new对象 */</span> \</span></span><br><span class="line"><span class="meta">	inline void* operator new( const size_t InSize, EInternal* InMem ) \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		return (void*)InMem; \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>到此，&quot;GENERATED_BODY ()&quot; 宏定义生成的代码已经全部简单介绍了一遍。上面定义的很多函数，在我们后面 &quot;UClass&quot; 的 收集和注册 中都会用到。</p></li></ul><hr><h2 id="回到uclass的构造"><a class="anchor" href="#回到uclass的构造">#</a> 回到 UClass 的构造</h2><p>ue 将 &quot;UClass&quot; 的构造分成了几个部分，大致可以总结为：<strong>收集</strong>，<strong>注册</strong>，<strong>延迟注册</strong>，<strong>后处理</strong>。</p><ul><li>收集：收集这个类的信息，如：类名，Size，Crc 等</li><li>注册：为 &quot;UClass&quot; 分配内存，对其进行构造，并初始化其大部分属性，最后添加到延迟处理的 TMap 里</li><li>延迟注册：为 &quot;UClass&quot; 设置所属包名和包标记，将其注册到全局的 &quot;FUObjectHashTables&quot; 中</li><li>后处理：为 &quot;UClass&quot; 生成 &quot;CDO&quot;，&quot;TokenStream&quot; 等（<strong>称其为后处理，只是因为这部分是在 PreInit 的后半部分进行的，且便于理解，但引擎里面这部分也是统一称为注册的。</strong></li></ul><p>可能这么说还是有点抽象，让我们先看看引擎的启动流程图（引自<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NzYxMTEzNw=="> InsideUE4</span>），再来分析都是什么时候做了什么吧 😃</p><p><img data-src="%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="引擎启动流程图"></p><h3 id="uclass的信息收集"><a class="anchor" href="#uclass的信息收集">#</a> UClass 的信息收集</h3><p>收集阶段是在 <strong>&quot;Static 初始化&quot;</strong>中完成的，引擎只会去收集我们再&quot;Build.cs&quot; 文件中所依赖的模块的类。所以不用担心没启用的模块也会被收集，从而增加无用的性能消耗的问题</p><p></p><figure class="highlight c++"><figcaption><span>收集</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClassName.gen.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义在 &quot;ObjectMacros&quot; 中，定义了一个用于收集 &quot;UClass&quot; 信息的全局静态对象 &quot;AutoInitialize##TClass&quot; 和一个用于注册的函数 &quot;TClass::GetPrivateStaticClass&quot;，收集阶段我们只需要关注全局静态对象，因为全局静态变量会在程序启动时，直接调用其构造函数，完成该类的 &quot;UClass&quot; 信息收集。这一步主要收集: 类名，Size，Crc等</span></span><br><span class="line"><span class="built_in">IMPLEMENT_CLASS</span>(UClassName, <span class="number">2305906519</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集该类的 &quot;UClass&quot; 的构造函数，并存到全局静态TArray &quot;DeferredCompiledInRegistration&quot; 中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FCompiledInDefer <span class="title">Z_CompiledInDefer_UClass_UMyClassName</span><span class="params">(Z_Construct_UClass_UMyClassName, &amp;UMyClassName::StaticClass, TEXT(<span class="string">&quot;/Script/ProjectName&quot;</span>), TEXT(<span class="string">&quot;UMyClassName&quot;</span>), <span class="literal">false</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>以下对上面两个宏具体展开</p><h4 id="implement_class"><a class="anchor" href="#implement_class">#</a> IMPLEMENT_CLASS</h4><p></p><figure class="highlight c++"><figcaption><span>IMPLEMENT_CLASS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectMacros.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_CLASS(TClass, TClassCrc) \</span></span><br><span class="line"><span class="meta">	<span class="comment">/* 收集 &quot;UClass&quot; 的 &quot;Size&quot; 等属性的静态对象 */</span> \</span></span><br><span class="line"><span class="meta">	static TClassCompiledInDefer<span class="meta-string">&lt;TClass&gt;</span> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \</span></span><br><span class="line"><span class="meta">	</span></span><br><span class="line">	<span class="comment">/* 省略&quot;GetPrivateStaticClass&quot; 函数，留到注册阶段分析 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClass&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TClassCompiledInDefer</span> :</span> <span class="keyword">public</span> FFieldCompiledInInfo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">TClassCompiledInDefer</span>(<span class="keyword">const</span> TCHAR* InName, SIZE_T InClassSize, uint32 InCrc)</span><br><span class="line">	: <span class="built_in">FFieldCompiledInInfo</span>(InClassSize, InCrc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UClassCompiledInDefer</span>(<span class="keyword">this</span>, InName, InClassSize, InCrc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* &quot;Register&quot; 和 &quot;ClassPackage&quot; 函数留到注册阶段分析 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UClassCompiledInDefer</span><span class="params">(FFieldCompiledInInfo* ClassInfo, <span class="keyword">const</span> TCHAR* Name, SIZE_T ClassSize, uint32 Crc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> FName CPPClassName = Name;</span><br><span class="line">    <span class="comment">// 这里省略一段 &quot;HotLoad&quot; 处理代码</span></span><br><span class="line">	<span class="built_in">GetDeferredClassRegistration</span>().<span class="built_in">Add</span>(ClassInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> TArray&lt;FFieldCompiledInInfo*&gt;&amp; <span class="title">GetDeferredClassRegistration</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> TArray&lt;FFieldCompiledInInfo*&gt; DeferredClassRegistration;</span><br><span class="line">	<span class="keyword">return</span> DeferredClassRegistration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FFieldCompiledInInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">FFieldCompiledInInfo</span>(SIZE_T InClassSize, uint32 InCrc)</span><br><span class="line">		: <span class="built_in">Size</span>(InClassSize)</span><br><span class="line">		, <span class="built_in">Crc</span>(InCrc)</span><br><span class="line">		, <span class="built_in">OldClass</span>(<span class="literal">nullptr</span>)</span><br><span class="line">		, <span class="built_in">bHasChanged</span>(<span class="literal">false</span>)</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>显而易见，&quot;IMPLEMENT_CLASS&quot; 宏 实际上就是再往 &quot;DeferredClassRegistration&quot; 静态数组里面 Add 一个记录了该类信息的 &quot;FFieldCompiledInInfo&quot; 结构体，这个结构体记录的数据比较少，只用于 &quot;注册&quot; 阶段。</p><h4 id="z_compiledindefer_uclass_umyclassname"><a class="anchor" href="#z_compiledindefer_uclass_umyclassname">#</a> Z_CompiledInDefer_UClass_UMyClassName</h4><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UMyClassName.gen.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;FCompiledInDefer&quot; 是用来收集 &quot;UClass&quot; 信息的类，利用全局静态对象在程序启动时就会自动进行构造的特性，调用其构造函数来收集信息</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FCompiledInDefer <span class="title">Z_CompiledInDefer_UClass_UMyClassName</span><span class="params">(Z_Construct_UClass_UMyClassName, &amp;UMyClassName::StaticClass, TEXT(<span class="string">&quot;/Script/ProjectName&quot;</span>), TEXT(<span class="string">&quot;UMyClassName&quot;</span>), <span class="literal">false</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FCompiledInDefer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">FCompiledInDefer</span>(class UClass *(*InRegister)(), class UClass *(*InStaticClass)(), <span class="keyword">const</span> TCHAR* PackageName, <span class="keyword">const</span> TCHAR* Name, <span class="keyword">bool</span> bDynamic, <span class="keyword">const</span> TCHAR* DynamicPackageName = <span class="literal">nullptr</span>, <span class="keyword">const</span> TCHAR* DynamicPathName = <span class="literal">nullptr</span>, <span class="built_in"><span class="keyword">void</span></span> (*InInitSearchableValues)(TMap&lt;FName, FName&gt;&amp;) = <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 是否正在编译动态类</span></span><br><span class="line">		<span class="keyword">if</span> (bDynamic)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">GetConvertedDynamicPackageNameToTypeName</span>().<span class="built_in">Add</span>(<span class="built_in">FName</span>(DynamicPackageName), <span class="built_in">FName</span>(Name));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">UObjectCompiledInDefer</span>(InRegister, InStaticClass, Name, PackageName, bDynamic, DynamicPathName, InInitSearchableValues);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UObjectCompiledInDefer</span><span class="params">(UClass *(*InRegister)(), UClass *(*InStaticClass)(), <span class="keyword">const</span> TCHAR* Name, <span class="keyword">const</span> TCHAR* PackageName, <span class="keyword">bool</span> bDynamic, <span class="keyword">const</span> TCHAR* DynamicPathName, <span class="keyword">void</span> (*InInitSearchableValues)(TMap&lt;FName, FName&gt;&amp;))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!bDynamic)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/* 省略热重载代码 */</span></span><br><span class="line">        <span class="comment">// 用该 &quot;UClass&quot; 的 &quot;Z_Construct&quot; 函数生成一个 &quot;FEDLBootObjectState&quot; 设置其属性后，存到 &quot;PathToState&quot; 中，用于异步包读取</span></span><br><span class="line">        <span class="function">FString <span class="title">NoPrefix</span><span class="params">(UObjectBase::RemoveClassPrefix(Name))</span></span>;</span><br><span class="line">        <span class="built_in">NotifyRegistrationEvent</span>(PackageName, *NoPrefix, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Added, (UObject *(*)())(InRegister), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">NotifyRegistrationEvent</span>(PackageName, *(<span class="built_in">FString</span>(DEFAULT_OBJECT_PREFIX) + NoPrefix), ENotifyRegistrationType::NRT_ClassCDO, ENotifyRegistrationPhase::NRP_Added, (UObject *(*)())(InRegister), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往 &quot;DeferredCompiledInRegistration&quot; 静态数组(单例)中添加咱的 &quot;UClass&quot; 的 &quot;Z_Construct&quot; 函数</span></span><br><span class="line">        TArray&lt;UClass *(*)()&gt;&amp; DeferredCompiledInRegistration = <span class="built_in">GetDeferredCompiledInRegistration</span>();</span><br><span class="line">        <span class="built_in">checkSlow</span>(!DeferredCompiledInRegistration.<span class="built_in">Contains</span>(InRegister));</span><br><span class="line">        DeferredCompiledInRegistration.<span class="built_in">Add</span>(InRegister);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 省略编译动态类代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>总的来说，这个静态全局变量 将 &quot;UClass&quot; 的 &quot;Z_Construct&quot; 函数 (用于初始化一些 &quot;UClass&quot; 的属性，但又不是传统意义上的构造函数) 和 &quot;PackageName&quot; 添加到异步包加载的 &quot;FEDLBootObjectManager&quot; 中，再将 &quot;UClass&quot; 的 &quot;Z_Construct&quot; 函数添加到 &quot;DeferredCompiledInRegistration&quot; 静态数组中，用于后面 &quot;UClass&quot; 构造。</p><p>不知道读者是否对 &quot;UClass&quot; 的 &quot;Z_Construct&quot; 函数是怎么定义的感兴趣，也就是这个宏 &quot;Z_Construct_UClass_UMyClassName&quot; 的定义，这个函数会在最后的 &quot;后处理阶段&quot; 被调用，先分析一下其实现：</p><h4 id="z_construct_uclass_umyclassname"><a class="anchor" href="#z_construct_uclass_umyclassname">#</a> Z_Construct_UClass_UMyClassName</h4><p></p><figure class="highlight c++"><figcaption><span>Z_Construct_UClass_UMyClassName</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClassName.gen.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">UClass* <span class="title">Z_Construct_UClass_UMyClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> UClass* OuterClass = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!OuterClass)</span><br><span class="line">    &#123;</span><br><span class="line">        UE4CodeGen_Private::<span class="built_in">ConstructUClass</span>(OuterClass, Z_Construct_UClass_UMyClassName_Statics::ClassParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OuterClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>看似简单，只是对一个单例 &quot;UClass&quot; 对象进行构造后处理而已，但其实里面别有洞天。其中 &quot;ConstructUClass&quot; 将处理我们 &quot;UClass&quot; 的很多属性的初始化，而 &quot;ClassParams&quot; 又是一个存着我们这个类所有属性的一个结构体。</p><h4 id="constructuclass"><a class="anchor" href="#constructuclass">#</a> ConstructUClass</h4><p></p><figure class="highlight c++"><figcaption><span>ConstructUClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectGlobals.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructUClass</span><span class="params">(UClass*&amp; OutClass, <span class="keyword">const</span> FClassParams&amp; Params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 该类对象存在，且已构造则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (OutClass &amp;&amp; (OutClass-&gt;ClassFlags &amp; CLASS_Constructed))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有依赖函数(主要是基类的 &quot;UClass&quot; 的构造函数和 &quot;UPackage&quot; 的构造函数)，迭代函数指针</span></span><br><span class="line">    <span class="keyword">for</span> (UObject* (*<span class="keyword">const</span> *SingletonFunc)() = Params.DependencySingletonFuncArray, *(*<span class="keyword">const</span> *SingletonFuncEnd)() = SingletonFunc + Params.NumDependencySingletons; SingletonFunc != SingletonFuncEnd; ++SingletonFunc)</span><br><span class="line">    &#123;</span><br><span class="line">        (*SingletonFunc)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上调用的是该类的 &quot;StaticClass&quot; 函数，&quot;StaticClass&quot; 并不会初始化属性链</span></span><br><span class="line">    UClass* NewClass = Params.<span class="built_in">ClassNoRegisterFunc</span>();</span><br><span class="line">    OutClass = NewClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NewClass-&gt;ClassFlags &amp; CLASS_Constructed)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;UClass&quot; 的注册函数，后文详细介绍</span></span><br><span class="line">    <span class="built_in">UObjectForceRegistration</span>(NewClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 &quot;ClassFlags&quot;，用于动态类型转换</span></span><br><span class="line">    UClass* SuperClass = NewClass-&gt;<span class="built_in">GetSuperClass</span>();</span><br><span class="line">    <span class="keyword">if</span> (SuperClass)</span><br><span class="line">    &#123;</span><br><span class="line">        NewClass-&gt;ClassFlags |= (SuperClass-&gt;ClassFlags &amp; CLASS_Inherit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记上之前存在 &quot;Params&quot; 里的标记和 &quot;CLASS_Constructed&quot; 标记</span></span><br><span class="line">    NewClass-&gt;ClassFlags |= (EClassFlags)(Params.ClassFlags | CLASS_Constructed);</span><br><span class="line">    <span class="comment">// 清空引用标记流，因为要在后面重构。</span></span><br><span class="line">    <span class="keyword">if</span> ((NewClass-&gt;ClassFlags &amp; CLASS_Intrinsic) != CLASS_Intrinsic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>((NewClass-&gt;ClassFlags &amp; CLASS_TokenStreamAssembled) != CLASS_TokenStreamAssembled);</span><br><span class="line">        NewClass-&gt;ReferenceTokenStream.<span class="built_in">Empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将之前用 &quot;ConstructUFunction&quot; 构造出来的函数链接起来，放到 &quot;Children&quot;(UProperty属性链)里面</span></span><br><span class="line">    NewClass-&gt;<span class="built_in">CreateLinkAndAddChildFunctionsToMap</span>(Params.FunctionLinkArray, Params.NumFunctions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造该类的所有 &quot;FProperty&quot;，用于后面的 &quot;StaticLink&quot;</span></span><br><span class="line">    <span class="built_in">ConstructFProperties</span>(NewClass, Params.PropertyArray, Params.NumProperties);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 &quot;UClass&quot; 的 &quot;ClassConfigName&quot; 属性 (该类对象读取数据的配置文件名)</span></span><br><span class="line">    <span class="keyword">if</span> (Params.ClassConfigNameUTF8)</span><br><span class="line">    &#123;</span><br><span class="line">        NewClass-&gt;ClassConfigName = <span class="built_in">FName</span>(<span class="built_in">UTF8_TO_TCHAR</span>(Params.ClassConfigNameUTF8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 &quot;CppClassInfo&quot; 属性 (是否抽象类)</span></span><br><span class="line">    NewClass-&gt;<span class="built_in">SetCppTypeInfoStatic</span>(Params.CppClassInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 &quot;UClass&quot; 的 &quot;Interfaces&quot; 数组，包括该 &quot;Interface&quot; 的 &quot;UClass&quot;，内存偏移，是否被蓝图重写</span></span><br><span class="line">    <span class="keyword">if</span> (int32 NumImplementedInterfaces = Params.NumImplementedInterfaces)</span><br><span class="line">    &#123;</span><br><span class="line">        NewClass-&gt;Interfaces.<span class="built_in">Reserve</span>(NumImplementedInterfaces);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> FImplementedInterfaceParams* ImplementedInterface = Params.ImplementedInterfaceArray, *ImplementedInterfaceEnd = ImplementedInterface + NumImplementedInterfaces; ImplementedInterface != ImplementedInterfaceEnd; ++ImplementedInterface)</span><br><span class="line">        &#123;</span><br><span class="line">            UClass* (*ClassFunc)() = ImplementedInterface-&gt;ClassFunc;</span><br><span class="line">            UClass* InterfaceClass = ClassFunc ? <span class="built_in">ClassFunc</span>() : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            NewClass-&gt;Interfaces.<span class="built_in">Emplace</span>(InterfaceClass, ImplementedInterface-&gt;Offset, ImplementedInterface-&gt;bImplementedByK2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元数据</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">    <span class="built_in">AddMetaData</span>(NewClass, Params.MetaDataArray, Params.NumMetaData);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态链接，不展开。在解析 &quot;FProperty&quot; 的博客中再做详细解析</span></span><br><span class="line">    NewClass-&gt;<span class="built_in">StaticLink</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化该类的对象共有数据 &quot;SparseClassData&quot;，一般情况下不可修改</span></span><br><span class="line">    NewClass-&gt;<span class="built_in">SetSparseClassDataStruct</span>(NewClass-&gt;<span class="built_in">GetSparseClassDataArchetypeStruct</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这一步是在 &quot;UClass&quot; 注册的后处理阶段进行的（创建 &quot;CDO&quot; 之前），为什么？为什么不能一开始就调用这个初始化咱的 &quot;UClass&quot; ？其实是因为 &quot;FClassParams&quot; 里面很多参数都没有构造，比如 &quot;UFunction&quot; 和 &quot;FProperty&quot; 的构造，就是在延迟注册中进行的。所以咱只能等到后处理阶段，参数都构造好了才能调用。以下是 &quot;FClassParams&quot; 的定义：</p><p></p><figure class="highlight c++"><figcaption><span>FClassParams</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectGlobals.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FClassParams</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// &quot;UClass&quot; 的构造函数指针</span></span><br><span class="line">    UClass*                                   (*ClassNoRegisterFunc)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置文件名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*                                 ClassConfigNameUTF8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Cpp类的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> FCppClassTypeInfoStatic*              CppClassInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依赖 &quot;UObject&quot; 的构造函数，通常是基类和包</span></span><br><span class="line">    UObject*                           (*<span class="keyword">const</span> *DependencySingletonFuncArray)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存着该类所有 &quot;UFunction&quot; 地址和函数名的映射的数组</span></span><br><span class="line">    <span class="keyword">const</span> FClassFunctionLinkInfo*               FunctionLinkArray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存着该类所有 &quot;FProperty&quot; 的 &quot;FPropertyParamBase&quot; 信息的数组</span></span><br><span class="line">    <span class="keyword">const</span> FPropertyParamsBase* <span class="keyword">const</span>*           PropertyArray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存着该类所有 &quot;UInterface&quot; 的 &quot;FImplementedInterfaceParams&quot; 信息的数组</span></span><br><span class="line">    <span class="keyword">const</span> FImplementedInterfaceParams*          ImplementedInterfaceArray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依赖 “UObject&quot; 个数</span></span><br><span class="line">    int32                                       NumDependencySingletons;</span><br><span class="line">    <span class="comment">// &quot;UFunction&quot; 个数</span></span><br><span class="line">    int32                                       NumFunctions;</span><br><span class="line">    <span class="comment">// “UProperty&quot; 个数</span></span><br><span class="line">    int32                                       NumProperties;</span><br><span class="line">    <span class="comment">// 继承 &quot;UInterface&quot; 个数</span></span><br><span class="line">    int32                                       NumImplementedInterfaces;</span><br><span class="line">    <span class="comment">// EClassFlags</span></span><br><span class="line">    uint32                                      ClassFlags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_METADATA</span></span><br><span class="line">    <span class="comment">// 存着该类所有的 &quot;MetaData&quot; 数据的数组</span></span><br><span class="line">    <span class="keyword">const</span> FMetaDataPairParam*                   MetaDataArray;</span><br><span class="line">    <span class="comment">// &quot;MetaData&quot; 个数</span></span><br><span class="line">    int32                                       NumMetaData;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><p>对上面的内容如果有不清晰其实也没关系，不影响后文理解。我们只要在读到后处理阶段的时候再回来看看就好了 😃</p><p>总结：通过类收集阶段，我们会得到两个数组。</p><ul><li>&quot;DeferredClassRegistration&quot; -&gt; 记录了所有需要注册的类的 &quot;类名&quot;，&quot;Size&quot;，&quot;Crc&quot;</li><li>&quot;DeferredCompiledInRegistration&quot; -&gt; 记录了所有类的 &quot;UClass&quot; 的构造函数，也可以理解为用于注册函数</li></ul><h3 id="uclass的注册"><a class="anchor" href="#uclass的注册">#</a> UClass 的注册</h3><p>&quot;UClass&quot; 的注册是集中在 &quot;<strong>UClassRegisterAllCompiledInClasses</strong>&quot; 中进行的，以下是其调用链：</p><p></p><figure class="highlight c++"><figcaption><span>FEngineLoop::PreInit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WinMain</span>() -&gt; <span class="built_in">GuardedMain</span>() -&gt; <span class="built_in">EnginePreInit</span>() -&gt; FEngineLoop::<span class="built_in">PreInit</span>() -&gt; <span class="built_in">PreInitPreStartupScreen</span>() -&gt; <span class="built_in">LoadCoreModules</span>() -&gt; FModuleManager::<span class="built_in">Get</span>().<span class="built_in">LoadModule</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;CoreUObject&quot;</span>)) -&gt; FModuleManager::<span class="built_in">LoadModuleWithFailureReason</span>() -&gt; StartupModule -&gt; <span class="built_in">UClassRegisterAllCompiledInClasses</span>()</span><br></pre></td></tr></table></figure><p></p><p>是不是很长？没错，就是很长。但上面的接口其实处理的事情远远不止 &quot;构造 UClass&quot;，还初始化了很多 Manager，设置游戏线程，加载 CoreModules 等等。我们 &quot;UClass&quot; 的注册其实只是冰山一角。千里之行始于足下，让我们先看看 &quot;UClassRegisterAllCompiledInClasses&quot; 里面都做了什么吧 ）</p><h4 id="uclassregisterallcompiledinclasses"><a class="anchor" href="#uclassregisterallcompiledinclasses">#</a> UClassRegisterAllCompiledInClasses</h4><p></p><figure class="highlight c++"><figcaption><span>UClassRegisterAllCompiledInClasses</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UClassRegisterAllCompiledInClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有收集阶段收集到的需要注册的 &quot;UClass&quot; 的信息，并调用其 &quot;Register&quot; 函数进行注册</span></span><br><span class="line">	TArray&lt;FFieldCompiledInInfo*&gt;&amp; DeferredClassRegistration = <span class="built_in">GetDeferredClassRegistration</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> FFieldCompiledInInfo* Class : DeferredClassRegistration)</span><br><span class="line">	&#123;</span><br><span class="line">		UClass* RegisteredClass = Class-&gt;<span class="built_in">Register</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空数组，以免重复注册</span></span><br><span class="line">	DeferredClassRegistration.<span class="built_in">Empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClass&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TClassCompiledInDefer</span> :</span> <span class="keyword">public</span> FFieldCompiledInInfo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> UClass* <span class="title">Register</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">// 调用 &quot;StaticClass&quot;，进行注册</span></span><br><span class="line">		<span class="keyword">return</span> TClass::<span class="built_in">StaticClass</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectMacros.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_CLASS(TClass, TClassCrc) \</span></span><br><span class="line"><span class="meta">	UClass* TClass::GetPrivateStaticClass() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		static UClass* PrivateStaticClass = NULL; \</span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">if</span> (!PrivateStaticClass) \</span></span><br><span class="line"><span class="meta">		&#123; \</span></span><br><span class="line"><span class="meta">			<span class="comment">/* 这里可以用模板，但为了避免代码冗余，就将其定义在了 &quot;ObjectMacros&quot; 里面 */</span> \</span></span><br><span class="line"><span class="meta">			GetPrivateStaticClassBody( \</span></span><br><span class="line"><span class="meta">				StaticPackage(), \</span></span><br><span class="line"><span class="meta">				(TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), \</span></span><br><span class="line"><span class="meta">				PrivateStaticClass, \</span></span><br><span class="line"><span class="meta">				StaticRegisterNatives##TClass, \</span></span><br><span class="line"><span class="meta">				sizeof(TClass), \</span></span><br><span class="line"><span class="meta">				alignof(TClass), \</span></span><br><span class="line"><span class="meta">				(EClassFlags)TClass::StaticClassFlags, \</span></span><br><span class="line"><span class="meta">				TClass::StaticClassCastFlags(), \</span></span><br><span class="line"><span class="meta">				TClass::StaticConfigName(), \</span></span><br><span class="line"><span class="meta">				(UClass::ClassConstructorType)InternalConstructor<span class="meta-string">&lt;TClass&gt;</span>, \</span></span><br><span class="line"><span class="meta">				(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<span class="meta-string">&lt;TClass&gt;</span>, \</span></span><br><span class="line"><span class="meta">				&amp;TClass::AddReferencedObjects, \</span></span><br><span class="line"><span class="meta">				&amp;TClass::Super::StaticClass, \</span></span><br><span class="line"><span class="meta">				&amp;TClass::WithinClass::StaticClass \</span></span><br><span class="line"><span class="meta">			); \</span></span><br><span class="line"><span class="meta">		&#125; \</span></span><br><span class="line"><span class="meta">		return PrivateStaticClass; \</span></span><br><span class="line"><span class="meta">	&#125; \</span></span><br></pre></td></tr></table></figure><p></p><p>不难发现，其实 &quot;UClassRegisterAllCompiledInClasses&quot; 就是再遍历我们之前收集的所有 &quot;UClass&quot; 信息，并逐个调用其 &quot;GetPrivateStaticClassBody&quot; 函数。以下对 &quot;GetPrivateStaticClassBody&quot; 函数进行解析 (好戏正式开始啦～～～)</p><h4 id="getprivatestaticclassbody"><a class="anchor" href="#getprivatestaticclassbody">#</a> GetPrivateStaticClassBody</h4><p></p><figure class="highlight c++"><figcaption><span>GetPrivateStaticClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrivateStaticClassBody</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TCHAR* PackageName,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TCHAR* Name,</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass*&amp; ReturnClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">void</span>(*RegisterNativeFunc)(),</span></span></span><br><span class="line"><span class="params"><span class="function">	uint32 InSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	uint32 InAlignment,</span></span></span><br><span class="line"><span class="params"><span class="function">	EClassFlags InClassFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	EClassCastFlags InClassCastFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TCHAR* InConfigName,</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass::ClassConstructorType InClassConstructor,</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass::ClassVTableHelperCtorCallerType InClassVTableHelperCtorCaller,</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass::ClassAddReferencedObjectsType InClassAddReferencedObjects,</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass::StaticClassFunctionType InSuperClassFn,</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass::StaticClassFunctionType InWithinClassFn,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">bool</span> bIsDynamic <span class="comment">/*= false*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	UDynamicClass::DynamicClassInitializerType InDynamicClassInitializerFn <span class="comment">/*= nullptr*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 忽略热重载和动态类的处理(类似) */</span></span><br><span class="line">    <span class="comment">// 获取全局UObject内存分配器，分配一块内存给咱的 &quot;UClass&quot;</span></span><br><span class="line">	ReturnClass = (UClass*)GUObjectAllocator.<span class="built_in">AllocateUObject</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(UClass), <span class="built_in"><span class="keyword">alignof</span></span>(UClass), <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 在刚刚分配的内存中构造咱的 &quot;UClass&quot; (UClass的构造函数下文分析)</span></span><br><span class="line">    ReturnClass = ::<span class="built_in"><span class="keyword">new</span></span> (ReturnClass)</span><br><span class="line">        <span class="built_in">UClass</span></span><br><span class="line">        (</span><br><span class="line">        EC_StaticConstructor,</span><br><span class="line">        Name,</span><br><span class="line">        InSize,</span><br><span class="line">        InAlignment,</span><br><span class="line">        InClassFlags,</span><br><span class="line">        InClassCastFlags,</span><br><span class="line">        InConfigName,</span><br><span class="line">        <span class="built_in">EObjectFlags</span>(RF_Public | RF_Standalone | RF_Transient | RF_MarkAsNative | RF_MarkAsRootSet),</span><br><span class="line">        InClassConstructor,</span><br><span class="line">        InClassVTableHelperCtorCaller,</span><br><span class="line">        InClassAddReferencedObjects</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">check</span>(ReturnClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化类的一些私有属性，做一些延迟注册的前置工作</span></span><br><span class="line">    <span class="built_in">InitializePrivateStaticClass</span>(</span><br><span class="line">        <span class="built_in">InSuperClassFn</span>(),</span><br><span class="line">        ReturnClass,</span><br><span class="line">        <span class="built_in">InWithinClassFn</span>(),</span><br><span class="line">        PackageName,</span><br><span class="line">        Name</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册类的本地函数 (源文件中的UFunction)，下文分析</span></span><br><span class="line">    <span class="built_in">RegisterNativeFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;GetPrivateStaticClassBody&quot; 其实就是申请了一块内存，然后在这块内存中构造咱的 &quot;UClass&quot;，最后再注册咱的本地函数。不知道读者有没有想过：<strong>为什么 UE 要在 &quot;CoreUObject&quot; 模块 &quot;Startup&quot; 后才为 &quot;UClass&quot; 申请内存并进行构造呢？<strong>其实是</strong>因为我们要为 &quot;UClass&quot; 申请内存空间，那就必须要用到 &quot;GUObjectAllocator&quot;，而这个 &quot;UObject 内存分配器&quot; 又是定义在 &quot;CoreUObject&quot; 模组中的一个全局对象</strong>，所以我们需要先加载 &quot;CoreUObject&quot; 模组，当然 &quot;CoreUObject&quot; 的作用远远不止这点，剩下的留到以后再探究吧 ）</p><p>咱先去看看 &quot;UClass 的构造函数&quot;，&quot;InitializePrivateStaticClass&quot; 和 &quot;RegisterNativeFunc&quot; 里都干了什么 😃</p><h4 id="uclassuclass"><a class="anchor" href="#uclassuclass">#</a> UClass::UClass</h4><p></p><figure class="highlight c++"><figcaption><span>UClass::UClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">UClass::<span class="built_in">UClass</span></span><br><span class="line">(</span><br><span class="line">	EStaticConstructor,</span><br><span class="line">	FName			InName,</span><br><span class="line">	uint32			InSize,</span><br><span class="line">	uint32			InAlignment,</span><br><span class="line">	EClassFlags		InClassFlags,</span><br><span class="line">	EClassCastFlags	InClassCastFlags,</span><br><span class="line">	<span class="keyword">const</span> TCHAR*    InConfigName,</span><br><span class="line">	EObjectFlags	InFlags,</span><br><span class="line">	ClassConstructorType InClassConstructor,</span><br><span class="line">	ClassVTableHelperCtorCallerType InClassVTableHelperCtorCaller,</span><br><span class="line">	ClassAddReferencedObjectsType InClassAddReferencedObjects</span><br><span class="line">)</span><br><span class="line">    <span class="comment">// 初始化基类Struct</span></span><br><span class="line">:	<span class="built_in">UStruct</span>					( EC_StaticConstructor, InSize, InAlignment, InFlags )</span><br><span class="line">    <span class="comment">// 反射用的 包装了该类的构造函数的 函数指针</span></span><br><span class="line">,	<span class="built_in">ClassConstructor</span>		( InClassConstructor )</span><br><span class="line">    <span class="comment">// 包装了该类的热重载时调用的构造函数的 函数指针</span></span><br><span class="line">,	<span class="built_in">ClassVTableHelperCtorCaller</span>(InClassVTableHelperCtorCaller)</span><br><span class="line">    <span class="comment">// 指向定义在 &quot;UObject&quot; 中的虚函数 &quot;AddReferencedObjects&quot; </span></span><br><span class="line">,	<span class="built_in">ClassAddReferencedObjects</span>( InClassAddReferencedObjects )</span><br><span class="line">    <span class="comment">// 类伪唯一计数器；用于加速唯一实例名称的生成 (uint32)</span></span><br><span class="line">,	<span class="built_in">ClassUnique</span>				( <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// 该类是否已被烘焙 (bool)</span></span><br><span class="line">,	<span class="built_in">bCooked</span>					( <span class="literal">false</span> )</span><br><span class="line">    <span class="comment">// 描述一个类的Flags，详见EClassFlags (EClassFlags)</span></span><br><span class="line">,	<span class="built_in">ClassFlags</span>				( InClassFlags | CLASS_Native )</span><br><span class="line">    <span class="comment">// 用于UObject的动态类型转换 (EClassCastFlags)</span></span><br><span class="line">,	<span class="built_in">ClassCastFlags</span>			( InClassCastFlags )</span><br><span class="line">    <span class="comment">// 类的外部实例的类型 (UClass*)</span></span><br><span class="line">,	<span class="built_in">ClassWithin</span>				( <span class="literal">nullptr</span> )</span><br><span class="line">    <span class="comment">// 生成该类的蓝图，如果生成该类的是C++类则为空 (UObject*)</span></span><br><span class="line">,	<span class="built_in">ClassGeneratedBy</span>		( <span class="literal">nullptr</span> )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> WITH_EDITORONLY_DATA</span></span><br><span class="line">    <span class="comment">// 在PurgeClass中无法销毁的 此类销毁时要销毁的属性的链接列表 (FField*)</span></span><br><span class="line">,	<span class="built_in">PropertiesPendingDestruction</span>( <span class="literal">nullptr</span> )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 记录该类的配置信息的 Name.ini 文件名 (FName)</span></span><br><span class="line">,	<span class="built_in">ClassConfigName</span>			()</span><br><span class="line">    <span class="comment">// 网络相关的字段(函数)列表 (TArray&lt;UField*&gt;)</span></span><br><span class="line">,	<span class="built_in">NetFields</span>				()</span><br><span class="line">    <span class="comment">// CDO</span></span><br><span class="line">,	<span class="built_in">ClassDefaultObject</span>		( <span class="literal">nullptr</span> )</span><br><span class="line">    <span class="comment">// 指向我们自定义的 &quot;SparseClassData&quot; 结构体的实例的指针 (void*)</span></span><br><span class="line">,	<span class="built_in">SparseClassData</span>			( <span class="literal">nullptr</span> )</span><br><span class="line">    <span class="comment">// 指向我们自定义的 &quot;SparseClassData&quot; 结构体的类型信息的指针 (void*)</span></span><br><span class="line">,	<span class="built_in">SparseClassDataStruct</span>	( <span class="literal">nullptr</span> )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果你改源码，在这里添加了其他的property，请同步更新其他的构造函数和PurgeClass()</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义特定C++类的特性 (该C++类是否为抽象类，默认为false)</span></span><br><span class="line">	<span class="built_in">SetCppTypeInfoStatic</span>(&amp;DefaultCppClassTypeInfoStatic);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这是一个不匹配的类型的强制转换，用于 &quot;UClass::DeferredRegister&quot;函数中，&quot;ClassConfigName&quot; 指明要从哪个 &quot;Name.ini&quot; 文件中读取配置变量</span></span><br><span class="line">	*(<span class="keyword">const</span> TCHAR**)&amp;ClassConfigName = InConfigName; <span class="comment">//-V580</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以上是 &quot;UClass&quot; 的构造函数和一些重要属性，既然是对 &quot;UClass&quot; 进行解析的博客，自然是不能跳过的。&quot;UClass&quot; 算是构造好了，但从上面可以看出，其实 &quot;UClass&quot; 中的很多属性都是没有赋值的。比如：&quot;Name&quot;，&quot;ClassWithin&quot;，&quot;CDO&quot; 等。不着急，咱一步一步来，慢工出细活 )</p><p>下面开始为咱刚刚构造的 &quot;UClass&quot; 填充更多的内容，让我们开始吧～～～</p><h4 id="initializeprivatestaticclass"><a class="anchor" href="#initializeprivatestaticclass">#</a> InitializePrivateStaticClass</h4><p></p><figure class="highlight c++"><figcaption><span>InitializePrivateStaticClass</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">COREUOBJECT_API <span class="keyword">void</span> <span class="title">InitializePrivateStaticClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	class UClass* TClass_Super_StaticClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	class UClass* TClass_PrivateStaticClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	class UClass* TClass_WithinClass_StaticClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TCHAR* PackageName,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TCHAR* Name</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用通知注册事件，改变该类在 &quot;PathToState&quot; 中的状态，用于异步包读取</span></span><br><span class="line">	<span class="built_in">NotifyRegistrationEvent</span>(PackageName, Name, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Started);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &quot;SetSuperStruct&quot; 里面回调用 &quot;Super::SetSuperStruct&quot; 来维护这个类的继承链，也是为了避免进入递归死循环，函数解析在下面 */</span></span><br><span class="line">	<span class="keyword">if</span> (TClass_Super_StaticClass != TClass_PrivateStaticClass)</span><br><span class="line">	&#123;</span><br><span class="line">		TClass_PrivateStaticClass-&gt;<span class="built_in">SetSuperStruct</span>(TClass_Super_StaticClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		TClass_PrivateStaticClass-&gt;<span class="built_in">SetSuperStruct</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 咱现在的 &quot;UClass&quot; 实际上是一个描述 &quot;UObject&quot; 的类，所以这里的 &quot;ClassWithin&quot; 就是 &quot;UObject&quot;，&quot;UObject&quot; 应该放在 &quot;UObject&quot; 里面</span></span><br><span class="line">	TClass_PrivateStaticClass-&gt;ClassWithin = TClass_WithinClass_StaticClass;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册类的依赖，然后注册该类</span></span><br><span class="line">	TClass_PrivateStaticClass-&gt;<span class="built_in">RegisterDependencies</span>();</span><br><span class="line">	<span class="keyword">if</span> (!TClass_PrivateStaticClass-&gt;<span class="built_in">HasAnyFlags</span>(RF_Dynamic))</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 将此类列入 &quot;PendingRegistrants&quot; TMap中，挂起注册 (延迟注册)，函数解析在下面</span></span><br><span class="line">		TClass_PrivateStaticClass-&gt;<span class="built_in">Register</span>(PackageName, Name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		TClass_PrivateStaticClass-&gt;<span class="built_in">DeferredRegister</span>(UDynamicClass::<span class="built_in">StaticClass</span>(), PackageName, Name);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 调用通知注册事件，改变该类在 &quot;PathToState&quot; 中的状态，用于异步包读取</span></span><br><span class="line">	<span class="built_in">NotifyRegistrationEvent</span>(PackageName, Name, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Finished);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UClass::SetSuperStruct</span><span class="params">(UStruct* NewSuperStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为当前 &quot;UClass&quot; 还是没有初始化 &quot;Name&quot;，所以 &quot;UnhashObject&quot; 直接被return</span></span><br><span class="line">	<span class="built_in">UnhashObject</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 没有初始化 &quot;SuperFuncMap&quot;，略过</span></span><br><span class="line">	<span class="built_in">ClearFunctionMapsCaches</span>();</span><br><span class="line">    <span class="comment">// 设置 &quot;SuperClass&quot;，切勿递归死循环</span></span><br><span class="line">	Super::<span class="built_in">SetSuperStruct</span>(NewSuperStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有初始化 &quot;SparseClassData&quot;，但会去查找SuperClass是否有 &quot;SparseClassData&quot; 信息</span></span><br><span class="line"> 	<span class="comment">// 如果有，将其类型给自己安上，但父类中的 &quot;SparseClassData&quot; 结构体中保存的数据并不会被继承</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">GetSparseClassDataStruct</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (UScriptStruct* SparseClassDataStructArchetype = <span class="built_in">GetSparseClassDataArchetypeStruct</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">SetSparseClassDataStruct</span>(SparseClassDataStructArchetype);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HashObject</span>(<span class="keyword">this</span>);	<span class="comment">// 无效操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// UClass的注册是以延迟注册的方式进行的，当前函数只是在添加延迟注册的信息，真正的注册还没开始...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UObjectBase::Register</span><span class="params">(<span class="keyword">const</span> TCHAR* PackageName,<span class="keyword">const</span> TCHAR* InName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一个记录当前正在挂起注册的所有 &quot;UClass&quot; 的单例TMap</span></span><br><span class="line">	TMap&lt;UObjectBase*, FPendingRegistrantInfo&gt;&amp; PendingRegistrants = FPendingRegistrantInfo::<span class="built_in">GetMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该类添加到 &quot;PendingRegistrants&quot; 中，进行挂起注册 (延迟注册)</span></span><br><span class="line">	FPendingRegistrant* PendingRegistration = <span class="keyword">new</span> <span class="built_in">FPendingRegistrant</span>(<span class="keyword">this</span>);</span><br><span class="line">	PendingRegistrants.<span class="built_in">Add</span>(<span class="keyword">this</span>, <span class="built_in">FPendingRegistrantInfo</span>(InName, PackageName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往全局 &quot;挂起注册&quot; 链表中添加当前类</span></span><br><span class="line">    <span class="keyword">if</span> (GLastPendingRegistrant)</span><br><span class="line">    &#123;</span><br><span class="line">        GLastPendingRegistrant-&gt;NextAutoRegister = PendingRegistration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>(!GFirstPendingRegistrant);</span><br><span class="line">        GFirstPendingRegistrant = PendingRegistration;</span><br><span class="line">    &#125;</span><br><span class="line">    GLastPendingRegistrant = PendingRegistration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>到这里，&quot;UClass&quot; 的 &quot;ClassWithin&quot; ，&quot;SuperClass&quot; 都初始化好了，但其实 &quot;UClass&quot; 的数据远远不止这些，剩下的会在后面的<a href="#UClass%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B3%A8%E5%86%8C">延迟注册</a>中被初始化，先期待一下吧 😃</p><p>别忘了，我们还有 &quot;UFunction&quot; 函数没有注册（反射系统当然少不了咱的 UFunction 啦～～～</p><h4 id="registernativefunc"><a class="anchor" href="#registernativefunc">#</a> RegisterNativeFunc</h4><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class.cpp 以下代码省略的部分前文都已经分析过了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrivateStaticClassBody</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">/* ..., */</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">void</span>(*RegisterNativeFunc)(), </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">/* ... */</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    <span class="built_in">RegisterNativeFunc</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectMacros.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_CLASS(TClass, TClassCrc) \</span></span><br><span class="line"><span class="meta">	UClass* TClass::GetPrivateStaticClass() \</span></span><br><span class="line"><span class="meta">	&#123; \</span></span><br><span class="line"><span class="meta">		<span class="comment">/* ... */</span> \</span></span><br><span class="line"><span class="meta">		GetPrivateStaticClassBody( \</span></span><br><span class="line"><span class="meta">			<span class="comment">/* ... */</span> \</span></span><br><span class="line"><span class="meta">			StaticRegisterNatives##TClass, \</span></span><br><span class="line"><span class="meta">            <span class="comment">/* ... */</span> \                          </span></span><br><span class="line">			); \</span><br><span class="line">        <span class="comment">/* ... */</span> \     </span><br><span class="line">	&#125; \</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ClassName.gen.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UClassName::StaticRegisterNativesUClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        UClass* Class = UClassName::<span class="built_in">StaticClass</span>();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> FNameNativePtrPair Funcs[] = &#123;</span><br><span class="line">            &#123; <span class="string">&quot;UFunctionName&quot;</span>, &amp;UClassName::execUFunctionName &#125;,</span><br><span class="line">            <span class="comment">// ...... 其他在 &quot;RPC_WRAPPERS_NO_PURE_DECLS&quot; 宏中定义的 &quot;exec函数&quot; 都会加入到 &quot;Funcs&quot; 数组里，用于下面的 &quot;RegisterFunctions&quot; 注册函数。</span></span><br><span class="line">        &#125;;</span><br><span class="line">        FNativeFunctionRegistrar::<span class="built_in">RegisterFunctions</span>(Class, Funcs, <span class="built_in">UE_ARRAY_COUNT</span>(Funcs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FNativeFunctionRegistrar::RegisterFunctions</span><span class="params">(class UClass* Class, <span class="keyword">const</span> FNameNativePtrPair* InArray, int32 NumFunctions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; NumFunctions; ++InArray, --NumFunctions)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 逐个注册 &quot;Funcs&quot; 数组里面的函数</span></span><br><span class="line">		Class-&gt;<span class="built_in">AddNativeFunction</span>(<span class="built_in">UTF8_TO_TCHAR</span>(InArray-&gt;NameUTF8), InArray-&gt;Pointer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UClass::AddNativeFunction</span><span class="params">(<span class="keyword">const</span> WIDECHAR* InName, FNativeFuncPtr InPointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FName <span class="title">InFName</span><span class="params">(InName)</span></span>;</span><br><span class="line">    <span class="comment">/* 省略热重载代码 */</span></span><br><span class="line">    <span class="comment">// &quot;TArray&lt;FNativeFunctionLookup&gt; NativeFunctionLookupTable&quot; 是一个数组，往这个数组的末端添加一个元素</span></span><br><span class="line">	<span class="keyword">new</span>(NativeFunctionLookupTable)<span class="built_in">FNativeFunctionLookup</span>(InFName, InPointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FNativeFunctionLookup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 函数名</span></span><br><span class="line">	FName Name;</span><br><span class="line">    <span class="comment">// 本地函数指针</span></span><br><span class="line">	FNativeFuncPtr Pointer;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FNativeFunctionLookup</span>(FName InName, FNativeFuncPtr InPointer)</span><br><span class="line">		:	<span class="built_in">Name</span>(InName)</span><br><span class="line">		,	<span class="built_in">Pointer</span>(InPointer)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>一顿操作下来，其实只是把我们在 &quot;ClassName.h&quot; 中定义的 UFunction 给添加到其 &quot;UClass&quot; 的 &quot;NativeFunctionLookupTable&quot; 数组中。有了这个数组，我们就可以通过函数名查找到对应的 &quot;exec 函数&quot;，这就相当于实现了函数的反射了</p><p>okk，让我们来看看 UE 是怎么<strong>处理挂起的 UClass 的注册</strong>的吧～～～</p><h3 id="uclass的延迟注册a-iduclass的延迟注册a"><a class="anchor" href="#uclass的延迟注册a-iduclass的延迟注册a">#</a> UClass 的延迟注册 &lt;a id=&quot;UClass 的延迟注册&quot;&gt;&lt;/a&gt;</h3><p>&quot;<strong>UObjectProcessRegistrants</strong>&quot;函数是&quot;UClass&quot; 挂起注册的入口，其调用链如下：</p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectProcessRegistrants( 调用链</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WinMain</span>() -&gt; <span class="built_in">GuardedMain</span>() -&gt; <span class="built_in">EnginePreInit</span>() -&gt; FEngineLoop::<span class="built_in">PreInit</span>() -&gt; FEngineLoop::<span class="built_in">PreInitPreStartupScreen</span>() -&gt; FEngineLoop::<span class="built_in">AppInit</span>() -&gt; FCoreDelegates::OnInit.<span class="built_in">Broadcast</span>() -&gt; FCoreDelegates::OnInit.<span class="built_in">AddStatic</span>(InitUObject) -&gt; <span class="built_in">StaticUObjectInit</span>() -&gt; <span class="built_in">UObjectBaseInit</span>() -&gt; <span class="built_in">UObjectProcessRegistrants</span>()</span><br></pre></td></tr></table></figure><p></p><p>显然，我们的挂起注册实际上也是在 &quot;FEngineLoop::PreInit&quot; 阶段进行的。只不过 &quot;AppInit&quot; 在 &quot;UClassRegisterAllCompiledInClasses&quot; 之后而已。在我们进入 &quot;UObjectProcessRegistrants&quot; 的解析之前，其实调用链中还有一个函数非常值得我们分析，那就是 &quot;StaticUObjectInit&quot;。是的，这是静态初始化 &quot;UObject&quot; 的函数，让我们先看看 &quot;StaticUObjectInit&quot; 都做了什么吧～～～</p><h4 id="staticuobjectinit"><a class="anchor" href="#staticuobjectinit">#</a> StaticUObjectInit</h4><p></p><figure class="highlight c++"><figcaption><span>StaticUObjectInit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Obj.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StaticUObjectInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// UObject初始化的最后阶段，重要函数！下文解析</span></span><br><span class="line">	<span class="built_in">UObjectBaseInit</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为临时包分配内存，该临时包不会被GC，没有具体包名的UObject会被加入该临时包中</span></span><br><span class="line">	GObjTransientPkg = NewObject&lt;UPackage&gt;(<span class="literal">nullptr</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;/Engine/Transient&quot;</span>), RF_Transient);</span><br><span class="line">	GObjTransientPkg-&gt;<span class="built_in">AddToRoot</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="uobjectbaseinit"><a class="anchor" href="#uobjectbaseinit">#</a> UObjectBaseInit</h4><p></p><figure class="highlight c++"><figcaption><span>UObjectBaseInit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UObjectBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数首先初始化了 &quot;GUObjectAllocator&quot; 的永久对象池(不会被GC)，和 &quot;GUObjectArray&quot; 的对象池，最后初始化异步线程，用于包读取。最后调用咱的 &quot;UObjectProcessRegistrants&quot; 处理挂起注册的 &quot;UClass&quot;。所有的过程咱都会在注释里介绍一遍，不像看GC的读者也可以跳过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UObjectBaseInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明一些用于初始化 &quot;GUObjectAllocator&quot; 和 &quot;GUObjectArray&quot; 的参数</span></span><br><span class="line">	int32 MaxObjectsNotConsideredByGC = <span class="number">0</span>;</span><br><span class="line">	int32 SizeOfPermanentObjectPool = <span class="number">0</span>;</span><br><span class="line">	int32 MaxUObjects = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Default to ~2M UObjects</span></span><br><span class="line">	<span class="keyword">bool</span> bPreAllocateUObjectArray = <span class="literal">false</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非Editor模式下，从配置文件中读取相应数据，并配置到刚刚声明的参数中</span></span><br><span class="line">	<span class="keyword">if</span> (FPlatformProperties::<span class="built_in">RequiresCookedData</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		FString Value;</span><br><span class="line">		<span class="keyword">bool</span> bIsCookOnTheFly = FParse::<span class="built_in">Value</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;-filehostip=&quot;</span>), Value);</span><br><span class="line">		<span class="keyword">if</span> (bIsCookOnTheFly)</span><br><span class="line">		&#123;</span><br><span class="line">			GCreateGCClusters = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 从配置文件中读取并设置参数</span></span><br><span class="line">			GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsNotConsideredByGC&quot;</span>), MaxObjectsNotConsideredByGC, GEngineIni);</span><br><span class="line"></span><br><span class="line">			GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.SizeOfPermanentObjectPool&quot;</span>), SizeOfPermanentObjectPool, GEngineIni);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsInGame&quot;</span>), MaxUObjects, GEngineIni);</span><br><span class="line"></span><br><span class="line">		GConfig-&gt;<span class="built_in">GetBool</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.PreAllocateUObjectArray&quot;</span>), bPreAllocateUObjectArray, GEngineIni);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Editor模式下将禁用 &quot;GUObjectAllocator&quot; 的永久对象池</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_PROGRAM</span></span><br><span class="line">		MaxUObjects = <span class="number">100000</span>; <span class="comment">// Default to 100K for programs</span></span><br><span class="line">		GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsInProgram&quot;</span>), MaxUObjects, GEngineIni);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsInEditor&quot;</span>), MaxUObjects, GEngineIni);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果启用永久对象池但可忽略GC的Object数量为0，则GC会把永久池中的对象Mark为不可达，并将其清理掉。所以这种清空也应该禁用永久池</span></span><br><span class="line">	<span class="keyword">if</span> (MaxObjectsNotConsideredByGC &lt;= <span class="number">0</span> &amp;&amp; SizeOfPermanentObjectPool &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SizeOfPermanentObjectPool = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 GUObjectAllocator的永久池 和 GUObjectArray的对象池&quot;ObjObjects&quot;，该对象池既存永久对象又存当前存活的参与GC的对象，永久对象会存在数组的后面。</span></span><br><span class="line">	GUObjectAllocator.<span class="built_in">AllocatePermanentObjectPool</span>(SizeOfPermanentObjectPool);</span><br><span class="line">	GUObjectArray.<span class="built_in">AllocateObjectPool</span>(MaxUObjects, MaxObjectsNotConsideredByGC, bPreAllocateUObjectArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个全局的异步包读取器，并更新当前异步线程数。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InitAsyncThread</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="built_in">InitAsyncThread</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标志着 &quot;UObject系统&quot; 初始化完成</span></span><br><span class="line">	Internal::<span class="built_in">GetUObjectSubsystemInitialised</span>() = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始处理 &quot;UClass&quot; 的挂起注册</span></span><br><span class="line">	<span class="built_in">UObjectProcessRegistrants</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&quot;UObjectBaseInit&quot; 函数主要就是在为 GC 做准备，然后初始化了一个异步线程，用于后面的 &quot;UClass&quot; 的延迟注册。终于... 可以继续注册咱的 &quot;UClass&quot; 了（兴奋）</p><h4 id="uobjectprocessregistrants"><a class="anchor" href="#uobjectprocessregistrants">#</a> UObjectProcessRegistrants</h4><p></p><figure class="highlight c++"><figcaption><span>UObjectProcessRegistrants</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UObjectProcessRegistrants</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 所有需要注册的 &quot;UObjects&quot; 数组</span></span><br><span class="line">	TArray&lt;FPendingRegistrant&gt; PendingRegistrants;</span><br><span class="line">    <span class="comment">// 更新 &quot;PendingRegistrants&quot; 数组</span></span><br><span class="line">	<span class="built_in">DequeuePendingAutoRegistrants</span>(PendingRegistrants);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历注册 &quot;PendingRegistrants&quot; 数组中的所有Objects</span></span><br><span class="line">	<span class="keyword">for</span>(int32 RegistrantIndex = <span class="number">0</span>;RegistrantIndex &lt; PendingRegistrants.<span class="built_in">Num</span>();++RegistrantIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> FPendingRegistrant&amp; PendingRegistrant = PendingRegistrants[RegistrantIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正注册 &quot;UClass&quot; 的函数，重要！下文分析</span></span><br><span class="line">		<span class="built_in">UObjectForceRegistration</span>(PendingRegistrant.Object, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里需要更新咱的 &quot;PendingRegistrants&quot; 数组，因为在注册的时候可能会触发另一个Module的加载，从而导致有新的 &quot;挂起注册&quot; 进来，我们要把新的 &quot;挂起注册&quot; 也一起处理了</span></span><br><span class="line">		<span class="built_in">DequeuePendingAutoRegistrants</span>(PendingRegistrants);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DequeuePendingAutoRegistrants</span><span class="params">(TArray&lt;FPendingRegistrant&gt;&amp; OutPendingRegistrants)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FPendingRegistrant* NextPendingRegistrant = GFirstPendingRegistrant;</span><br><span class="line">    <span class="comment">// 清空链表节点记录，以便下次使用</span></span><br><span class="line">	GFirstPendingRegistrant = <span class="literal">NULL</span>;</span><br><span class="line">	GLastPendingRegistrant = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将所有新的 &quot;挂起注册&quot; 加载复制到咱的 &quot;PendingRegistrants&quot; 数组中，并释放原来指针指向的内存</span></span><br><span class="line">	<span class="keyword">while</span>(NextPendingRegistrant)</span><br><span class="line">	&#123;</span><br><span class="line">		FPendingRegistrant* PendingRegistrant = NextPendingRegistrant;</span><br><span class="line">		OutPendingRegistrants.<span class="built_in">Add</span>(*PendingRegistrant);</span><br><span class="line">		NextPendingRegistrant = PendingRegistrant-&gt;NextAutoRegister;</span><br><span class="line">		<span class="keyword">delete</span> PendingRegistrant;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="uobjectforceregistration"><a class="anchor" href="#uobjectforceregistration">#</a> UObjectForceRegistration</h4><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UObjectForceRegistration</span><span class="params">(UObjectBase* Object, <span class="keyword">bool</span> bCheckForModuleRelease)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取咱们收集阶段处理好的TMap</span></span><br><span class="line">	TMap&lt;UObjectBase*, FPendingRegistrantInfo&gt;&amp; PendingRegistrants = FPendingRegistrantInfo::<span class="built_in">GetMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用传进来的 &quot;UClass&quot; 作为键，找到对应的 &quot;UClass&quot; 挂起注册信息</span></span><br><span class="line">	FPendingRegistrantInfo* Info = PendingRegistrants.<span class="built_in">Find</span>(Object);</span><br><span class="line">	<span class="keyword">if</span> (Info)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> TCHAR* PackageName = Info-&gt;PackageName;</span><br><span class="line">		<span class="keyword">const</span> TCHAR* Name = Info-&gt;Name;</span><br><span class="line">		PendingRegistrants.<span class="built_in">Remove</span>(Object);  <span class="comment">// 先删除，避免二次延迟注册</span></span><br><span class="line">        <span class="comment">// 开始延迟注册，下文分析</span></span><br><span class="line">		Object-&gt;<span class="built_in">DeferredRegister</span>(UClass::<span class="built_in">StaticClass</span>(),PackageName,Name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UObjectBase::DeferredRegister</span><span class="params">(UClass *UClassStaticClass,<span class="keyword">const</span> TCHAR* PackageName,<span class="keyword">const</span> TCHAR* InName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 设置对象的属性</span></span><br><span class="line">	UPackage* Package = <span class="built_in">CreatePackage</span>(PackageName);</span><br><span class="line">	<span class="built_in">check</span>(Package);</span><br><span class="line">	Package-&gt;<span class="built_in">SetPackageFlags</span>(PKG_CompiledIn);</span><br><span class="line">	OuterPrivate = Package;</span><br><span class="line"></span><br><span class="line">	ClassPrivate = UClassStaticClass;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将该对象添加到 &quot;FUObjectHashTables&quot; 单例中(到这一步Object才有Name...)</span></span><br><span class="line">	<span class="built_in">AddObject</span>(<span class="built_in">FName</span>(InName), EInternalObjectFlags::None);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保该对象在根集中，忽略GC</span></span><br><span class="line">	<span class="built_in">check</span>(!GUObjectArray.<span class="built_in">IsDisregardForGC</span>(<span class="keyword">this</span>) || GUObjectArray.<span class="built_in">IndexToObject</span>(InternalIndex)-&gt;<span class="built_in">IsRootSet</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UObjectBase::AddObject</span><span class="params">(FName InName, EInternalObjectFlags InSetInternalFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置名字，内部对象标志(用于GC等)</span></span><br><span class="line">	NamePrivate = InName;</span><br><span class="line">	EInternalObjectFlags InternalFlagsToSet = InSetInternalFlags;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsInGameThread</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		InternalFlagsToSet |= EInternalObjectFlags::Async;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ObjectFlags &amp; RF_MarkAsRootSet)</span><br><span class="line">	&#123;		</span><br><span class="line">		InternalFlagsToSet |= EInternalObjectFlags::RootSet;</span><br><span class="line">		ObjectFlags &amp;= ~RF_MarkAsRootSet;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ObjectFlags &amp; RF_MarkAsNative)</span><br><span class="line">	&#123;</span><br><span class="line">		InternalFlagsToSet |= EInternalObjectFlags::Native;</span><br><span class="line">		ObjectFlags &amp;= ~RF_MarkAsNative;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 给Object分配一个 &quot;Index&quot;，以便 &quot;GUObjectArray&quot; 能通过 &quot;IndexToObject&quot; 找到这个Object，并重新设置该Object的Flags</span></span><br><span class="line">	<span class="built_in">AllocateUObjectIndexForCurrentThread</span>(<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">check</span>(InName != NAME_None &amp;&amp; InternalIndex &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (InternalFlagsToSet != EInternalObjectFlags::None)</span><br><span class="line">	&#123;</span><br><span class="line">		GUObjectArray.<span class="built_in">IndexToObject</span>(InternalIndex)-&gt;<span class="built_in">SetFlags</span>(InternalFlagsToSet);</span><br><span class="line">	&#125;	</span><br><span class="line">    <span class="comment">// &quot;HashObject&quot; 是对 &quot;FUObjectHashTable&quot; 单例的操作，重要！下文分析</span></span><br><span class="line">	<span class="built_in">HashObject</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在分析 &quot;HashObject&quot; 之前，我们需要简单了解一下 &quot;FUObjectHashTables&quot; 类的作用和内部结构。</p><p><img data-src="FUObjectHashTables.png" alt="FUObjectHashTables"></p><p>&quot;FUObjectHashTables&quot; 是一个单例类，下面的 &quot;Get&quot; 函数是用来获取全局唯一的单例的。其属性包括：</p><ul><li>FHashBucket：特殊的散列存储桶以节省内存，里面有两个指针，指向一个 &quot;UObject&quot; 或一个 &quot;TSet&quot;</li><li>TMap&lt;int32, FHashBucket&gt; Hash：一个标准的哈希表，&quot;key&quot; 是通过 &quot;FName&quot; 计算出来的哈希值，&quot;value&quot; 是一个哈希桶，存着一个 &quot;UObject&quot; 或 &quot;TSet&quot; (复杂数据结构)，这个 &quot;Hash&quot; TMap 会把我们注册的所有 &quot;UObject&quot; 给存起来，用于反射</li><li>TMultiMap&lt;int32, class UObjectBase*&gt; HashOuter：对应于 &quot;Hash&quot;，注册 &quot;UObject&quot; 时，会对应的往 &quot;HashOuter&quot; 里面添加一条记录，&quot;key&quot; 为 该对象的 &quot;Outer&quot; 的哈希值，&quot;value&quot; 为该对象自身</li><li>TMap&lt;UObjectBase*, FHashBucket&gt; ObjectOuterMap：每个 &quot;Outer&quot; 都会在这个 &quot;TMap&quot; 中，以自己作为 &quot;key&quot;，生成一个 &quot;FHashBucket&quot;，如果有 &quot;UObject&quot; 需要注册时，会往对应的 &quot;Outer&quot; 的桶里面，把自己添加进去</li><li>TMap&lt;UClass*, FHashBucket&gt; ClassToObjectListMap：每个 &quot;UClass&quot; 都会在这个 &quot;TMap&quot; 中，以自己作为 &quot;key&quot;，生成一个 &quot;FHashBucket&quot;，如果有 &quot;UObject&quot; 需要注册时，会往对应的 &quot;UClass&quot; 的桶里面，把自己添加进去</li><li>TMap&lt;UClass*, TSet&lt;UClass*&gt;&gt; ClassToChildListMap：每个 &quot;UClass&quot; 都会在这个 &quot;TMap&quot; 中，以自己作为 &quot;key&quot;，生成一个 &quot;TSet&lt;UClass&gt;&quot; 容器，如果有 &quot;UObject&quot; 需要注册时，会往对应的 &quot;USuperClass&quot; 的容器中，把自己的 &quot;UClass&quot; 添加进去 (如果之前没有添加过)</li><li>TAtomic&lt;uint64&gt; ClassToChildListMapVersion：每次更新 &quot;ClassToChildListMap&quot; (包括添加和删除元素)，这个 &quot;Version&quot; 都会自增</li><li>TMap&lt;UPackage*, FHashBucket&gt; PackageToObjectListMap：每个 &quot;UClass&quot; 都会在这个 &quot;TMap&quot; 中，以自己作为 &quot;key&quot;，生成一个 &quot;FHashBucket&quot; ，如果有 &quot;UObject&quot; 需要创建时，会往对应的 &quot;FHashBucket&quot; 的容器中，把自己添加进去</li><li>TMap&lt;UObjectBase*, UPackage*&gt; ObjectToPackageMap：&quot;UObject*&quot; 到 &quot;UPackage*&quot; 的映射</li></ul><p>这些容器都是用于全局查找 &quot;UObject&quot; 的各种属性，无疑是为了扩展 &quot;UObject&quot; 的反射功能的一个类，类内的函数，包括 &quot;UObjectBase.cpp&quot; 中的很多函数都是为这些容器服务的，所以我们注册 &quot;UClass&quot; 时，很有必要将其添加到 &quot;FUObjectHashTable&quot; 中。</p><h4 id="hashobject"><a class="anchor" href="#hashobject">#</a> HashObject</h4><p></p><figure class="highlight c++"><figcaption><span>HashObject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObejctHash.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HashObject</span><span class="params">(UObjectBase* Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FName Name = Object-&gt;<span class="built_in">GetFName</span>();</span><br><span class="line">	<span class="keyword">if</span> (Name != NAME_None)</span><br><span class="line">	&#123;</span><br><span class="line">		int32 Hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 &quot;UObjectHashTable&quot; 单例，并上锁</span></span><br><span class="line">		FUObjectHashTables&amp; ThreadHash = FUObjectHashTables::<span class="built_in">Get</span>();</span><br><span class="line">		<span class="function">FHashTableLock <span class="title">HashLock</span><span class="params">(ThreadHash)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前 Object 的 &quot;Hash&quot; 键</span></span><br><span class="line">		Hash = <span class="built_in">GetObjectHash</span>(Name);</span><br><span class="line">        <span class="comment">// 将这个对象添加到 &quot;FUObjectHashTables&quot; 单例的TMap &quot;Hash&quot; 中</span></span><br><span class="line">		ThreadHash.<span class="built_in">AddToHash</span>(Hash, Object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该 Object 存在 &quot;Outer&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (PTRINT Outer = (PTRINT)Object-&gt;<span class="built_in">GetOuter</span>())</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 将这个对象添加到 &quot;FUObjectHashTables&quot; 单例的 &quot;HashOuter&quot; 中</span></span><br><span class="line">			Hash = <span class="built_in">GetObjectOuterHash</span>(Name, Outer);</span><br><span class="line">			ThreadHash.HashOuter.<span class="built_in">Add</span>(Hash, Object);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将这个对象添加到 &quot;FUObjectHashTables&quot; 单例的 &quot;ObjectOuterMap&quot; 中</span></span><br><span class="line">			<span class="built_in">AddToOuterMap</span>(ThreadHash, Object);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将这个对象添加到 &quot;FUObjectHashTables&quot; 单例的 &quot;ClassToObjectListMap&quot; 和 &quot;ClassToChildListMap&quot; 中</span></span><br><span class="line">		<span class="built_in">AddToClassMap</span>( ThreadHash, Object );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>没错，&quot;HashObject&quot; 这个函数就是为了维护 &quot;UObjectHashTables&quot; 中的全局 TMap 的。其实到这里，咱 &quot;UClass&quot; 的初始化已经完成一大半了。但剩下的注册工作，对于 &quot;UClass&quot; 的反射系统也是尤为重要的，那就是我们的 &quot;CDO&quot; 和 &quot;TokenStream&quot;(GC) 了（毕竟是场长途旅行，怎么可能这么快结束嘛～～～</p><h3 id="后处理注册的后半部分"><a class="anchor" href="#后处理注册的后半部分">#</a> 后处理（注册的后半部分）</h3><p>&quot;UClass&quot; 的后处理是在 &quot;<strong>ProcessNewlyLoadedUObjects</strong>&quot; 中进行的，其调用链为</p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WinMain</span>() -&gt; <span class="built_in">GuardedMain</span>() -&gt; <span class="built_in">EnginePreInit</span>() -&gt; FEngineLoop::<span class="built_in">PreInit</span>() -&gt; <span class="built_in">PreInitPostStartupScreen</span>() -&gt; <span class="built_in">ProcessNewlyLoadedUObjects</span>()</span><br></pre></td></tr></table></figure><p></p><p>可以看出，后处理其实是在 &quot;PreInit&quot; 的后半部分 &quot;PreInitPostStartupScreen&quot; 进行的，之前的注册都是在前半部分 &quot;PreInitPreStartupScreen&quot; 完成的。理清楚了后处理执行的时间点，让我们看看后处理都做了什么吧～～～</p><h4 id="processnewlyloadeduobjects"><a class="anchor" href="#processnewlyloadeduobjects">#</a> ProcessNewlyLoadedUObjects</h4><p></p><figure class="highlight c++"><figcaption><span>ProcessNewlyLoadedUObjects</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessNewlyLoadedUObjects</span><span class="params">(FName Package, <span class="keyword">bool</span> bCanProcessNewlyLoadedObjects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;UClass&quot; 的注册阶段，前文分析过了</span></span><br><span class="line">	<span class="built_in">UClassRegisterAllCompiledInClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取是否有新收集到的 &quot;UClass&quot; 或 &quot;UStruct&quot; 或 &quot;UEnum&quot;，有则对其进行处理</span></span><br><span class="line">	<span class="keyword">const</span> TArray&lt;UClass* (*)()&gt;&amp; DeferredCompiledInRegistration = <span class="built_in">GetDeferredCompiledInRegistration</span>();</span><br><span class="line">	<span class="keyword">const</span> TArray&lt;FPendingStructRegistrant&gt;&amp; DeferredCompiledInStructRegistration = <span class="built_in">GetDeferredCompiledInStructRegistration</span>();</span><br><span class="line">	<span class="keyword">const</span> TArray&lt;FPendingEnumRegistrant&gt;&amp; DeferredCompiledInEnumRegistration = <span class="built_in">GetDeferredCompiledInEnumRegistration</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> bNewUObjects = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (GFirstPendingRegistrant || DeferredCompiledInRegistration.<span class="built_in">Num</span>() || DeferredCompiledInStructRegistration.<span class="built_in">Num</span>() || DeferredCompiledInEnumRegistration.<span class="built_in">Num</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		bNewUObjects = <span class="literal">true</span>;		<span class="comment">// 标记有新UObject生成，用于后面引用记号流的创建</span></span><br><span class="line">		<span class="built_in">UObjectProcessRegistrants</span>();	<span class="comment">// 延迟注册UObjects，前文分析过了</span></span><br><span class="line">		<span class="built_in">UObjectLoadAllCompiledInStructs</span>();	<span class="comment">// 注册UEnum，设置内部单例等</span></span><br><span class="line">		<span class="built_in">UObjectLoadAllCompiledInDefaultProperties</span>(); <span class="comment">// 初始化属性链等，创建CDO，详见下文</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前处于 &quot;EngineLoop::PreInit&quot; 阶段，所以GIsInitialLoad为ture，下面这个函数并不会执行，但我们还是要对其进行分析的，以便咱对这个函数有更为全面的理解</span></span><br><span class="line">	<span class="keyword">if</span> (bNewUObjects &amp;&amp; !GIsInitialLoad)</span><br><span class="line">	&#123;</span><br><span class="line">		UClass::<span class="built_in">AssembleReferenceTokenStreams</span>();	<span class="comment">// 为 &quot;UClass&quot; 创建引用记号流，详见下文</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>咋一看，好像这一步只做了三件事，继续初始化 &quot;UClass&quot; 的相关属性，创建 CDO 和构建 TokenStreams。但其实这一步还把之前的注册和延迟注册也包含进去了。所以说，这是一个完整的注册步骤。只要你在收集阶段收集到一个 &quot;UClass&quot; 再调用这个函数，都是可以一条龙完成注册的。那么问题来了，为什么需要这么一条可以处理所有注册任务的函数？竟然有这么一条函数，为什么之前还辛辛苦苦把注册的步骤拆开来完成？</p><p>原因总结起来有三点：</p><ol><li>首先，我们之前讲得都是 &quot;EngineLoop::PreInit&quot; 中的注册，此阶段需要注册的 &quot;UClass&quot; 可能很多，因为引擎刚启动，很多底层的上层的模块中的类都需要注册，这个时候我们就需要分步骤来延迟注册，这样引擎也能同时完成一些其他的初始化任务。</li><li>其次，我们后面动态加载进来的模块是不会再进入 PreInit 阶段的。这样的话，我们就不得不做一个完全可以一条龙注册 &quot;UClass&quot; 的函数，来完成动态加载的模块的类的 &quot;UClass&quot; 的注册</li><li>最后，也是为了确保 &quot;PreInit&quot; 阶段中注册的 &quot;UClass&quot; 没有遗漏，反正注册阶段处理过的 &quot;UClass&quot; 会被清理掉。如果没有数据遗漏，咱也会直接返回，并不会二次注册同一个 &quot;UClass&quot;。</li></ol><p>好的，接下来进入 &quot;UObjectLoadAllCompiledInDefaultProperties&quot; 和 &quot;AssembleReferenceTokenStreams&quot; 的函数解析。</p><h4 id="uobjectloadallcompiledindefaultproperties"><a class="anchor" href="#uobjectloadallcompiledindefaultproperties">#</a> UObjectLoadAllCompiledInDefaultProperties</h4><p></p><figure class="highlight c++"><figcaption><span>UObjectLoadAllCompiledInDefaultProperties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UObjectBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UObjectLoadAllCompiledInDefaultProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> FName <span class="title">LongEnginePackageName</span><span class="params">(TEXT(<span class="string">&quot;/Script/Engine&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;DeferredCompiledInRegistration&quot; 存着所有类的构造函数，包括属性链等的初始化</span></span><br><span class="line">	TArray&lt;UClass *(*)()&gt;&amp; DeferredCompiledInRegistration = <span class="built_in">GetDeferredCompiledInRegistration</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> bHaveRegistrants = DeferredCompiledInRegistration.<span class="built_in">Num</span>() != <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>( bHaveRegistrants )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 分类注册，先注册底层模块 &quot;UClass&quot;，再注册上层，同时也方便性能分析</span></span><br><span class="line">		TArray&lt;UClass*&gt; NewClasses;</span><br><span class="line">		TArray&lt;UClass*&gt; NewClassesInCoreUObject;</span><br><span class="line">		TArray&lt;UClass*&gt; NewClassesInEngine;</span><br><span class="line">		TArray&lt;UClass* (*)()&gt; PendingRegistrants = <span class="built_in">MoveTemp</span>(DeferredCompiledInRegistration);</span><br><span class="line">		<span class="keyword">for</span> (UClass* (*Registrant)() : PendingRegistrants)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 后处理 &quot;UClass&quot; 中的属性，包括配置文件名，属性链等，详见上文</span></span><br><span class="line">			UClass* Class = <span class="built_in">Registrant</span>();</span><br><span class="line">			<span class="keyword">if</span> (Class-&gt;<span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">GetFName</span>() == GLongCoreUObjectPackageName)</span><br><span class="line">			&#123;</span><br><span class="line">				NewClassesInCoreUObject.<span class="built_in">Add</span>(Class);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Class-&gt;<span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">GetFName</span>() == LongEnginePackageName)</span><br><span class="line">			&#123;</span><br><span class="line">				NewClassesInEngine.<span class="built_in">Add</span>(Class);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				NewClasses.<span class="built_in">Add</span>(Class);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建 &quot;CoreUObject&quot; 模块 &quot;UClass&quot; 的 &quot;CDO&quot;</span></span><br><span class="line">            <span class="keyword">for</span> (UClass* Class : NewClassesInCoreUObject)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// &quot;GetDefaultObject&quot; 会在下文进行解析</span></span><br><span class="line">				Class-&gt;<span class="built_in">GetDefaultObject</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 创建引擎其他模块的 &quot;UClass&quot; 的 &quot;CDO&quot;</span></span><br><span class="line">            <span class="keyword">for</span> (UClass* Class : NewClassesInEngine) </span><br><span class="line">			&#123;</span><br><span class="line">				Class-&gt;<span class="built_in">GetDefaultObject</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 创建我们自建类的 &quot;UClass&quot; 的 &quot;CDO&quot;</span></span><br><span class="line">			<span class="keyword">for</span> (UClass* Class : NewClasses)</span><br><span class="line">			&#123;</span><br><span class="line">				Class-&gt;<span class="built_in">GetDefaultObject</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 省略性能分析的部分代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这块代码也不难理解，就是后处理 &quot;UClass&quot; 中的一些属性，然后给 &quot;UClass&quot; 分类，按底层到上层的顺序创建 &quot;CDO&quot; 嘛。但是为什么呢？为什么要这么做？其中一个原因是，依赖关系。上层类依赖底层类，在创建 &quot;CDO&quot; 时可能会用到基类或者包的 &quot;CDO&quot;，如果这些被依赖的类的 &quot;CDO&quot; 能在这之前就构造，子类 &quot;CDO&quot; 的创建也会方便不少。还有就是为了方便对每种分类创建 &quot;CDO&quot; 进行性能分析，这块代码咱省略掉了。接下来去看看怎么创建 &quot;CDO&quot; 的吧 )</p><h4 id="getdefaultobject"><a class="anchor" href="#getdefaultobject">#</a> GetDefaultObject</h4><p></p><figure class="highlight c++"><figcaption><span>GetDefaultObject</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class.h</span></span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">GetDefaultObject</span><span class="params">(<span class="keyword">bool</span> bCreateIfNeeded = <span class="literal">true</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 没有才创建，有则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (ClassDefaultObject == <span class="literal">nullptr</span> &amp;&amp; bCreateIfNeeded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;UClass*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">CreateDefaultObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ClassDefaultObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">UObject* <span class="title">UClass::CreateDefaultObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( ClassDefaultObject == <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		UClass* ParentClass = <span class="built_in">GetSuperClass</span>();</span><br><span class="line">		UObject* ParentDefaultObject = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> ( ParentClass != <span class="literal">NULL</span> )</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 如果存在父类，确保父类已注册</span></span><br><span class="line">			<span class="built_in">UObjectForceRegistration</span>(ParentClass);</span><br><span class="line">            <span class="comment">// 确保父类已经有CDO，这一步是会递归地创建其父类的父类的 &quot;CDO&quot; 的</span></span><br><span class="line">			ParentDefaultObject = ParentClass-&gt;<span class="built_in">GetDefaultObject</span>(); </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前 &quot;UClass&quot; 是 &quot;UObject&quot;，或者该类没有父类</span></span><br><span class="line">		<span class="keyword">if</span> ( (ParentDefaultObject != <span class="literal">NULL</span>) || (<span class="keyword">this</span> == UObject::<span class="built_in">StaticClass</span>()) )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 如果这是一个蓝图类的 &quot;UClass&quot;，则可能是没有完全加载进来。在此调用 &quot;Preload&quot; 和 &quot;StaticLink&quot; 以确保正确地为CDO设置零内存和读入属性</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">HasAnyClassFlags</span>(CLASS_CompiledFromBlueprint) &amp;&amp; (PropertyLink == <span class="literal">NULL</span>) &amp;&amp; !GIsDuplicatingClassForReinstancing)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> ClassLinker = <span class="built_in">GetLinker</span>();</span><br><span class="line">				<span class="keyword">if</span> (ClassLinker &amp;&amp; !ClassLinker-&gt;bDynamicClassLinker)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (!GEventDrivenLoaderEnabled)</span><br><span class="line">					&#123;</span><br><span class="line">						UField* FieldIt = Children;</span><br><span class="line">						<span class="keyword">while</span> (FieldIt &amp;&amp; (FieldIt-&gt;<span class="built_in">GetOuter</span>() == <span class="keyword">this</span>))</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">// 如果类之间存在循环依赖关系，则可能需要预加载以确保能加载完所有依赖字段</span></span><br><span class="line">							<span class="keyword">if</span> (FieldIt-&gt;<span class="built_in">HasAnyFlags</span>(RF_NeedLoad))</span><br><span class="line">							&#123;</span><br><span class="line">                                <span class="comment">// 字段预加载，不展开</span></span><br><span class="line">								ClassLinker-&gt;<span class="built_in">Preload</span>(FieldIt);</span><br><span class="line">							&#125;</span><br><span class="line">							FieldIt = FieldIt-&gt;Next;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 处理 &quot;UClass&quot; 的属性链，留到别的文章解析</span></span><br><span class="line">					<span class="built_in">StaticLink</span>(<span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 在循环依赖的情况下，上面的 &quot;Preload&quot; 调用可能会自己调用此方法</span></span><br><span class="line">            <span class="comment">// 这意味着一旦完成了所有 &quot;Preload&quot; 调用，我们必须确保 &quot;CDO&quot; 仍然为NULL，以保证我们不会使已设置的 &quot;CDO&quot; 无效</span></span><br><span class="line">            <span class="keyword">if</span> (ClassDefaultObject == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				FString PackageName;</span><br><span class="line">				FString CDOName;</span><br><span class="line">				<span class="keyword">bool</span> bDoNotify = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 如果可以加载 &quot;CDO&quot;，则初始化包名和CDO名等</span></span><br><span class="line">				<span class="keyword">if</span> (GIsInitialLoad &amp;&amp; <span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">HasAnyPackageFlags</span>(PKG_CompiledIn) &amp;&amp; !<span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">HasAnyPackageFlags</span>(PKG_RuntimeGenerated))</span><br><span class="line">				&#123;</span><br><span class="line">					PackageName = <span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">GetFName</span>().<span class="built_in">ToString</span>();</span><br><span class="line">					CDOName = <span class="built_in">GetDefaultObjectName</span>().<span class="built_in">ToString</span>();</span><br><span class="line">					<span class="built_in">NotifyRegistrationEvent</span>(*PackageName, *CDOName, ENotifyRegistrationType::NRT_ClassCDO, ENotifyRegistrationPhase::NRP_Started);</span><br><span class="line">					bDoNotify = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// &quot;RF_ArchetypeObject&quot; 标志通常对 &quot;RF_ClassDefaultObject&quot; 是冗余的，</span></span><br><span class="line">                <span class="comment">// 但是我们需要将 &quot;CDO&quot; 标记为 &quot;RF_ArchetypeObject&quot;，以便将该标志传播到任何默认子对象。</span></span><br><span class="line">				ClassDefaultObject = <span class="built_in">StaticAllocateObject</span>(<span class="keyword">this</span>, <span class="built_in">GetOuter</span>(), NAME_None, <span class="built_in">EObjectFlags</span>(RF_Public|RF_ClassDefaultObject|RF_ArchetypeObject));</span><br><span class="line">				<span class="built_in">check</span>(ClassDefaultObject);</span><br><span class="line">				<span class="comment">// 蓝图 &quot;CDO&quot; 有属性始终会被初始化(用于后面CDO的构造函数)</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">bool</span> bShouldInitializeProperties = !<span class="built_in">HasAnyClassFlags</span>(CLASS_Native | CLASS_Intrinsic);</span><br><span class="line">				<span class="comment">// 将此类引入的所有稀疏代理的偏移量注册到稀疏代理存储中(放到代理的文章里面解析，只需要知道在这个时候注册即可)</span></span><br><span class="line">				<span class="keyword">for</span> (TFieldIterator&lt;FMulticastSparseDelegateProperty&gt; <span class="built_in">SparseDelegateIt</span>(<span class="keyword">this</span>, EFieldIteratorFlags::ExcludeSuper, EFieldIteratorFlags::ExcludeDeprecated); SparseDelegateIt; ++SparseDelegateIt)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">const</span> FSparseDelegate&amp; SparseDelegate = SparseDelegateIt-&gt;<span class="built_in">GetPropertyValue_InContainer</span>(ClassDefaultObject);</span><br><span class="line">					USparseDelegateFunction* SparseDelegateFunction = CastChecked&lt;USparseDelegateFunction&gt;(SparseDelegateIt-&gt;SignatureFunction);</span><br><span class="line">					FSparseDelegateStorage::<span class="built_in">RegisterDelegateOffset</span>(ClassDefaultObject, SparseDelegateFunction-&gt;DelegateName, (<span class="keyword">size_t</span>)&amp;SparseDelegate - (<span class="keyword">size_t</span>)ClassDefaultObject);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 如果是蓝图类 &quot;UClass&quot; 则初始化动态类的相关属性</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">HasAnyClassFlags</span>(CLASS_CompiledFromBlueprint))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (UDynamicClass* DynamicClass = Cast&lt;UDynamicClass&gt;(<span class="keyword">this</span>))</span><br><span class="line">					&#123;</span><br><span class="line">						(*(DynamicClass-&gt;DynamicClassInitializer))(DynamicClass);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 构造一个 &quot;CDO&quot;，&quot;ClassConstructor&quot; 其实就是我们 &quot;GENERATED_BODY()&quot; 里面，&quot;UHT&quot; 为我们生成的构造函数包装器，是一个装着该类的构造函数的函数指针</span></span><br><span class="line">				(*ClassConstructor)(<span class="built_in">FObjectInitializer</span>(ClassDefaultObject, ParentDefaultObject, <span class="literal">false</span>, bShouldInitializeProperties));</span><br><span class="line">				<span class="keyword">if</span> (bDoNotify)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">NotifyRegistrationEvent</span>(*PackageName, *CDOName, ENotifyRegistrationType::NRT_ClassCDO, ENotifyRegistrationPhase::NRP_Finished);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// &quot;CDO&quot; 的后处理，虚函数，可以重载来处理更多的逻辑</span></span><br><span class="line">				ClassDefaultObject-&gt;<span class="built_in">PostCDOContruct</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ClassDefaultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>总结起来就是，<strong>引擎会先判断是否需要创建 &quot;CDO&quot;，需要则优先创建递归创建所有基类的 &quot;CDO&quot; (如果没有)。如果没有基类，或者该对象的 &quot;UClass&quot; 就是 &quot;UObject&quot;（蓝图创建的类没有加载完也是 &quot;UObject&quot;，要调用 &quot;Preload&quot; 和 &quot;Link&quot; 使其完成加载），最后就是为 &quot;CDO&quot; 申请内存，注册代理，构造 &quot;CDO&quot;，当然还有预留的后处理接口。</strong></p><p>最后是创建 &quot;引用流标记&quot;，再提醒一下，我们注册 &quot;UClass&quot; 的时候是不会创建 &quot;TokenStream&quot; 的，&quot;UClass::AssembleReferenceTokenStreams&quot; 会在让后续的 &quot;GUObjectArray.CloseDisregardForGC&quot; 中触发，这里之所以要加这一步，是因为我们的 &quot;ProcessNewlyLoadedUObjects&quot; 函数是可以用于模块动态加载时注册 &quot;UClass&quot; 的，而动态加载时是会直接创建引用流标记的。好的，让我们开始最后一轮解析吧～～～（最后一步啦，有点不舍...</p><h4 id="assemblereferencetokenstreams"><a class="anchor" href="#assemblereferencetokenstreams">#</a> AssembleReferenceTokenStreams</h4><p></p><figure class="highlight c++"><figcaption><span>AssembleReferenceTokenStreams</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UClass::AssembleReferenceTokenStreams</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 遍历所有 &quot;UClass&quot; 对象，强制创建 &quot;CDO&quot;，再为 &quot;UClass&quot; 创建引用记号流(如果没装上)</span></span><br><span class="line">    <span class="keyword">for</span> (FRawObjectIterator <span class="built_in">It</span>(<span class="literal">false</span>); It; ++It)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (UClass* Class = Cast&lt;UClass&gt;((UObject*)(It-&gt;Object)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!GExitPurge &amp;&amp; !Class-&gt;<span class="built_in">HasAnyFlags</span>(RF_BeingRegenerated))</span><br><span class="line">			&#123;</span><br><span class="line">				Class-&gt;<span class="built_in">GetDefaultObject</span>(); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!Class-&gt;<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject) &amp;&amp; !Class-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_TokenStreamAssembled))</span><br><span class="line">			&#123;</span><br><span class="line">				Class-&gt;<span class="built_in">AssembleReferenceTokenStream</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UClass::AssembleReferenceTokenStream</span><span class="params">(<span class="keyword">bool</span> bForce = <span class="comment">/*false*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Lock for non-native classes</span></span><br><span class="line">	<span class="function">FScopeLockIfNotNative <span class="title">ReferenceTokenStreamLock</span><span class="params">(ReferenceTokenStreamCritical, !(ClassFlags &amp; CLASS_Native))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该 &quot;Class&quot; 没有创建 &quot;TokenStream&quot;，或者被要求强制创建</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">HasAnyClassFlags</span>(CLASS_TokenStreamAssembled) || bForce)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (bForce)</span><br><span class="line">		&#123;</span><br><span class="line">			ReferenceTokenStream.<span class="built_in">Empty</span>();</span><br><span class="line">			ClassFlags &amp;= ~CLASS_TokenStreamAssembled;</span><br><span class="line">		&#125;</span><br><span class="line">		TArray&lt;<span class="keyword">const</span> FStructProperty*&gt; EncounteredStructProps;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历定义在这个类中的所有FProperty(支持反射的属性)</span></span><br><span class="line">		<span class="keyword">for</span>( TFieldIterator&lt;FProperty&gt; <span class="built_in">It</span>(<span class="keyword">this</span>,EFieldIteratorFlags::ExcludeSuper); It; ++It)</span><br><span class="line">		&#123;</span><br><span class="line">			FProperty* Property = *It;</span><br><span class="line">            <span class="comment">// 将该属性加入到 &quot;UClass&quot; 的 &quot;ReferenceTOkenStream&quot; (用于GC的引用记号流)，其调用链下文会进行分析</span></span><br><span class="line">			Property-&gt;<span class="built_in">EmitReferenceInfo</span>(*<span class="keyword">this</span>, <span class="number">0</span>, EncounteredStructProps);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (UClass* SuperClass = <span class="built_in">GetSuperClass</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 这里需要锁父类流是为了避免其在游戏线程被重构</span></span><br><span class="line">			<span class="function">FScopeLockIfNotNative <span class="title">SuperClassReferenceTokenStreamLock</span><span class="params">(SuperClass-&gt;ReferenceTokenStreamCritical, !(SuperClass-&gt;ClassFlags &amp; CLASS_Native))</span></span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 确保父类的 &quot;ReferenceTokenStream&quot; 已初始化</span></span><br><span class="line">			SuperClass-&gt;<span class="built_in">AssembleReferenceTokenStream</span>();</span><br><span class="line">			<span class="keyword">if</span> (!SuperClass-&gt;ReferenceTokenStream.<span class="built_in">IsEmpty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将父类的 &quot;ReferenceTokenStream&quot; 加入到自己这里</span></span><br><span class="line">				ReferenceTokenStream.<span class="built_in">PrependStream</span>(SuperClass-&gt;ReferenceTokenStream);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 如果该对象参与反射，而又没有基类对象。想想会是什么情况？那必然是 &quot;UObject&quot; 呀，所以直接加到永久对象引用里面 </span></span><br><span class="line">			UObjectBase::<span class="built_in">EmitBaseReferences</span>(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">check</span>(ClassAddReferencedObjects != <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bKeepOuter = <span class="literal">true</span>;	<span class="comment">// GetFName() != NAME_Package;</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">bool</span> bKeepClass = <span class="literal">true</span>;	<span class="comment">// !HasAnyInternalFlags(EInternalObjectFlags::Native) || IsA(UDynamicClass::StaticClass());</span></span><br><span class="line"></span><br><span class="line">			ClassAddReferencedObjectsType AddReferencedObjectsFn = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !WITH_EDITOR</span></span><br><span class="line">			<span class="comment">// 非编辑器模式下 &quot;UObject::ARO&quot; 是空的，所以不需要 &quot;ARO&quot; 来生成记号流</span></span><br><span class="line">            <span class="comment">// 只有实现了自己的 &quot;ARO&quot; 函数的类才需要生成记号流</span></span><br><span class="line">			<span class="keyword">if</span> (ClassAddReferencedObjects != &amp;UObject::AddReferencedObjects)</span><br><span class="line">			&#123;</span><br><span class="line">				AddReferencedObjectsFn = ClassAddReferencedObjects;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			AddReferencedObjectsFn = ClassAddReferencedObjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 修复父类记号流连接后的一些后处理，修复 &quot;ReferenceTokenStream&quot; 的 &quot;TokenIndex&quot; </span></span><br><span class="line">			ReferenceTokenStream.<span class="built_in">Fixup</span>(AddReferencedObjectsFn, bKeepOuter, bKeepClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ReferenceTokenStream.<span class="built_in">IsEmpty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为引用记号流添加一个末尾元素</span></span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FName <span class="title">EOSDebugName</span><span class="params">(<span class="string">&quot;EndOfStreamToken&quot;</span>)</span></span>;</span><br><span class="line">		<span class="built_in">EmitObjectReference</span>(<span class="number">0</span>, EOSDebugName, GCRT_EndOfStream);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 收缩引用记号流至适当的Size</span></span><br><span class="line">		ReferenceTokenStream.<span class="built_in">Shrink</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 &quot;UClass&quot; 标记为已创建 &quot;TokenStream&quot;</span></span><br><span class="line">		ClassFlags |= CLASS_TokenStreamAssembled;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后，&quot;CloseDisregardForGC&quot; 将在 &quot;EngineLoop::PreInit&quot; 的最后阶段被调用，从而调用 &quot;AssembleReferenceTokenStreams&quot; 来创建所有 &quot;UClass&quot; 的引用记号流，而这也将是我们这次旅程的终点。整篇博客写下来，其实并不是一直在讲 &quot;UClass&quot; 的生成过程，有挺大一部分篇幅是在解释 引擎为什么要这么做。因为我认为阅读源码不仅仅是为了搞清楚这一块是怎么实现的，很多时候我们更应该问一下自己，为什么引擎会选择这种做法，知其然不如知其所以然。如果让我们来实现这一块的功能，我又是否会想到这种方法，亦或者其他的方案，我认为这些都是很值得我们去思考的。</p><p>最后的最后总结一下整个流程吧。</p><ul><li>编译，&quot;UHT&quot; 为我们生成两个用于实现反射的类，其需要配合 &quot;ObjectMacros&quot; 这个类来进行使用</li><li>收集，在我们引擎初始化之前 (WinMain 之前)，C++ 会生成 static 类，而这也是我们收集每个模块的类信息的一个时机，这直接决定了我们后面会初始化那些类的 &quot;UClass&quot;</li><li>注册，在这个阶段我们会为所有收集到的 &quot;UClass&quot; 申请内存，并调用其构造函数，但在此之前我们需要先 Startup &quot;CoreUObject&quot; 模块，因为这里面有我们的 &quot;UObjectAllocator&quot;，我们申请内存要用到他。最后我们会把处理好的 &quot;UClass&quot; 加到延迟注册的列表里面，等待下一步处理</li><li>延迟注册，这一步我们会去丰富刚刚注册过的 &quot;UClass&quot;，包括一些私有属性的设置 &quot;SuperClass&quot;, &quot;PackageName&quot; 等等，我们还会将 &quot;UClass&quot; 对象添加进全局唯一的 &quot;FUObjectHashTables&quot; 里面，以实现何时何地都能利用 &quot;UObject 系统&quot; 的反射的便利。当然还会对其 UFunction 进行处理</li><li>后处理（也是注册），我们继续前进，初始化了 &quot;UClass&quot; 的其他属性（链接函数，属性链，接口数组，元数据等），创建并初始化 &quot;CDO&quot;。最后还处理了 &quot;UClass&quot; 的引用记号流。到此，完事收工。</li></ul><p>结语：旅程结束，有点累，不过很值得。期待与你的下一次旅程 😃</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-11-17 19:03:11" itemprop="dateModified" datetime="2021-11-17T19:03:11+08:00">2021-11-17</time> </span><span id="2021/11/08/UE4/UE4CPP/UClass的诞生与成长/" class="item leancloud_visitors" data-flag-title="UClass的诞生与成长" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>-YIFEI- <i class="ic i-at"><em>@</em></i>一个年轻人奔向梦想的足迹</li><li class="link"><strong>本文链接：</strong> <a href="https://kotori_suki.github.io/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" title="UClass的诞生与成长">https://kotori_suki.github.io/2021/11/08/UE4/UE4CPP/UClass的诞生与成长/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicitcxhpij20zk0m8hdt.jpg" title="Unreal GC过程"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>Unreal GC过程</h3></a></div><div class="item right"><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhpw3lwj20zk0m8gvw.jpg" title="UE4代理的实现与用法"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> UE4_C++</span><h3>UE4代理的实现与用法</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#uclass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF"><span class="toc-number">1.</span> <span class="toc-text">UClass 的诞生与成长</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uclass-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">UClass 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-generated_body-%E5%BC%80%E5%A7%8B"><span class="toc-number">1.2.</span> <span class="toc-text">从 &quot;GENERATED_BODY ()&quot; 开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#declare_class"><span class="toc-number">1.2.1.</span> <span class="toc-text">DECLARE_CLASS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0uclass%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.3.</span> <span class="toc-text">回到 UClass 的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uclass%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">UClass 的信息收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#implement_class"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">IMPLEMENT_CLASS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#z_compiledindefer_uclass_umyclassname"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Z_CompiledInDefer_UClass_UMyClassName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#z_construct_uclass_umyclassname"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Z_Construct_UClass_UMyClassName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constructuclass"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">ConstructUClass</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uclass%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">UClass 的注册</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uclassregisterallcompiledinclasses"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">UClassRegisterAllCompiledInClasses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getprivatestaticclassbody"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">GetPrivateStaticClassBody</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uclassuclass"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">UClass::UClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initializeprivatestaticclass"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">InitializePrivateStaticClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registernativefunc"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">RegisterNativeFunc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uclass%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B3%A8%E5%86%8Ca-iduclass%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%B3%A8%E5%86%8Ca"><span class="toc-number">1.3.3.</span> <span class="toc-text">UClass 的延迟注册 &lt;a id&#x3D;&quot;UClass 的延迟注册&quot;&gt;&lt;&#x2F;a&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#staticuobjectinit"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">StaticUObjectInit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uobjectbaseinit"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">UObjectBaseInit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uobjectprocessregistrants"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">UObjectProcessRegistrants</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uobjectforceregistration"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">UObjectForceRegistration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashobject"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">HashObject</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E6%B3%A8%E5%86%8C%E7%9A%84%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">后处理（注册的后半部分）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#processnewlyloadeduobjects"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">ProcessNewlyLoadedUObjects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uobjectloadallcompiledindefaultproperties"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">UObjectLoadAllCompiledInDefaultProperties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getdefaultobject"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">GetDefaultObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#assemblereferencetokenstreams"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">AssembleReferenceTokenStreams</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/08/05/UE4/UE4CPP/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="UE4多线程">UE4多线程</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" rel="bookmark" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></li><li><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetPlayerController/" rel="bookmark" title="API不正常工作 之 GetPlayerController">API不正常工作 之 GetPlayerController</a></li><li><a href="/2021/10/25/UE4/UE4CPP/unreal%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" rel="bookmark" title="unreal引擎启动流程">unreal引擎启动流程</a></li><li><a href="/2021/10/26/UE4/UE4CPP/%E4%BB%8ESVG%E6%96%87%E4%BB%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%85%E7%A8%8B/" rel="bookmark" title="从SVG文件开始的旅程~~~">从SVG文件开始的旅程~~~</a></li><li><a href="/2021/10/29/UE4/UE4CPP/%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%20API/" rel="bookmark" title="反射系统API  解析和使用">反射系统API 解析和使用</a></li><li><a href="/2021/10/31/UE4/UE4CPP/Session%E7%9A%84%E4%BD%BF%E7%94%A8%20C++%E7%AF%87/" rel="bookmark" title="Session的使用 C++篇">Session的使用 C++篇</a></li><li><a href="/2021/11/02/UE4/UE4CPP/Unreal%20%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Unreal 序列化~~~">Unreal 序列化~~~</a></li><li><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="bookmark" title="Unreal GC过程">Unreal GC过程</a></li><li class="active"><a href="/2021/11/08/UE4/UE4CPP/UClass%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E6%88%90%E9%95%BF/" rel="bookmark" title="UClass的诞生与成长">UClass的诞生与成长</a></li><li><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="bookmark" title="UE4代理的实现与用法">UE4代理的实现与用法</a></li><li><a href="/2021/11/15/UE4/UE4CPP/FProperty%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="FProperty的分析与总结">FProperty的分析与总结</a></li><li><a href="/2021/11/22/UE4/UE4CPP/Unreal%20%E5%A4%9A%E7%A7%8D%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="bookmark" title="Unreal 多种指针实现原理">Unreal 多种指针实现原理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="-YIFEI-" data-src="/images/avatar.jpg"><p class="name" itemprop="name">-YIFEI-</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">44</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tvdG9yaS1TdWtp" title="https:&#x2F;&#x2F;github.com&#x2F;Kotori-Suki"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS90dnQtNjA=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tvt-60"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/11/06/UE4/UE4CPP/Unreal%20GC%E8%BF%87%E7%A8%8B/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/11/11/UE4/UE4CPP/UE4%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%94%A8%E6%B3%95/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C/" title="分类于 插件制作">插件制作</a></div><span><a href="/2021/08/05/UE4/UE4Plugin/UE4_Plugin/" title="UE4 插件">UE4 插件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/10/25/UE4/UE4CPP/API%E4%B8%8D%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C-%E4%B9%8B-GetGameMode/" title="API不正常工作 之 GetGameMode">API不正常工作 之 GetGameMode</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/11/22/CPPBase/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20%E5%A4%8D%E5%88%BB/" title="C++智能指针 复刻">C++智能指针 复刻</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UE4/" title="分类于 UE4">UE4</a> <i class="ic i-angle-right"></i> <a href="/categories/UE4/UE4CPP/" title="分类于 UE4_C++">UE4_C++</a></div><span><a href="/2021/08/05/UE4/UE4CPP/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="UE4多线程">UE4多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 创建型模式">创建型模式</a></div><span><a href="/2021/08/17/CPPBase/DesignPattern/Builder/" title="建造者模式">建造者模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/Observe/" title="观察者模式">观察者模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a></div><span><a href="/2021/08/16/CPPBase/C++%E6%8C%87%E9%92%88/" title="C++指针">C++指针</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/2021/08/16/ComputerBase/Algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ComputerBase/" title="分类于 计算机基础">计算机基础</a> <i class="ic i-angle-right"></i> <a href="/categories/ComputerBase/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="分类于 操作系统">操作系统</a></div><span><a href="/2021/08/16/ComputerBase/OperatingSystem/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="进程 线程 多线程">进程 线程 多线程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CPPBase/" title="分类于 C++基础">C++基础</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="分类于 设计模式">设计模式</a> <i class="ic i-angle-right"></i> <a href="/categories/CPPBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="分类于 行为型模式">行为型模式</a></div><span><a href="/2021/08/19/CPPBase/DesignPattern/Strategy/" title="策略模式">策略模式</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">-YIFEI- @ Afei's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/11/08/UE4/UE4CPP/UClass的诞生与成长/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>